# $\textbf{Rest of DB}$ 

# $\textbf{1. Data Administration}$​ 

> ## $\textbf{1.1. Overview}$ 
>
> >
> > **1️⃣**$\text{Capacity Planning:}$ 预测未来$\text{DB}$的符合$\text{→}$预测系统会何时饱和$\text{→}$尽可能延长饱和的时间
> >
> > **2️⃣**大小计算
> >
> > |    $\textbf{Size}$     | 描述                                        |
> > | :--------------------: | :------------------------------------------ |
> > | $\text{Database Size}$ | $\text{Sum of all Table sizes}$             |
> > |  $\text{Table Size}$   | $\text{Number of rows * Average row width}$ |
> > |   $\text{Row Size}$    | $\text{Sum of sizes of all attributes}$     |
>
> ## $\textbf{1.2. }$​例题
>
> > **1️⃣**$\text{DB}$更新数据
> >
> > |        表格         |  起始数量  | 更新                                                         |
> > | :-----------------: | :--------: | :----------------------------------------------------------- |
> > | $\text{Suppliers}$  | $\text{0}$ | 新增$\text{1000 Suppliers/Year}$                             |
> > | $\text{Puerchases}$ | $\text{0}$ | 新增$\text{10000 Purchases/Year}$，$\text{1-Purchase}\xleftrightarrow{对应}\text{10-Items}$ |
> > |   $\text{Items}$    | $\text{0}$ | 新增$\text{2000 Items/Year}$                                 |
> >
> > **2️⃣**$\text{Size of Row}$ 
> >
> > |      $\textbf{Table Name}$      | $\textbf{Size of Row(Byte)}$ |
> > | :-----------------------------: | :--------------------------: |
> > |  $\text{Purchase(Normalized)}$  |         $\text{50}$          |
> > | $\text{Purchase(Denormalized)}$ |         $\text{110}$         |
> > |        $\text{Supplier}$        |         $\text{50}$          |
> > |      $\text{PurchaseItem}$      |         $\text{12}$          |
> > |          $\text{Item}$          |         $\text{50}$          |
> >
> > **3️⃣**$\text{Normalized}$模式下：数据库运行两年后，会占用多大存储空间$\text{ ?}$ 
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240527193246239.png" alt="image-20240527193246239" style="zoom: 31%;" /> 
> >
> > - $\text{2×1000×50+2×10000×50+2×100000×12+2×2000×50=3700000Bytes=3613.28KB}$ 
> >
> > **4️⃣**$\text{Denoemalized}$模式下：数据库运行两年后，会占用多大存储空间$\text{ ?}$ 
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240527194017901.png" alt="image-20240527194017901" style="zoom: 29%;" /> 
> >
> > - $\text{2×10000×110+2×100000×12+2×2000×50=4800000Bytes=4687.5KB}$  

# $\textbf{2. DB Backup}$​ 

> ## $\textbf{2.1. Overview}$ 
>
> > **1️⃣**可能出现数据丢失的$\text{Fails}$ 
> >
> > |    $\textbf{Failure Type}$    | $\textbf{Description}$                          |
> > | :---------------------------: | ----------------------------------------------- |
> > |  $\text{Statement failure}$   | 语法错误                                        |
> > | $\text{User Process failure}$ | 处理过程中的错误，比如$\text{Power Outage}$断电 |
> > |   $\text{Network failure}$    | 断网                                            |
> > |      $\text{User error}$      | 用户手欠导致的错误，比如误删掉某个表格          |
> > |    $\text{Memory failure}$    | 内存出错                                        |
> > |    $\text{Media Failure}$     | 硬盘出错                                        |
> >
> > **2️⃣**$\text{Backup}$​​的意义就在于，出现上述情况时防止数据丢失
>
> ## $\textbf{2.2. Backup}$种类
>
> > **1️⃣**$\text{Backup}$种类：$\text{Physical \& Logical}$ 
> >
> > |    $\textbf{Item}$    | $\textbf{Physical}$                                        | $\textbf{Logical}$   |
> > | :-------------------: | :--------------------------------------------------------- | :------------------- |
> > | $\text{Backup}$的内容 | 实体表格($\text{File+Dictionary}$)                         | $\text{SQL}$代码     |
> > |      数据库状态       | 一般$\text{Offline(Cold Backup)}$，但也可以$\text{Online}$ | 必须$\text{Online}$  |
> > |       备份速度        | 快(直接复制文件表格，无需转成$\text{SQL}$)                 | 慢                   |
> > | $\text{Log}$日志文件  | 包含在备份中                                               | 不包含在备份中       |
> > |     关于系统配置      | 备份后的文件要在相似的系统配置上才能运行                   | 备份独立于具体的机器 |
> >
> > **2️⃣**$\text{Online \& Offline:}$ 指备份的时候，数据库要在线($\text{Available}$)/下线($\text{Shut Down}$​) 
> >
> > **3️⃣**$\text{Full \& Incremental:}$​ 备份的起始点，是数据库诞生开始/上一次备份完开始
> >
> > **4️⃣**$\text{Onsite \& Offsite:}$​ 备份在本地/云端，还有就是本地备份肯定更快
>
> ## $\textbf{2.3. Backup}$方式选择: 抓住题目关键词
>
> > **1️⃣**$\text{Physical or Logical:}$  如果是$\text{Time-Critical}$就选择$\text{Pyhsical}$​，因为其速度更快
> >
> > **2️⃣**$\text{Online \& Offline:}$ 如果要求数据库$\text{24h×7day}$不停歇工作，则必须是$\text{Online}$​ 
> >
> > **3️⃣**$\text{Onsite \& Offsite:}$ 
> >
> > 1. 云端备份是否有意义，如多个工厂共用一个$\text{DB}$，防止某工厂发生灾害，备份云端就有意义
> >
> > 2. 如果是$\text{Time-Critical}$也需考虑选$\text{Onsite}$​ 
> >
> > **4️⃣**$\text{Full \& Incremental:}$
> >
> > 1. 当使用不频繁时选择$\text{Full}$(比如周末)，使用频繁时选择$\text{Incremental}$​(比如工作日)
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240527223901294.png" alt="image-20240527223901294" style="zoom:50%;" /> 
> >
> > 2. 实质上二者经常交叉混用

# $\textbf{3. Data Warehouse}$​ 

> ## $\textbf{3.0. }$前言：两种$\textbf{DB}$ 
>
> > |   $\textbf{DB Type}$   | 适用情况                                | 备注                                                         |
> > | :--------------------: | --------------------------------------- | :----------------------------------------------------------- |
> > | $\text{Transactional}$ | 涉及表少(不需要太多$\text{Join}$)       | 比如$\text{Relational DB}$                                   |
> > | $\text{Informational}$ | 涉及表格多，解决$\text{Analytical}$问题 | $\text{Trans DB}\xrightarrow{\text{Data Warehouse}}\text{Info DB}$ |
>
> ## $\textbf{3.1. Data Warehouse}$概述
>
> > **1️⃣**$\text{Data Warehouse}$特点
> > 
> > | 特点                                | 描述                                                    |
> > | :---------------------------------- | ------------------------------------------------------- |
> > | $\text{Subject Oriented}$           | $\text{Data Warehouse}$需要有特定的分析目标             |
> > | $\text{Validated, Integrated Data}$ | 数据转为同一模式(即$\text{Dimensional Model}$)          |
> > | $\text{Time Variant}$               | 存在时间维度，历史数据被用来分析趋势                    |
> > | $\text{Non-Volatile}$(非易失性)     | 用户对$\text{Data Warehouse}$只读，如果要更改则见下补充 |
> >
> > **2️⃣**补充：如何修改$\text{Data Warehouse}$ 
> > $$
> > 更改\text{Trans DB}\xrightarrow{\text{ETL/DBA}\begin{cases}\text{ETL: 即Extract/Transform/Load过程}\\\\\text{DBA: 即DB Administration(人为干预)}\end{cases}}更改\text{Info DB/Data Warehouse}
> > $$
> > 
>
> ## $\textbf{3.2. Dimensional Modelling}$
>
> > **1️⃣**$\text{Fact \& Dimension:}$ 可类比为因变量/自变量
> >
> > |   $\text{Item}$    | 描述             | 示例                                           |
> > | :----------------: | ---------------- | ---------------------------------------------- |
> > |   $\text{Fact}$    | 测量与分析的目标 | 产品$\text{G}$过去三月的销量                   |
> > | $\text{Dimension}$ | 衡量目标的维度   | 产品销售的地区，产品的促销力度，产品投放的时间 |
> >
> > **2️⃣**$\text{Star Schema: Fact Table+Dimension Table}$​​​​ 
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240528002136546.png" alt="image-20240528002136546" style="zoom:50%;" /> 
> >
> > 1. $\text{Fact Table}$​置于中间
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240528011806796.png" alt="image-20240528011806796" style="zoom:33%;" />  
> >
> >    - 存放了所有$\text{Dimension Table}$的$\text{PK}$(其实是$\text{PFK}$​)，这样利于不同表格快速相$\text{Join}$ 
> >    - 还存放了$\text{Fact}$，此处为$\text{PRICE/QUANTITY}$ 
> >
> > 2. $\text{Dimension Table:}$​  
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240528012430298.png" alt="image-20240528012430298" style="zoom: 40%;" /> 
> >
> >    - 置于周围，有$\text{N}$个$\text{Dimension Table}$就是$\text{N-Dimension}$​ 
> >    - 处于$\text{Denormalized}$​状态，若存在$\text{Hierarchies}$(比如$\text{Product}$高$\text{Sale}$一级)则可标准化
> >
> > **3️⃣**$\text{Star Schema}\xrightarrow[向外延展]{将\text{Dimension Table}规范化}\text{Snowflake Schema}$ 
> >
> >   <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240528003747856.png" alt="image-20240528003747856" style="zoom: 33%;" />

# $\textbf{4. Distributed DB}$​ 

> ## $\textbf{4.1. Distributed DB}$概念
>
> > **1️⃣**几种数据库
> >
> > |      $\textbf{Type}$      | 描述                                                         |
> > | :-----------------------: | ------------------------------------------------------------ |
> > |  $\text{Centralized DB}$  | 将整个数据库放到一个$\text{Location}$                        |
> > | $\text{Decentralized DB}$ | 将整个数据库分为几块，每块放到不同的$\text{Location}$        |
> > |  $\text{Distributed DB}$  | 将整个数据库分为几块，每块放到不同的$\text{Location}$，并通过网络互联 |
> >
> > **2️⃣**$\text{Distributed DB}$​结构示意图
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240528020053662.png" alt="image-20240528020053662" style="zoom: 33%;" /> 
> >
> > 1. $\text{DB}$不同部分由$\text{Communication Network/Link}$互联，任一部分可访问其他所有部分的数据
> > 2. 此处有两个$\text{DB1}$这是允许的，但是要确保连个$\text{DB1}$​的数据尽可能一致
>
> ## $\textbf{4.2. Distributed DB}$的特点
>
> > **1️⃣**$\text{Distributed DB}$的优点
> >
> > 1. 加快访问/处理数据的速度：比如$\text{L1}$处要频繁访问$\text{DB1}$，将$\text{DB1}$放在$\text{L1}$​处就可以加快访问速度
> >
> > 2. 允许$\text{Modular Growth}$/具有$\text{Horizontal Scalability}$​(横向扩展)
> >
> >    - $\text{Vertical Scaling:}$ 在$\text{Centralized DB}$中增加磁盘空间
> >
> >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240528021157893.png" alt="image-20240528021157893" style="zoom: 25%;" /> 
> >
> >    - $\text{Horizontal Scaling:}$ 在$\text{Distributed DB}$中增加节点，并用网络连接；==成本要低得多== 
> >
> >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240528021435381.png" alt="image-20240528021435381" style="zoom: 35%;" /> 
> >
> > 3. 稳定性更高：一个节点崩了不会导致整个系统崩了
> >
> > **2️⃣**$\text{Distributed DB}$的缺点
> >
> > 1. $\text{Management and Control}$更复杂，维护更复杂
> > 2. 需要保证数据一致性($\text{Integrity}$)：比如有多个$\text{DB1}$节点，用户改变一$\text{DB1→}$所有$\text{DB1}$​都变
> > 3. 安全问题更严峻：节点越多越容易被黑
>
> ## $\textbf{4.3. Distribution Option}$ 
>
> > **1️⃣**$\text{Partitioned/Replicated}$方式：但注意一般实际会采用二者的结合
> >
> > |  $\textbf{Option}$   | 描述：将数据库$\_\_$ | 示例                 |    可靠性    | 访问(本地)数据 |     存储     |
> > | :------------------: | :------------------: | -------------------- | :----------: | :------------: | :----------: |
> > | $\text{Replicated}$  |    完整地复制几块    | $\small\text{ABC→3×ABC}$ | 高 |慢      |       大       |
> > | $\text{Partitioned}$ |    拆为不同的几块    | $\small\text{ABC→A+B+C}$ |      低      | 快 |      小      |
> > |    $\text{Mixed}$    |      前二者混合      | $\small\text{ABC→AB+BC+C}$ | $\text{N/A}$ |  $\text{N/A}$  | $\text{N/A}$ |
> >
> > **2️⃣**$\text{Partitioned}$的两种方式： 把数据横着/竖着切开$\text{→Horizontal/Vertical}$​  
> >
> > |        方式         | 描述：分割表的操作                                 | 数据还原                                  |
> > | :-----------------: | -------------------------------------------------- | ----------------------------------------- |
> > | $\text{Horizontal}$ | 把不同的$\text{Row}$放在不同的$\text{Location}$    | 将不同$\text{Location}$数据$\text{UNION}$ |
> > |  $\text{Vertical}$  | 把不同的$\text{Column}$放在不同的$\text{Location}$ | 将不同$\text{Location}$数据$\text{JOIN}$  |
> >
> > - $\text{PS: Vertical}$会改变表格的$\text{Schema}$​，因此更复杂
>
> ## $\textbf{4.4. CAP}$理论：不可能三角
>
> > **1️⃣**概述
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240528025831917.png" alt="image-20240528025831917" style="zoom: 43%;" /> 
> >
> > |             性质             | 描述                           | 对应更新选项                        |
> > | :--------------------------: | :----------------------------- | ----------------------------------- |
> > | $\text{Partition Tolerance}$ | 某节点网络失联后，系统任能运行 | $\text{N/A}$                        |
> > |     $\text{Consistency}$     | 所有用户看到的数据都一致       | 数据立即更新($\text{Synchronous}$)  |
> > |    $\text{Availability}$     | 每个请求都有回应，即使节点故障 | 数据延迟更新($\text{Asynchronous}$) |
> >
> > **2️⃣**$\text{Distributed DB:}$ 由于有多个节点，必须选择$\text{Partition Tolerance}$ 
> >
> > 1. 当节点失联后还==使用==节点$\text{→}$再选择$\text{Availability}$  
> > 2. 当节点失联后就==丢弃==节点$\text{→}$再选择$\text{Consistency}$ ​
> >
> > **3️⃣**$\text{Transactional DB:}$ 仅一个节点不存在网络问题$\to$大概率只能选$\text{Availability+Consistency}$ 

# $\textbf{5. NoSQL}$ 

> ## $\textbf{5.1. NoSQL}$概述
>
> > **1️⃣**$\text{NoSQL}$的引入：要解决$\text{Objected Oriented}$(面向对象)问题，而传统$\text{Relational Model}$办不到 
> >
> > **2️⃣**$\text{NoSQL}$的作用：存储大量数据
> >
> > 1. $\text{Bigdata}$的特点：$\text{3V}$ ($\text{Volume}$/量大，$\text{Variety}$/种类多，$\text{Velocity}$​/数据生成快)
> >
> > 2. $\text{NoSQL}$存储数据的方式：$\text{Schema On Read}$​
> >
> >    - $\text{Schema On Read:}$ 先快速存储数据，稍后再选择数据$\text{Model}$ 
> >    - $\text{Schema On Write:}$ 先决定数据的$\text{Model}$​，再存储数据
> >
> > 3. $\text{Data Lake:}$ 存储数据的大型集成$\text{Repository}$ 
> >
> > **3️⃣**$\text{NoSQL}$更契合$\text{Distributed DB}$​的思想：
> >
> > 1. 在$\text{CAP}$中选择$\text{Partition Tolerance+Availability}$ 
> > 2. 由于主要用于存数据，所以比起一致性对数据可访问性要求更高
>
> ## $\textbf{5.2. NoSQL}$种类 
>
> > **1️⃣**$\text{Key-Value}$
> >
> > 1. 结构：类似于目录结构，通过$\text{Primary Key}$索引，对应其下的$\text{Value}$可以放任何东西
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240528074434447.png" alt="image-20240528074434447" style="zoom:28%;" />  
> >
> > 2. 特点：最灵活，但结构化程度最弱
> >
> > **2️⃣**$\text{Document:}$ 
> >
> > 1. 结构：将数据存储在文件中，比如$\text{Json/XML}$​ 
> > 2. 比如$\text{MangoDB}$ 
> >
> > **3️⃣**$\text{Column Family:}$​ 类似于$\text{Vertical Partition}$将每列存储为一个表格
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240528075841058.png" alt="image-20240528075841058" style="zoom: 23%;" /> 
> >
> > **4️⃣**$\text{Graphic-Oriented:}$​ 
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/38311088324.png" alt="38311088324" style="zoom:50%;" /> 
> >
> > 1. 图边$\xleftrightarrow{}$关系，图节点$\xleftrightarrow{}$​实体
> > 2. 适合用于追溯不同实体间的关系
>
> ## $\textbf{5.3. BASE}$​理论$\textbf{For NoSQL}$ 
>
> > **1️⃣**$\text{Basically Avaliable:}$ 选择$\text{Partition Tolerance}$基础上，确保$\text{Availbility}$而非$\text{Consistency}$​ 
> >
> > **2️⃣**$\text{Evental Consistency:}$ 系统从停止接收数据开始，终将会(慢慢更新)到达$\text{Evental Consistency}$ 
> >
> > **3️⃣**$\text{Soft State:}$ 在最终一致状态($\text{Evental Consistency}$)前，系统状态会随时改变 



 