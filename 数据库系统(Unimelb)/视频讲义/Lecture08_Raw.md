<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240322190740263.png" alt="image-20240322190740263" style="zoom:50%;" /> 

Hello, everyone, and welcome back to the eighth lecture of our database systems series. Today, we will be diving into SQL, or Structured Query Language, which is the primary language used for interacting with and manipulating data in relational databases. This session aims to bridge the theoretical concepts of relational algebra, discussed in our previous lecture, with their practical application in SQL. By understanding how relational algebra principles translate into SQL commands, you will gain a deeper insight into the efficient management and manipulation of database information. So, let's embark on this journey to explore the intricacies of SQL and its pivotal role in the realm of relational databases.

å¤§å®¶å¥½ï¼Œæ¬¢è¿å›åˆ°æˆ‘ä»¬æ•°æ®åº“ç³»ç»Ÿç³»åˆ—çš„ç¬¬å…«è®²ã€‚ä»Šå¤©ï¼Œæˆ‘ä»¬å°†æ·±å…¥æ¢è®¨SQLï¼Œæˆ–ç»“æ„åŒ–æŸ¥è¯¢è¯­è¨€ï¼Œè¿™æ˜¯ç”¨äºä¸å…³ç³»æ•°æ®åº“ä¸­çš„æ•°æ®è¿›è¡Œäº¤äº’å’Œæ“ä½œçš„ä¸»è¦è¯­è¨€ã€‚æœ¬æ¬¡è¯¾ç¨‹æ—¨åœ¨å°†ä¸Šä¸€è®²è®¨è®ºçš„å…³ç³»ä»£æ•°çš„ç†è®ºæ¦‚å¿µä¸SQLçš„å®é™…åº”ç”¨æ¡¥æ¥èµ·æ¥ã€‚é€šè¿‡ç†è§£å…³ç³»ä»£æ•°åŸç†å¦‚ä½•è½¬åŒ–ä¸ºSQLå‘½ä»¤ï¼Œæ‚¨å°†æ›´æ·±å…¥åœ°äº†è§£æ•°æ®åº“ä¿¡æ¯çš„é«˜æ•ˆç®¡ç†å’Œæ“ä½œã€‚é‚£ä¹ˆï¼Œè®©æˆ‘ä»¬å¼€å§‹è¿™ä¸€æ—…ç¨‹ï¼Œæ¢ç´¢SQLçš„å¤æ‚æ€§åŠå…¶åœ¨å…³ç³»æ•°æ®åº“é¢†åŸŸä¸­çš„å…³é”®ä½œç”¨ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240322190815278.png" alt="image-20240322190815278" style="zoom:50%;" /> 

When exploring SQL, we encounter a fundamental concept known as CRUD, which is a recurrent acronym you'll often come across while researching SQL online. CRUD is nothing mysterious; it stands for Create, Read, Update, and Delete, encapsulating the core commands that SQL facilitates. These commands are essential as they are also supported by the majority of relational database systems. Throughout our lectures, we'll be examining SQL as a universal language. However, for those who may find themselves seeking additional guidance, I recommend consulting concise and clear tutorials. These resources can be incredibly beneficial, especially for those who are engaging with SQL for the first time.

å½“æˆ‘ä»¬æ¢ç´¢SQLæ—¶ï¼Œä¼šé‡åˆ°ä¸€ä¸ªåŸºæœ¬æ¦‚å¿µï¼Œå³CRUDï¼Œè¿™æ˜¯ä¸€ä¸ªåœ¨ç½‘ä¸Šç ”ç©¶SQLæ—¶ç»å¸¸é‡åˆ°çš„é‡è¦ç¼©å†™è¯ã€‚CRUDå¹¶æ²¡æœ‰ä»€ä¹ˆç¥ç§˜çš„ï¼›å®ƒä»£è¡¨äº†Createï¼ˆåˆ›å»ºï¼‰ï¼ŒReadï¼ˆè¯»å–ï¼‰ï¼ŒUpdateï¼ˆæ›´æ–°ï¼‰å’ŒDeleteï¼ˆåˆ é™¤ï¼‰ï¼Œè¿™äº›æ˜¯SQLæ”¯æŒçš„æ ¸å¿ƒå‘½ä»¤ã€‚è¿™äº›å‘½ä»¤éå¸¸é‡è¦ï¼Œå› ä¸ºå®ƒä»¬ä¹Ÿç”±å¤§å¤šæ•°å…³ç³»æ•°æ®åº“ç³»ç»Ÿæ”¯æŒã€‚åœ¨æˆ‘ä»¬çš„è¯¾ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†æŠŠSQLä½œä¸ºä¸€ç§é€šç”¨è¯­è¨€æ¥ç ”ç©¶ã€‚ä½†æ˜¯ï¼Œå¯¹äºé‚£äº›å¯èƒ½åœ¨å¯»æ±‚é¢å¤–æŒ‡å¯¼çš„äººï¼Œæˆ‘æ¨èæŸ¥é˜…ç®€æ˜æ¸…æ™°çš„æ•™ç¨‹ã€‚è¿™äº›èµ„æºå¯¹äºç¬¬ä¸€æ¬¡æ¥è§¦SQLçš„äººæ¥è¯´å¯èƒ½ç‰¹åˆ«æœ‰å¸®åŠ©ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240322190913106.png" alt="image-20240322190913106" style="zoom:50%;" /> 

The SQL language is versatile, comprising various command types, or sub-languages, namely DDL, DML, and DCL. DDL, the Data Definition Language, is tasked with structuring the database schema. It enables us to construct tables, append new columns, or remove existing ones, essentially shaping the database schema. Then, there's DML, or Data Manipulation Language, which is designed for handling the actual data within the database. This includes inserting new data, updating existing data, deleting records, and using the SELECT statement to query the database.

SQLè¯­è¨€éå¸¸å¤šæ‰å¤šè‰ºï¼ŒåŒ…å«äº†å¤šç§å‘½ä»¤ç±»å‹æˆ–å­è¯­è¨€ï¼Œå³DDLã€DMLå’ŒDCLã€‚DDLï¼Œæ•°æ®å®šä¹‰è¯­è¨€ï¼Œè´Ÿè´£æ„é€ æ•°æ®åº“æ¶æ„ã€‚å®ƒä½¿æˆ‘ä»¬èƒ½å¤Ÿæ„å»ºè¡¨æ ¼ï¼Œæ·»åŠ æ–°åˆ—æˆ–åˆ é™¤ç°æœ‰çš„åˆ—ï¼ŒåŸºæœ¬ä¸Šæ˜¯åœ¨å¡‘é€ æ•°æ®åº“æ¶æ„ã€‚ç„¶åæ˜¯DMLï¼Œæˆ–æ•°æ®æ“ä½œè¯­è¨€ï¼Œæ—¨åœ¨å¤„ç†æ•°æ®åº“å†…çš„å®é™…æ•°æ®ã€‚è¿™åŒ…æ‹¬æ’å…¥æ–°æ•°æ®ï¼Œæ›´æ–°ç°æœ‰æ•°æ®ï¼Œåˆ é™¤è®°å½•ï¼Œä»¥åŠä½¿ç”¨SELECTè¯­å¥æ¥æŸ¥è¯¢æ•°æ®åº“ã€‚

We also explore DCL, the Data Control Language, which governs the permissions granted to various users. It determines who has access to which data and defines user roles. Additionally, we delve into database administration, including creating backups and performing recovery, as well as managing transactions. These topics equip you with a comprehensive understanding of SQL, enabling you to become a proficient and informed database user.

æˆ‘ä»¬è¿˜ä¼šæ¢è®¨DCLï¼Œæ•°æ®æ§åˆ¶è¯­è¨€ï¼Œå®ƒç®¡ç†æˆäºˆå„ç§ç”¨æˆ·çš„æƒé™ã€‚å®ƒå†³å®šäº†è°å¯ä»¥è®¿é—®å“ªäº›æ•°æ®å¹¶å®šä¹‰ç”¨æˆ·è§’è‰²ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜å°†æ·±å…¥ç ”ç©¶æ•°æ®åº“ç®¡ç†ï¼ŒåŒ…æ‹¬åˆ›å»ºå¤‡ä»½å’Œæ‰§è¡Œæ¢å¤ï¼Œä»¥åŠç®¡ç†äº¤æ˜“ã€‚è¿™äº›ä¸»é¢˜ä¸ºæ‚¨æä¾›äº†å¯¹SQLçš„å…¨é¢äº†è§£ï¼Œä½¿æ‚¨èƒ½å¤Ÿæˆä¸ºä¸€ä¸ªç†Ÿç»ƒä¸”è§å¤šè¯†å¹¿çš„æ•°æ®åº“ç”¨æˆ·ã€‚

The importance of database administration, particularly backup and recovery, cannot be overstated. Students often question the necessity of learning these aspects when they are not currently dealing with critical data. However, it's imperative to understand that soon many will enter the workforce where data is invaluable, and the loss of significant data can result in severe consequences, including job loss.

æ•°æ®åº“ç®¡ç†çš„é‡è¦æ€§ï¼Œç‰¹åˆ«æ˜¯å¤‡ä»½å’Œæ¢å¤ï¼Œä¸å¯ä½ä¼°ã€‚å­¦ç”Ÿä»¬å¸¸å¸¸è´¨ç–‘åœ¨ä»–ä»¬ç›®å‰æ²¡æœ‰å¤„ç†å…³é”®æ•°æ®çš„æƒ…å†µä¸‹å­¦ä¹ è¿™äº›æ–¹é¢çš„å¿…è¦æ€§ã€‚ç„¶è€Œï¼Œå¿…é¡»æ˜ç™½ï¼Œå¾ˆå¿«è®¸å¤šäººå°†è¿›å…¥æ•°æ®éå¸¸å®è´µçš„åŠ³åŠ¨åŠ›å¸‚åœºï¼Œä¸”ä¸¢å¤±é‡è¦æ•°æ®å¯èƒ½ä¼šå¯¼è‡´ä¸¥é‡åæœï¼ŒåŒ…æ‹¬å¤±ä¸šã€‚

I emphasize practicing these critical skills in a safe, stress-free educational setting. This preparation is crucial, especially considering the high stakes involved in data handling within industries like banking. In such environments, a mistake during a backup or recovery process could not only be stressful but potentially ğŸš—eer-ending. Let's master these skills together to ensure you're well-prepared for the future.

æˆ‘å¼ºè°ƒåœ¨ä¸€ä¸ªå®‰å…¨ã€æ— å‹åŠ›çš„æ•™è‚²ç¯å¢ƒä¸­ç»ƒä¹ è¿™äº›å…³é”®æŠ€èƒ½ã€‚ç‰¹åˆ«æ˜¯è€ƒè™‘åˆ°åœ¨é“¶è¡Œç­‰è¡Œä¸šå†…å¤„ç†æ•°æ®æ‰€æ¶‰åŠçš„é«˜é£é™©ï¼Œè¿™ç§å‡†å¤‡æ˜¯è‡³å…³é‡è¦çš„ã€‚åœ¨è¿™æ ·çš„ç¯å¢ƒä¸­ï¼Œå¤‡ä»½æˆ–æ¢å¤è¿‡ç¨‹ä¸­çš„ä¸€ä¸ªé”™è¯¯ä¸ä»…ä¼šè®©äººå‹åŠ›å±±å¤§ï¼Œè¿˜å¯èƒ½å¯¼è‡´èŒä¸šç”Ÿæ¶¯çš„ç»ˆç»“ã€‚è®©æˆ‘ä»¬ä¸€èµ·æŒæ¡è¿™äº›æŠ€èƒ½ï¼Œç¡®ä¿ä½ ä¸ºå°†æ¥åšå¥½äº†å……åˆ†å‡†å¤‡ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240322191020920.png" alt="image-20240322191020920" style="zoom:50%;" /> 

Utilizing SQL begins with the implementation phase of the database. Recall that we've already covered how to construct our model. Following this, with the simple click of an export button, we generate a set of 'CREATE TABLE' statements. This is where the SQL language demonstrates its power, enabling the creation of a database. The next phase is the actual usage of the database, which involves the critical tasks of adding data, processing it, updating, deleting, and querying the database to retrieve valuable information. Remember, the essence of databases, as we discussed at the start of this course, is to unearth the 'hidden gold'â€”the insights that our database holds.

ä½¿ç”¨SQLé¦–å…ˆå¼€å§‹äºæ•°æ®åº“çš„å®ç°é˜¶æ®µã€‚å›æƒ³ä¸€ä¸‹ï¼Œæˆ‘ä»¬å·²ç»è®²è¿‡å¦‚ä½•æ„å»ºæˆ‘ä»¬çš„æ¨¡å‹ã€‚åœ¨æ­¤ä¹‹åï¼Œé€šè¿‡ç®€å•ç‚¹å‡»å¯¼å‡ºæŒ‰é’®ï¼Œæˆ‘ä»¬ç”Ÿæˆäº†ä¸€ç³»åˆ—çš„'CREATE TABLE'è¯­å¥ã€‚è¿™å°±æ˜¯SQLè¯­è¨€å±•ç¤ºå…¶èƒ½åŠ›çš„åœ°æ–¹ï¼Œå®ƒä½¿åˆ›å»ºæ•°æ®åº“æˆä¸ºå¯èƒ½ã€‚ä¸‹ä¸€ä¸ªé˜¶æ®µæ˜¯æ•°æ®åº“çš„å®é™…ä½¿ç”¨ï¼Œè¿™æ¶‰åŠæ·»åŠ æ•°æ®ã€å¤„ç†æ•°æ®ã€æ›´æ–°ã€åˆ é™¤ä»¥åŠæŸ¥è¯¢æ•°æ®åº“ä»¥æ£€ç´¢æœ‰ä»·å€¼ä¿¡æ¯çš„å…³é”®ä»»åŠ¡ã€‚è®°ä½ï¼Œæ­£å¦‚æˆ‘ä»¬åœ¨è¯¾ç¨‹å¼€å§‹æ—¶è®¨è®ºçš„ï¼Œæ•°æ®åº“çš„æœ¬è´¨æ˜¯å‘æ˜'éšè—çš„é‡‘å­'â€”â€”æˆ‘ä»¬çš„æ•°æ®åº“æŒæœ‰çš„æ´å¯ŸåŠ›ã€‚

The goal is to navigate the database to discover the knowledge hidden within its dataâ€”knowledge that our database can uniquely provide us. This process involves employing various SQL commands such as 'SELECT' to read and link the data from tables, and 'ALTER' and 'DROP' commands to modify the database structure. Likewise, 'INSERT', 'UPDATE', and 'DELETE' commands are used to change the data within the database. Each of these steps brings us closer to extracting the full value from the data at our disposal.

ç›®æ ‡æ˜¯å¯¼èˆªæ•°æ®åº“ï¼Œä»¥å‘ç°éšè—åœ¨å…¶æ•°æ®ä¸­çš„çŸ¥è¯†â€”â€”è¿™äº›çŸ¥è¯†æ˜¯æˆ‘ä»¬çš„æ•°æ®åº“å¯ä»¥ç‹¬ç‰¹åœ°ä¸ºæˆ‘ä»¬æä¾›çš„ã€‚è¿™ä¸ªè¿‡ç¨‹æ¶‰åŠä½¿ç”¨å„ç§SQLå‘½ä»¤ï¼Œå¦‚ä½¿ç”¨'SELECT'è¯»å–å’Œé“¾æ¥è¡¨ä¸­çš„æ•°æ®ï¼Œä»¥åŠä½¿ç”¨'ALTER'å’Œ'DROP'å‘½ä»¤ä¿®æ”¹æ•°æ®åº“ç»“æ„ã€‚åŒæ ·ï¼Œ'INSERT'ã€'UPDATE'å’Œ'DELETE'å‘½ä»¤ç”¨äºæ›´æ”¹æ•°æ®åº“ä¸­çš„æ•°æ®ã€‚è¿™äº›æ­¥éª¤ä¸­çš„æ¯ä¸€ä¸ªéƒ½ä½¿æˆ‘ä»¬æ›´æ¥è¿‘äºä»æˆ‘ä»¬æ‰‹å¤´çš„æ•°æ®ä¸­æå–å…¨éƒ¨ä»·å€¼ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240322191113911.png" alt="image-20240322191113911" style="zoom:50%;" /> 

To break it down into simple steps, the diagram at the bottom of the screen exemplifies a physical model created using a modeling tool like Workbench, which is currently part of your practice. Once the model is constructed, it encapsulates all the entities, attributes, and data types. It designates mandatory and optional attributes, identifies the primary keys, and defines relationship labels. This stage is about reminding you of the necessary components when building a model. Upon completing this phase, you will export the model to generate 'CREATE TABLE' statements like the one illustrated here for the bank's headquarters. This marks the implementation stage of the database.

ç®€å•åœ°åˆ†æ­¥éª¤æ¥è¯´ï¼Œå±å¹•åº•éƒ¨çš„å›¾è¡¨ç¤ºä¾‹äº†ä½¿ç”¨å»ºæ¨¡å·¥å…·å¦‚Workbenchåˆ›å»ºçš„ä¸€ä¸ªç‰©ç†æ¨¡å‹ï¼Œè¿™ç›®å‰æ˜¯ä½ ä»¬çš„ç»ƒä¹ å†…å®¹ã€‚ä¸€æ—¦æ¨¡å‹æ„å»ºå®Œæˆï¼Œå®ƒå°±åŒ…å«äº†æ‰€æœ‰å®ä½“ã€å±æ€§å’Œæ•°æ®ç±»å‹ã€‚å®ƒæŒ‡å®šäº†å¿…éœ€å’Œå¯é€‰çš„å±æ€§ï¼Œè¯†åˆ«äº†ä¸»é”®ï¼Œå¹¶å®šä¹‰äº†å…³ç³»æ ‡ç­¾ã€‚è¿™ä¸ªé˜¶æ®µæ˜¯å…³äºæé†’ä½ ä»¬åœ¨å»ºç«‹æ¨¡å‹æ—¶éœ€è¦è€ƒè™‘çš„å¿…è¦ç»„æˆéƒ¨åˆ†ã€‚å®Œæˆè¿™ä¸ªé˜¶æ®µåï¼Œä½ å°†å¯¼å‡ºæ¨¡å‹ä»¥ç”Ÿæˆç±»ä¼¼è¿™é‡Œæ‰€ç¤ºçš„é“¶è¡Œæ€»éƒ¨çš„'CREATE TABLE'è¯­å¥ã€‚è¿™æ ‡å¿—ç€æ•°æ®åº“çš„å®ç°é˜¶æ®µã€‚

In the next phase, the use of the database, we engage in populating our database with data. During this lecture, we will explore how to populate a table with data using examples like the ones shown. And lastly, in the third step, we can interrogate the database by running queries to search for intriguing patterns. In database systems, this querying process is often the most crucial element, as it allows us to extract meaningful insights from our data.

åœ¨ä¸‹ä¸€ä¸ªé˜¶æ®µï¼Œæ•°æ®åº“çš„ä½¿ç”¨ï¼Œæˆ‘ä»¬å¼€å§‹å‘æ•°æ®åº“ä¸­å¡«å……æ•°æ®ã€‚åœ¨è¿™èŠ‚è¯¾ä¸­ï¼Œæˆ‘ä»¬å°†æ¢è®¨å¦‚ä½•ä½¿ç”¨æ˜¾ç¤ºçš„ä¾‹å­æ¥å‘è¡¨ä¸­å¡«å……æ•°æ®ã€‚æœ€åï¼Œåœ¨ç¬¬ä¸‰æ­¥ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è¿è¡ŒæŸ¥è¯¢æ¥å®¡æŸ¥æ•°æ®åº“ï¼Œä»¥å¯»æ‰¾æœ‰è¶£çš„æ¨¡å¼ã€‚åœ¨æ•°æ®åº“ç³»ç»Ÿä¸­ï¼ŒæŸ¥è¯¢è¿‡ç¨‹é€šå¸¸æ˜¯æœ€å…³é”®çš„å…ƒç´ ï¼Œå› ä¸ºå®ƒå…è®¸æˆ‘ä»¬ä»æ•°æ®ä¸­æå–æœ‰æ„ä¹‰çš„æ´å¯Ÿã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323205720588.png" alt="image-20240323205720588" style="zoom:50%;" /> 

Let's begin by reviewing the steps involved in implementing or creating tables, which essentially revisits concepts we have covered after finalizing the modeling stage. By now, you should be able to understand how the entity depicted at the top of the screen translates into the SQL 'CREATE' statement at the bottom. All elements here should already be familiar to you, but there are two new aspects I want to clarify. Firstly, you may not have encountered 'AUTO_INCREMENT' before. This is a SQL function that automatically increments the value of a field. In our case, 'CustomerID' serves as a primary key and a surrogate key, ensuring uniqueness for each record in the table.

æˆ‘ä»¬å¼€å§‹å›é¡¾å®ç°æˆ–åˆ›å»ºè¡¨çš„æ­¥éª¤ï¼Œè¿™å®è´¨ä¸Šæ˜¯åœ¨å®Œæˆå»ºæ¨¡é˜¶æ®µåå¤ä¹ æˆ‘ä»¬å·²ç»è®¨è®ºè¿‡çš„æ¦‚å¿µã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œä½ ä»¬åº”è¯¥èƒ½å¤Ÿç†è§£å±å¹•é¡¶éƒ¨æ˜¾ç¤ºçš„å®ä½“æ˜¯å¦‚ä½•è½¬åŒ–ä¸ºå±å¹•åº•éƒ¨çš„SQL 'CREATE'è¯­å¥çš„ã€‚è¿™é‡Œçš„æ‰€æœ‰å…ƒç´ ä½ ä»¬åº”è¯¥å·²ç»ç†Ÿæ‚‰äº†ï¼Œä½†æœ‰ä¸¤ä¸ªæ–°çš„æ–¹é¢æˆ‘æƒ³è¦æ¾„æ¸…ã€‚é¦–å…ˆï¼Œä½ ä»¬å¯èƒ½ä¹‹å‰æ²¡æœ‰é‡åˆ°è¿‡'AUTO_INCREMENT'ã€‚è¿™æ˜¯ä¸€ä¸ªSQLåŠŸèƒ½ï¼Œå¯ä»¥è‡ªåŠ¨é€’å¢å­—æ®µçš„å€¼ã€‚åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œ'CustomerID'ä½œä¸ºä¸»é”®å’Œä»£ç†é”®ï¼Œç¡®ä¿äº†è¡¨ä¸­æ¯æ¡è®°å½•çš„å”¯ä¸€æ€§ã€‚

Recall that every entity and relationship in our model must have a primary key, determined by business use cases. Sometimes keys are inherently meaningful, such as a student or staff ID. However, there may be instances where no attribute stands out as an obvious key. For example, in a table with attributes like first name, last name, and age, none are suitable as unique keys, not even in combination. This leads us to introduce a new attribute, a surrogate key, like 'CustomerID', which has no inherent meaning but ensures each record is uniquely identifiable. Since this key holds no meaningful value for us, we let the database manage it, which can be efficiently done using the 'AUTO_INCREMENT' function.

å›æƒ³ä¸€ä¸‹ï¼Œæˆ‘ä»¬æ¨¡å‹ä¸­çš„æ¯ä¸ªå®ä½“å’Œå…³ç³»éƒ½å¿…é¡»æœ‰ä¸€ä¸ªä¸»é”®ï¼Œè¿™æ˜¯é€šè¿‡ä¸šåŠ¡ç”¨ä¾‹æ¥ç¡®å®šçš„ã€‚æœ‰æ—¶å€™ï¼Œé”®æœ¬èº«å°±å…·æœ‰æ„ä¹‰ï¼Œæ¯”å¦‚å­¦ç”Ÿæˆ–å‘˜å·¥IDã€‚ä½†æ˜¯ï¼Œä¹Ÿå¯èƒ½ä¼šé‡åˆ°æ²¡æœ‰å±æ€§æ˜¾è€Œæ˜“è§åœ°é€‚åˆä½œä¸ºé”®çš„æƒ…å†µã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸€ä¸ªå…·æœ‰åå­—ã€å§“æ°å’Œå¹´é¾„å±æ€§çš„è¡¨ä¸­ï¼Œæ²¡æœ‰ä»»ä½•ä¸€ä¸ªé€‚åˆä½œä¸ºå”¯ä¸€é”®ï¼Œå³ä½¿å®ƒä»¬ç»„åˆåœ¨ä¸€èµ·ä¹Ÿä¸è¡Œã€‚è¿™å°±å¯¼è‡´æˆ‘ä»¬å¼•å…¥ä¸€ä¸ªæ–°çš„å±æ€§ï¼Œä¸€ä¸ªä»£ç†é”®ï¼Œåƒ'CustomerID'ï¼Œå®ƒæ²¡æœ‰å†…åœ¨çš„æ„ä¹‰ï¼Œä½†ç¡®ä¿æ¯æ¡è®°å½•éƒ½æ˜¯å”¯ä¸€å¯è¯†åˆ«çš„ã€‚ç”±äºè¿™ä¸ªé”®å¯¹æˆ‘ä»¬æ²¡æœ‰æœ‰æ„ä¹‰çš„å€¼ï¼Œæˆ‘ä»¬è®©æ•°æ®åº“æ¥ç®¡ç†å®ƒï¼Œè¿™å¯ä»¥é€šè¿‡ä½¿ç”¨'AUTO_INCREMENT'åŠŸèƒ½æœ‰æ•ˆå®Œæˆã€‚

The second new element is the 'ENUM' type, as seen with 'CustType', allowing only certain predefined values. In the 'CREATE' statement, we define an enumeration attribute that permits storage of specific values exclusively. In this case, for 'CustomerType', only 'Personal' or 'Company' are acceptable inputs. This ensures data integrity by restricting the entries to those predefined categories.

ç¬¬äºŒä¸ªæ–°å…ƒç´ æ˜¯'ENUM'ç±»å‹ï¼Œå¦‚'CustType'æ‰€ç¤ºï¼Œåªå…è®¸æŸäº›é¢„å®šä¹‰çš„å€¼ã€‚åœ¨'CREATE'è¯­å¥ä¸­ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªæšä¸¾å±æ€§ï¼Œå®ƒåªå…è®¸å­˜å‚¨ç‰¹å®šçš„å€¼ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯¹äº'CustomerType'ï¼Œåªæœ‰'Personal'æˆ–'Company'æ˜¯å¯æ¥å—çš„è¾“å…¥ã€‚è¿™é€šè¿‡å°†è¾“å…¥é™åˆ¶åœ¨é‚£äº›é¢„å®šä¹‰çš„ç±»åˆ«ä¸­æ¥ç¡®ä¿æ•°æ®çš„å®Œæ•´æ€§ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323221349292.png" alt="image-20240323221349292" style="zoom:50%;" /> 

In our review, we revisit the concept of foreign keys, a fundamental aspect of relational databases that ensures tables are interlinked appropriately. A foreign key acts as a reference or pointer to a primary key in another table, establishing a relationship between tables. For example, in our accounts table, the foreign key points to the customer ID, indicating which customer each account belongs to. This mechanism is what enforces relational integrity within the database, making sure that relationships between tables are maintained correctly and the database doesn't permit inconsistencies.

åœ¨æˆ‘ä»¬çš„å¤ä¹ ä¸­ï¼Œæˆ‘ä»¬å›é¡¾äº†å¤–é”®çš„æ¦‚å¿µï¼Œè¿™æ˜¯å…³ç³»æ•°æ®åº“çš„ä¸€ä¸ªåŸºæœ¬æ–¹é¢ï¼Œç¡®ä¿è¡¨ä¹‹é—´è¢«é€‚å½“åœ°å…³è”ã€‚å¤–é”®å……å½“å¯¹å¦ä¸€ä¸ªè¡¨ä¸­ä¸»é”®çš„å¼•ç”¨æˆ–æŒ‡é’ˆï¼Œå»ºç«‹è¡¨ä¹‹é—´çš„å…³ç³»ã€‚ä¾‹å¦‚ï¼Œåœ¨æˆ‘ä»¬çš„è´¦æˆ·è¡¨ä¸­ï¼Œå¤–é”®æŒ‡å‘å®¢æˆ·IDï¼Œè¡¨æ˜æ¯ä¸ªè´¦æˆ·å±äºå“ªä¸ªå®¢æˆ·ã€‚è¿™ä¸ªæœºåˆ¶æ˜¯åœ¨æ•°æ®åº“ä¸­å¼ºåˆ¶å®æ–½å…³ç³»å®Œæ•´æ€§çš„ï¼Œç¡®ä¿è¡¨ä¹‹é—´çš„å…³ç³»æ­£ç¡®ç»´æŠ¤ï¼Œæ•°æ®åº“ä¸å…è®¸å­˜åœ¨ä¸ä¸€è‡´æ€§ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323221458169.png" alt="image-20240323221458169" style="zoom:50%;" /> 

The SQL 'CREATE' statement includes a specification for foreign keys, which is critical in linking tables within a database. In the 'Account' table creation example shown here, the 'FOREIGN KEY' clause refers to 'Customer(CustomerID)', establishing a relationship with the 'Customer' table by indicating that the 'CustomerID' in the 'Account' table points to the 'CustomerID' in the 'Customer' table. Although this may not be new information, it's important for completeness and understanding as you revisit SQL. Being familiar with these elements is crucial as they form the foundation of relational database design.

SQLçš„'CREATE'è¯­å¥ä¸­åŒ…å«äº†å¤–é”®çš„æŒ‡å®šï¼Œè¿™åœ¨æ•°æ®åº“ä¸­é“¾æ¥è¡¨æ ¼æ—¶è‡³å…³é‡è¦ã€‚å¦‚è¿™é‡Œæ‰€ç¤ºçš„'Account'è¡¨åˆ›å»ºç¤ºä¾‹ä¸­ï¼Œ'FOREIGN KEY'å­å¥å¼•ç”¨äº†'Customer(CustomerID)'ï¼Œé€šè¿‡æŒ‡å‡º'Account'è¡¨ä¸­çš„'CustomerID'æŒ‡å‘'Customer'è¡¨ä¸­çš„'CustomerID'ï¼Œå»ºç«‹äº†ä¸'Customer'è¡¨çš„å…³ç³»ã€‚è™½ç„¶è¿™å¯èƒ½ä¸æ˜¯æ–°ä¿¡æ¯ï¼Œä½†ä¸ºäº†å®Œæ•´æ€§å’Œç†è§£ï¼Œå½“ä½ é‡æ–°å®¡è§†SQLæ—¶ï¼Œè¿™æ˜¯å¾ˆé‡è¦çš„ã€‚ç†Ÿæ‚‰è¿™äº›å…ƒç´ è‡³å…³é‡è¦ï¼Œå› ä¸ºå®ƒä»¬æ„æˆäº†å…³ç³»æ•°æ®åº“è®¾è®¡çš„åŸºç¡€ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323223321583.png" alt="image-20240323223321583" style="zoom:50%;" /> 

After our tables are set up, we begin the process of inserting data, as demonstrated here with two different INSERT statements. The first command, labeled (1), shows data being inserted specifically into the 'Customer' table. It's important to note that keywords like 'INSERT INTO' are highlighted in capital letters for clarity, though SQL is not case-sensitive. 'Customer' is identified as the table name, and within parentheses, we specify the exact attributes we want to populate: 'CustFirstName', 'CustLastName', and 'CustType'. Following the 'VALUES' keyword, we list the corresponding values for these attributes, with 'Peter' as the first name, 'Smith' as the last name, and 'Personal' as the customer type.

åœ¨æˆ‘ä»¬çš„è¡¨æ ¼è®¾ç½®å®Œæˆåï¼Œæˆ‘ä»¬å¼€å§‹æ’å…¥æ•°æ®çš„è¿‡ç¨‹ï¼Œå¦‚è¿™é‡Œç”¨ä¸¤ç§ä¸åŒçš„INSERTè¯­å¥æ‰€ç¤ºã€‚ç¬¬ä¸€ä¸ªå‘½ä»¤ï¼Œæ ‡è®°ä¸ºï¼ˆ1ï¼‰ï¼Œæ˜¾ç¤ºæ•°æ®è¢«å…·ä½“æ’å…¥åˆ°'Customer'è¡¨ä¸­ã€‚é‡è¦çš„æ˜¯è¦æ³¨æ„ï¼Œåƒ'INSERT INTO'è¿™æ ·çš„å…³é”®å­—ä¸ºäº†æ¸…æ™°èµ·è§éƒ½ç”¨å¤§å†™å­—æ¯çªå‡ºæ˜¾ç¤ºï¼Œå°½ç®¡SQLä¸åŒºåˆ†å¤§å°å†™ã€‚'Customer'è¢«è¯†åˆ«ä¸ºè¡¨åï¼Œåœ¨æ‹¬å·å†…ï¼Œæˆ‘ä»¬æŒ‡å®šäº†æˆ‘ä»¬æƒ³è¦å¡«å……çš„ç¡®åˆ‡å±æ€§ï¼š'CustFirstName'ï¼Œ'CustLastName'å’Œ'CustType'ã€‚åœ¨'VALUES'å…³é”®å­—åï¼Œæˆ‘ä»¬åˆ—å‡ºäº†è¿™äº›å±æ€§å¯¹åº”çš„å€¼ï¼Œ'Peter'ä½œä¸ºåå­—ï¼Œ'Smith'ä½œä¸ºå§“ï¼Œä»¥åŠ'Personal'ä½œä¸ºå®¢æˆ·ç±»å‹ã€‚

In the second example, marked as (2), we omit the specification of attributes, implying that we're providing values for all columns in the order they are defined in the table schema. Here, 'DEFAULT' is used to denote that the 'CustID' will be auto-incremented by the database. The rest of the values provided include 'James' for the first name, 'NULL' for an undefined middle name, 'Jones' for the last name, 'JJ Enterprises' for the business name, and 'Company' for the customer type.

åœ¨ç¬¬äºŒä¸ªä¾‹å­ä¸­ï¼Œæ ‡è®°ä¸ºï¼ˆ2ï¼‰ï¼Œæˆ‘ä»¬çœç•¥äº†å±æ€§çš„æŒ‡å®šï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬æŒ‰ç…§å®ƒä»¬åœ¨è¡¨æ¨¡å¼ä¸­å®šä¹‰çš„é¡ºåºä¸ºæ‰€æœ‰åˆ—æä¾›äº†å€¼ã€‚è¿™é‡Œï¼Œ'DEFAULT'ç”¨æ¥è¡¨ç¤º'CustID'å°†ç”±æ•°æ®åº“è‡ªåŠ¨é€’å¢ã€‚æä¾›çš„å…¶ä½™å€¼åŒ…æ‹¬'James'ä½œä¸ºåå­—ï¼Œ'NULL'è¡¨ç¤ºæœªå®šä¹‰çš„ä¸­é—´åï¼Œ'Jones'ä½œä¸ºå§“ï¼Œ'JJ Enterprises'ä½œä¸ºå•†ä¸šåç§°ï¼Œä»¥åŠ'Company'ä½œä¸ºå®¢æˆ·ç±»å‹ã€‚

The concept of 'NULL' in a database context is critical; it represents an unknown or undefined value, distinct from an empty string, which is denoted by two quotation marks with no content in between. Unlike an empty string, 'NULL' does not equate to zero for numerical fields. It is essential to understand this difference to correctly manage data entry and database integrity.

åœ¨æ•°æ®åº“ä¸Šä¸‹æ–‡ä¸­ï¼Œ'NULL'çš„æ¦‚å¿µè‡³å…³é‡è¦ï¼›å®ƒä»£è¡¨ä¸€ä¸ªæœªçŸ¥æˆ–æœªå®šä¹‰çš„å€¼ï¼Œä¸ç©ºå­—ç¬¦ä¸²ä¸åŒï¼Œç©ºå­—ç¬¦ä¸²ç”±ä¸¤ä¸ªæ²¡æœ‰å†…å®¹çš„å¼•å·è¡¨ç¤ºã€‚ä¸ç©ºå­—ç¬¦ä¸²ä¸åŒï¼Œ'NULL'åœ¨æ•°å€¼å­—æ®µä¸­ä¸ç­‰åŒäºé›¶ã€‚ç†è§£è¿™ç§åŒºåˆ«å¯¹äºæ­£ç¡®ç®¡ç†æ•°æ®è¾“å…¥å’Œæ•°æ®åº“å®Œæ•´æ€§è‡³å…³é‡è¦ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323224702810.png" alt="image-20240323224702810" style="zoom:50%;" /> 



Understanding the meaning of 'NULL' is critical in database operations, especially for developers working on applications that interact with databases. The concept of 'NULL' can cause considerable confusion if not properly understood. 'NULL' represents an unknown or undefined value in the database; it is not equivalent to zero or an empty string. This is demonstrated by a case where a voting system in the US mishandled 'NULL' values. For several houses in Madison, Wisconsin, the coordinates were unknown, hence they were represented as 'NULL' in the database. However, the application developers misinterpreted 'NULL' as zero, which led to many people being erroneously assigned a coordinate of (0,0), placing them in the middle of the ocean. This incident underscores the importance of correctly understanding database concepts to avoid such errors in real-life applications.

äº†è§£'NULL'åœ¨æ•°æ®åº“æ“ä½œä¸­çš„æ„ä¹‰è‡³å…³é‡è¦ï¼Œç‰¹åˆ«æ˜¯å¯¹äºé‚£äº›ä¸æ•°æ®åº“äº¤äº’çš„åº”ç”¨ç¨‹åºçš„å¼€å‘è€…æ¥è¯´ã€‚å¦‚æœç†è§£ä¸å½“ï¼Œ'NULL'çš„æ¦‚å¿µå¯èƒ½ä¼šå¼•èµ·ç›¸å½“å¤§çš„æ··æ·†ã€‚'NULL'åœ¨æ•°æ®åº“ä¸­ä»£è¡¨ä¸€ä¸ªæœªçŸ¥æˆ–æœªå®šä¹‰çš„å€¼ï¼›å®ƒä¸ç­‰åŒäºé›¶æˆ–ç©ºå­—ç¬¦ä¸²ã€‚è¿™ä¸€ç‚¹é€šè¿‡ä¸€ä¸ªç¾å›½æŠ•ç¥¨ç³»ç»Ÿé”™è¯¯å¤„ç†'NULL'å€¼çš„æ¡ˆä¾‹å¾—åˆ°äº†è¯æ˜ã€‚åœ¨å¨æ–¯åº·æ˜Ÿå·éº¦è¿ªé€Šçš„å‡ æ‰€æˆ¿å­ï¼Œå…¶åæ ‡æ˜¯æœªçŸ¥çš„ï¼Œå› æ­¤åœ¨æ•°æ®åº“ä¸­è¢«è¡¨ç¤ºä¸º'NULL'ã€‚ç„¶è€Œï¼Œåº”ç”¨ç¨‹åºå¼€å‘è€…é”™è¯¯åœ°å°†'NULL'è§£é‡Šä¸ºé›¶ï¼Œå¯¼è‡´è®¸å¤šäººé”™è¯¯åœ°è¢«åˆ†é…äº†(0,0)çš„åæ ‡ï¼Œå°†ä»–ä»¬æ”¾åœ¨äº†æµ·æ´‹ä¸­é—´ã€‚è¿™ä¸ªäº‹ä»¶å¼ºè°ƒäº†æ­£ç¡®ç†è§£æ•°æ®åº“æ¦‚å¿µä»¥é¿å…åœ¨å®é™…åº”ç”¨ä¸­å‡ºç°æ­¤ç±»é”™è¯¯çš„é‡è¦æ€§ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240324011422502.png" alt="image-20240324011422502" style="zoom:50%;" />  

After we've entered our data into the database, we can start analyzing it using SQL statements, which let us query the database. The example shown below is the simplest form of an SQL query, where we seek to retrieve all columns from a table. The asterisk symbol (*) here is used to indicate that we want all columns from the 'Customer' table. The result displayed represents three records that have been previously inserted into the database.

åœ¨æˆ‘ä»¬å°†æ•°æ®è¾“å…¥æ•°æ®åº“ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹ä½¿ç”¨ SQL è¯­å¥æ¥åˆ†æå®ƒï¼ŒSQL è¯­å¥å…è®¸æˆ‘ä»¬æŸ¥è¯¢æ•°æ®åº“ã€‚ä¸‹é¢æ˜¾ç¤ºçš„ä¾‹å­æ˜¯æœ€ç®€å•çš„ SQL æŸ¥è¯¢å½¢å¼ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬è¯•å›¾æ£€ç´¢ä¸€ä¸ªè¡¨çš„æ‰€æœ‰åˆ—ã€‚è¿™é‡Œçš„æ˜Ÿå· (*) è¡¨ç¤ºæˆ‘ä»¬è¦ä» 'Customer' è¡¨ä¸­è·å–æ‰€æœ‰åˆ—ã€‚æ˜¾ç¤ºçš„ç»“æœä»£è¡¨äº†æ­¤å‰å·²ç»æ’å…¥åˆ°æ•°æ®åº“ä¸­çš„ä¸‰æ¡è®°å½•ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323225028621.png" alt="image-20240323225028621" style="zoom:50%;" /> 

Here we delve into the detailed structure of the SELECT statement in SQL. We start with the SELECT clause, where we list the attributes or expressions we intend to retrieve from the database. Next, the FROM clause specifies the tables or views from which we will be pulling data. The WHERE clause follows, allowing us to filter the data based on certain conditions. For grouping the results, we use the GROUP BY clause, followed by the HAVING clause, which permits us to apply conditions to the groups formed by GROUP BY. Ordering the output is done using the ORDER BY clause, and finally, the LIMIT clause is used to restrict the number of rows returned.

è¿™é‡Œæˆ‘ä»¬è¯¦ç»†ä»‹ç»äº†SQLä¸­çš„SELECTè¯­å¥çš„ç»“æ„ã€‚æˆ‘ä»¬ä»SELECTå­å¥å¼€å§‹ï¼Œåˆ—å‡ºæˆ‘ä»¬æ‰“ç®—ä»æ•°æ®åº“ä¸­æ£€ç´¢çš„å±æ€§æˆ–è¡¨è¾¾å¼ã€‚æ¥ä¸‹æ¥ï¼ŒFROMå­å¥æŒ‡å®šäº†æˆ‘ä»¬å°†ä»ä¸­æå–æ•°æ®çš„è¡¨æˆ–è§†å›¾ã€‚æ¥ç€æ˜¯WHEREå­å¥ï¼Œå…è®¸æˆ‘ä»¬æ ¹æ®æŸäº›æ¡ä»¶è¿‡æ»¤æ•°æ®ã€‚ä¸ºäº†å¯¹ç»“æœè¿›è¡Œåˆ†ç»„ï¼Œæˆ‘ä»¬ä½¿ç”¨GROUP BYå­å¥ï¼Œç„¶åæ˜¯HAVINGå­å¥ï¼Œå®ƒå…è®¸æˆ‘ä»¬å¯¹GROUP BYå½¢æˆçš„ç»„åº”ç”¨æ¡ä»¶ã€‚ä½¿ç”¨ORDER BYå­å¥å¯¹è¾“å‡ºè¿›è¡Œæ’åºï¼Œæœ€åï¼Œä½¿ç”¨LIMITå­å¥é™åˆ¶è¿”å›çš„è¡Œæ•°ã€‚

It's crucial to understand that the order of these clauses is significant. You cannot change their sequence; for instance, you cannot write FROM after WHERE, or WHERE after GROUP BY. While it is not necessary to include every clause in every SELECT statement, for those that you do include, maintaining the proper sequence is a must. Not every SELECT statement requires a WHERE, GROUP BY, or HAVING clause. However, for the clauses present in your query, the order must be respected.

ç†è§£è¿™äº›å­å¥çš„é¡ºåºæ˜¯é‡è¦çš„ã€‚ä½ ä¸èƒ½æ”¹å˜å®ƒä»¬çš„åºåˆ—ï¼›ä¾‹å¦‚ï¼Œä½ ä¸èƒ½åœ¨WHEREä¹‹åå†™FROMï¼Œæˆ–åœ¨GROUP BYä¹‹åå†™WHEREã€‚è™½ç„¶å¹¶ä¸éœ€è¦åœ¨æ¯ä¸ªSELECTè¯­å¥ä¸­éƒ½åŒ…å«æ¯ä¸ªå­å¥ï¼Œä½†å¯¹äºä½ ç¡®å®åŒ…å«çš„é‚£äº›å­å¥ï¼Œå¿…é¡»ä¿æŒæ­£ç¡®çš„é¡ºåºã€‚å¹¶éæ¯ä¸ªSELECTè¯­å¥éƒ½éœ€è¦WHEREã€GROUP BYæˆ–HAVINGå­å¥ã€‚ç„¶è€Œï¼Œå¯¹äºæŸ¥è¯¢ä¸­å‡ºç°çš„å­å¥ï¼Œå¿…é¡»å°Šé‡é¡ºåºã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323225405201.png" alt="image-20240323225405201" style="zoom:50%;" /> 

The most basic form of a query is exemplified by 'SELECT * FROM customer'. In this context, the asterisk (*) is a wildğŸš—d character that instructs the database to return all columns of data from the 'customer' table. To allow for a more interactive experience with the data, I've added additional records to the table, which although might not be immensely practical, serves our purpose for exploration and learning.

æœ€åŸºç¡€çš„æŸ¥è¯¢å½¢å¼å¯ä»¥é€šè¿‡'SELECT * FROM customer'æ¥ç¤ºä¾‹ã€‚åœ¨è¿™ä¸ªä¸Šä¸‹æ–‡ä¸­ï¼Œæ˜Ÿå·ï¼ˆ*ï¼‰æ˜¯ä¸€ä¸ªé€šé…ç¬¦ï¼Œå®ƒæŒ‡ç¤ºæ•°æ®åº“ä»'customer'è¡¨è¿”å›æ‰€æœ‰åˆ—çš„æ•°æ®ã€‚ä¸ºäº†èƒ½å¤Ÿæ›´äº’åŠ¨åœ°ä½“éªŒæ•°æ®ï¼Œæˆ‘å·²ç»å‘è¡¨ä¸­æ·»åŠ äº†é¢å¤–çš„è®°å½•ï¼Œè™½ç„¶è¿™å¯èƒ½å¹¶ä¸æå…¶å®ç”¨ï¼Œä½†ä¸ºäº†æ¢ç´¢å’Œå­¦ä¹ ï¼Œå®ƒæœåŠ¡äºæˆ‘ä»¬çš„ç›®çš„ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323230506605.png" alt="image-20240323230506605" style="zoom:50%;" /> 

Tables often contain many attributes, but typically we're interested in a subset of these attributes. This concept is known as projection in relational algebra, where we focus only on the attributes that are of interest to us. To accomplish this in SQL, we specify the attributes we wish to retain, listed and separated by commas alongside the SELECT statement. What was represented by the Ï€ (pi) symbol followed by attribute names in relational algebra is now translated into SQL as SELECT followed by the list of attribute names. As a result, we obtain a new table, in this case containing just a single column with last names.

ç”±äºè¡¨ä¸­é€šå¸¸åŒ…å«è®¸å¤šå±æ€§ï¼Œä½†é€šå¸¸æˆ‘ä»¬åªå¯¹å…¶ä¸­çš„ä¸€éƒ¨åˆ†å±æ€§æ„Ÿå…´è¶£ã€‚è¿™ä¸ªæ¦‚å¿µåœ¨å…³ç³»ä»£æ•°ä¸­è¢«ç§°ä¸ºæŠ•å½±ï¼ˆprojectionï¼‰ï¼Œæˆ‘ä»¬åªå…³æ³¨æˆ‘ä»¬æ„Ÿå…´è¶£çš„å±æ€§ã€‚è¦åœ¨SQLä¸­å®ç°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬æŒ‡å®šæˆ‘ä»¬å¸Œæœ›ä¿ç•™çš„å±æ€§ï¼Œå°†å®ƒä»¬åˆ—å‡ºå¹¶ç”¨é€—å·åˆ†éš”ï¼Œç´§éšSELECTè¯­å¥ä¹‹åã€‚åœ¨å…³ç³»ä»£æ•°ä¸­ï¼ŒÏ€ï¼ˆpiï¼‰ç¬¦å·åè·Ÿå±æ€§åç§°ï¼Œåœ¨SQLä¸­è½¬æ¢ä¸ºSELECTåè·Ÿå±æ€§åç§°åˆ—è¡¨ã€‚ç»“æœï¼Œæˆ‘ä»¬å¾—åˆ°äº†ä¸€ä¸ªæ–°è¡¨ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¯¥è¡¨ä»…åŒ…å«ä¸€ä¸ªå¸¦æœ‰å§“æ°çš„å•åˆ—ã€‚

It's important to note that while the theory of relational algebra states that projection eliminates duplicates to provide correct answers, commercial SQL systems deviate slightly from this theoretical aspect. Removing duplicates can be computationally expensive, so most systems do not remove them by default. If we want to eliminate duplicates in our results, we must explicitly use the DISTINCT keyword before the attribute names in our SQL query. Moving forward from projection, the next concept we cover is selection, which is an operation on a single table, as we recall from relational algebra.

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè™½ç„¶å…³ç³»ä»£æ•°ç†è®ºæŒ‡å‡ºæŠ•å½±æ“ä½œä¼šæ¶ˆé™¤é‡å¤é¡¹ä»¥æä¾›æ­£ç¡®ç­”æ¡ˆï¼Œä½†å•†ä¸šSQLç³»ç»Ÿåœ¨è¿™ä¸€ç†è®ºæ–¹é¢ç•¥æœ‰åå·®ã€‚åˆ é™¤é‡å¤é¡¹åœ¨è®¡ç®—ä¸Šå¯èƒ½ä»£ä»·é«˜æ˜‚ï¼Œå› æ­¤å¤§å¤šæ•°ç³»ç»Ÿé»˜è®¤ä¸ä¼šç§»é™¤å®ƒä»¬ã€‚å¦‚æœæˆ‘ä»¬æƒ³åœ¨ç»“æœä¸­æ¶ˆé™¤é‡å¤é¡¹ï¼Œæˆ‘ä»¬å¿…é¡»åœ¨SQLæŸ¥è¯¢ä¸­çš„å±æ€§åç§°å‰æ˜ç¡®ä½¿ç”¨DISTINCTå…³é”®å­—ã€‚ä»æŠ•å½±æ¦‚å¿µç»§ç»­å‰è¿›ï¼Œæˆ‘ä»¬æ¥ä¸‹æ¥è¦è¦†ç›–çš„æ¦‚å¿µæ˜¯é€‰æ‹©ï¼ˆselectionï¼‰ï¼Œè¿™æ˜¯ä¸€ä¸ªå•è¡¨æ“ä½œï¼Œæ­£å¦‚æˆ‘ä»¬ä»å…³ç³»ä»£æ•°ä¸­å›å¿†çš„é‚£æ ·ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323230655117.png" alt="image-20240323230655117" style="zoom:50%;" /> 

Selection in databases is used to filter data, allowing us to keep only the records that meet certain conditions. In relational algebra, this is denoted by the Greek letter Sigma (Ïƒ) followed by the conditions for filtering. In SQL, this translates to using the WHERE clause accompanied by conditions that determine which records to retain. These conditions can be combined using the logical operators AND, OR, and NOT. The slide illustrates a combined use of selection and projection on a customer database. For projection, weâ€™re extracting only the last names, and for selection, the WHERE clause filters the records to include only customers whose last name is 'Smith'. Consequently, the result displayed shows only the entries with the last name 'Smith'.

åœ¨æ•°æ®åº“ä¸­ï¼Œé€‰æ‹©ç”¨äºè¿‡æ»¤æ•°æ®ï¼Œè®©æˆ‘ä»¬åªä¿ç•™æ»¡è¶³ç‰¹å®šæ¡ä»¶çš„è®°å½•ã€‚åœ¨å…³ç³»ä»£æ•°ä¸­ï¼Œè¿™ç”±å¸Œè…Šå­—æ¯Sigma (Ïƒ)åŠå…¶åçš„è¿‡æ»¤æ¡ä»¶è¡¨ç¤ºã€‚åœ¨SQLä¸­ï¼Œè¿™è½¬åŒ–ä¸ºä½¿ç”¨WHEREå­å¥å’Œä¼´éšçš„æ¡ä»¶æ¥ç¡®å®šä¿ç•™å“ªäº›è®°å½•ã€‚è¿™äº›æ¡ä»¶å¯ä»¥ä½¿ç”¨é€»è¾‘æ“ä½œç¬¦ANDã€ORå’ŒNOTç»„åˆã€‚å¹»ç¯ç‰‡å±•ç¤ºäº†åœ¨å®¢æˆ·æ•°æ®åº“ä¸Šç»“åˆä½¿ç”¨é€‰æ‹©å’ŒæŠ•å½±çš„ä¾‹å­ã€‚å¯¹äºæŠ•å½±ï¼Œæˆ‘ä»¬åªæå–å§“æ°ï¼Œå¯¹äºé€‰æ‹©ï¼ŒWHEREå­å¥è¿‡æ»¤å‡ºåªåŒ…æ‹¬å§“'Smith'çš„å®¢æˆ·çš„è®°å½•ã€‚å› æ­¤ï¼Œæ˜¾ç¤ºçš„ç»“æœä»…æ˜¾ç¤ºå§“æ°ä¸º'Smith'çš„æ¡ç›®ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323230740461.png" alt="image-20240323230740461" style="zoom:50%;" /> 

When it comes to selection in SQL, we've learned that conditions can take the form of arithmetic expressions, which are well-suited for numerical values. However, when dealing with string values, comparison operations like greater than or less than become irrelevant. In such cases, we use the LIKE clause for pattern matching within strings. The LIKE clause is accompanied by a regular expression, which employs two special wildğŸš—d characters: the percent sign (%) to represent zero, one, or multiple characters, and the underscore (_) to represent exactly one character.

åœ¨SQLä¸­è¿›è¡Œé€‰æ‹©æ—¶ï¼Œæˆ‘ä»¬å·²ç»äº†è§£åˆ°æ¡ä»¶å¯ä»¥é‡‡ç”¨ç®—æœ¯è¡¨è¾¾å¼çš„å½¢å¼ï¼Œè¿™é€‚ç”¨äºæ•°å€¼ã€‚ä½†æ˜¯ï¼Œå½“å¤„ç†å­—ç¬¦ä¸²å€¼æ—¶ï¼Œåƒå¤§äºæˆ–å°äºè¿™æ ·çš„æ¯”è¾ƒæ“ä½œå°±å˜å¾—ä¸ç›¸å…³äº†ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä½¿ç”¨LIKEå­å¥è¿›è¡Œå­—ç¬¦ä¸²å†…çš„æ¨¡å¼åŒ¹é…ã€‚LIKEå­å¥ä¼´éšç€ä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼ï¼Œå®ƒä½¿ç”¨ä¸¤ä¸ªç‰¹æ®Šçš„é€šé…ç¬¦å­—ç¬¦ï¼šç™¾åˆ†å·ï¼ˆ%ï¼‰ä»£è¡¨é›¶ä¸ªã€ä¸€ä¸ªæˆ–å¤šä¸ªå­—ç¬¦ï¼Œä¸‹åˆ’çº¿ï¼ˆ_ï¼‰ä»£è¡¨ç¡®åˆ‡çš„ä¸€ä¸ªå­—ç¬¦ã€‚

The LIKE clause allows us to explore various string expressions. Here are a few examples: the expression 'a%' finds any values that begin with 'a', regardless of what follows. The second example '%a' looks for strings that end with 'a', and the third '%or%' searches for any occurrence of 'or' in any position within the string. The fourth example '*r%' finds values where 'r' is in the second position, and 'a*%_%' finds strings that start with 'a' and are at least three characters long. The final example 'a%o' searches for strings that start with 'a' and end with 'o'.

LIKEå­å¥å…è®¸æˆ‘ä»¬æ¢ç´¢å„ç§å­—ç¬¦ä¸²è¡¨è¾¾å¼ã€‚è¿™é‡Œæœ‰å‡ ä¸ªä¾‹å­ï¼šè¡¨è¾¾å¼'a%'æŸ¥æ‰¾ä»»ä½•ä»¥'a'å¼€å¤´çš„å€¼ï¼Œä¸ç®¡å…¶åæ˜¯ä»€ä¹ˆã€‚ç¬¬äºŒä¸ªä¾‹å­'%a'å¯»æ‰¾ä»¥'a'ç»“å°¾çš„å­—ç¬¦ä¸²ï¼Œç¬¬ä¸‰ä¸ª'%or%'æœç´¢å­—ç¬¦ä¸²ä¸­ä»»ä½•ä½ç½®çš„'or'å‡ºç°ã€‚ç¬¬å››ä¸ªä¾‹å­'*r%'æ‰¾åˆ°'r'åœ¨ç¬¬äºŒä½çš„å€¼ï¼Œè€Œ'a*%_%'æ‰¾åˆ°ä»¥'a'å¼€å¤´ä¸”è‡³å°‘ä¸‰ä¸ªå­—ç¬¦é•¿çš„å­—ç¬¦ä¸²ã€‚æœ€åä¸€ä¸ªä¾‹å­'a%o'æœç´¢ä»¥'a'å¼€å¤´ä¸”ä»¥'o'ç»“å°¾çš„å­—ç¬¦ä¸²ã€‚

To test your understanding, try writing a regular expression that matches a string of at least four characters in length with the last character being 'o'. If this exercise is challenging, revisiting these examples should help solidify your grasp of how the LIKE clause operates.

ä¸ºäº†æµ‹è¯•ä½ çš„ç†è§£ï¼Œå°è¯•ç¼–å†™ä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼ï¼ŒåŒ¹é…è‡³å°‘å››ä¸ªå­—ç¬¦é•¿ï¼Œæœ€åä¸€ä¸ªå­—ç¬¦æ˜¯'o'çš„å­—ç¬¦ä¸²ã€‚å¦‚æœè¿™ä¸ªç»ƒä¹ æœ‰éš¾åº¦ï¼Œå›é¡¾è¿™äº›ä¾‹å­åº”è¯¥æœ‰åŠ©äºå·©å›ºä½ å¯¹LIKEå­å¥æ“ä½œæ–¹å¼çš„ç†è§£ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323231011949.png" alt="image-20240323231011949" style="zoom:50%;" /> 

Column renaming is an additional operation we utilize when working with single tables. Comparable to role renaming in relational algebra, SQL achieves this with the AS clause where we assign a new name to an attribute or an expression result. The example shown here demonstrates renaming the result of a count function on customer IDs by customer type. Without renaming, the result column would have the default name of the function and parameter, which can be unclear or unwieldy. By using 'AS Count', we provide a clearer, more meaningful name to the result column, which in this case is simply labeled as 'Count'. It's important to clarify that while the results appear as tables, they are not actual tables stored in the database; they are virtual tablesâ€”temporary results displayed from executing the query.

åˆ—é‡å‘½åæ˜¯æˆ‘ä»¬åœ¨å¤„ç†å•ä¸ªè¡¨æ—¶ä½¿ç”¨çš„é™„åŠ æ“ä½œã€‚ä¸å…³ç³»ä»£æ•°ä¸­çš„è§’è‰²é‡å‘½åç±»ä¼¼ï¼ŒSQLé€šè¿‡ASå­å¥å®ç°ï¼Œæˆ‘ä»¬åœ¨é‚£é‡Œä¸ºå±æ€§æˆ–è¡¨è¾¾å¼ç»“æœåˆ†é…ä¸€ä¸ªæ–°åç§°ã€‚è¿™é‡Œå±•ç¤ºçš„ä¾‹å­æ¼”ç¤ºäº†æ ¹æ®å®¢æˆ·ç±»å‹å¯¹å®¢æˆ·IDè¿›è¡Œè®¡æ•°å‡½æ•°çš„ç»“æœé‡å‘½åã€‚å¦‚æœä¸è¿›è¡Œé‡å‘½åï¼Œç»“æœåˆ—å°†å…·æœ‰å‡½æ•°å’Œå‚æ•°çš„é»˜è®¤åç§°ï¼Œè¿™å¯èƒ½ä¸æ¸…æ™°æˆ–ä¸æ˜“ç®¡ç†ã€‚é€šè¿‡ä½¿ç”¨'AS Count'ï¼Œæˆ‘ä»¬ä¸ºç»“æœåˆ—æä¾›äº†ä¸€ä¸ªæ›´æ¸…æ™°ã€æ›´æœ‰æ„ä¹‰çš„åç§°ï¼Œåœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œç®€å•åœ°æ ‡è®°ä¸º'Count'ã€‚é‡è¦çš„æ˜¯è¦æ¾„æ¸…ï¼Œè™½ç„¶ç»“æœçœ‹èµ·æ¥åƒæ˜¯è¡¨æ ¼ï¼Œå®ƒä»¬ä¸æ˜¯æ•°æ®åº“ä¸­å­˜å‚¨çš„å®é™…è¡¨æ ¼ï¼›å®ƒä»¬æ˜¯è™šæ‹Ÿè¡¨â€”â€”æ‰§è¡ŒæŸ¥è¯¢åæ˜¾ç¤ºçš„ä¸´æ—¶ç»“æœã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323231056967.png" alt="image-20240323231056967" style="zoom:50%;" /> 

Aggregate functions are essential when we need to perform operations across multiple records within a single table, allowing us to condense large datasets into meaningful single outputs. These functions are widely used because databases often contain vast numbers of records, and simply outputting raw data would be overwhelming. Through aggregate functions such as AVG (average), MIN (minimum), MAX (maximum), COUNT (number of values), and SUM (sum of values), we can process and distill our data in a more digestible form. These are some of the most commonly utilized aggregate functions, and for those who are eager to delve deeper, a helpful link is provided in the lecture notes.

èšåˆå‡½æ•°åœ¨æˆ‘ä»¬éœ€è¦åœ¨å•ä¸ªè¡¨æ ¼ä¸­å¯¹å¤šä¸ªè®°å½•æ‰§è¡Œæ“ä½œæ—¶è‡³å…³é‡è¦ï¼Œå®ƒä»¬å…è®¸æˆ‘ä»¬å°†åºå¤§çš„æ•°æ®é›†å‹ç¼©æˆæœ‰æ„ä¹‰çš„å•ä¸ªè¾“å‡ºã€‚è¿™äº›å‡½æ•°è¢«å¹¿æ³›ä½¿ç”¨ï¼Œå› ä¸ºæ•°æ®åº“é€šå¸¸åŒ…å«å¤§é‡çš„è®°å½•ï¼Œä»…ä»…è¾“å‡ºåŸå§‹æ•°æ®å°†æ˜¯å‹å€’æ€§çš„ã€‚é€šè¿‡èšåˆå‡½æ•°å¦‚AVGï¼ˆå¹³å‡å€¼ï¼‰ã€MINï¼ˆæœ€å°å€¼ï¼‰ã€MAXï¼ˆæœ€å¤§å€¼ï¼‰ã€COUNTï¼ˆå€¼çš„æ•°é‡ï¼‰å’ŒSUMï¼ˆå€¼çš„æ€»å’Œï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥ä»¥æ›´æ˜“äºæ¶ˆåŒ–çš„å½¢å¼å¤„ç†å’Œæç‚¼æˆ‘ä»¬çš„æ•°æ®ã€‚è¿™äº›æ˜¯ä¸€äº›æœ€å¸¸ç”¨çš„èšåˆå‡½æ•°ï¼Œå¯¹äºé‚£äº›æ¸´æœ›æ·±å…¥ç ”ç©¶çš„äººæ¥è¯´ï¼Œè®²ä¹‰ä¸­æä¾›äº†ä¸€ä¸ªæœ‰ç”¨çš„é“¾æ¥ã€‚

When using aggregate functions, it's important to understand that they typically ignore NULL values. For example, when calculating an average across a set of records, any NULL value within the set will not be considered in the computation, effectively treating the average as if the NULL value were non-existent. The exception to this is the COUNT function, which counts the number of records without regard to whether their values are NULL or not, focusing solely on the presence of the records themselves.

åœ¨ä½¿ç”¨èšåˆå‡½æ•°æ—¶ï¼Œäº†è§£å®ƒä»¬é€šå¸¸å¿½ç•¥NULLå€¼æ˜¯é‡è¦çš„ã€‚ä¾‹å¦‚ï¼Œåœ¨è®¡ç®—ä¸€ç»„è®°å½•çš„å¹³å‡å€¼æ—¶ï¼Œé›†åˆä¸­çš„ä»»ä½•NULLå€¼éƒ½ä¸ä¼šè¢«è®¡ç®—åœ¨å†…ï¼Œæœ‰æ•ˆåœ°å°†å¹³å‡å€¼è§†ä¸ºå¦‚æœNULLå€¼ä¸å­˜åœ¨ä¸€æ ·ã€‚æ­¤è§„åˆ™çš„ä¾‹å¤–æ˜¯COUNTå‡½æ•°ï¼Œå®ƒè®¡ç®—è®°å½•çš„æ•°é‡ï¼Œè€Œä¸è€ƒè™‘å®ƒä»¬çš„å€¼æ˜¯å¦ä¸ºNULLï¼Œä»…å…³æ³¨è®°å½•æœ¬èº«çš„å­˜åœ¨ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323231242563.png" alt="image-20240323231242563" style="zoom:50%;" /> 

Letâ€™s explore how aggregate functions are practically applied. Two of the most commonly used functions are COUNT and AVG. COUNT returns the total number of records, while AVG calculates the average of the specified values. For instance, the first SQL statement we see simply determines the number of customers by counting customer IDs in the Customer table. This basic measure, often the starting point of data analysis, gives us an insight into the tableâ€™s ğŸš—dinality. The second example illustrates how to calculate the average balance across all accounts, a more efficient method than examining each account balance individually, especially when dealing with numerous accounts.

æˆ‘ä»¬æ¥æ¢è®¨ä¸€ä¸‹èšåˆå‡½æ•°åœ¨å®è·µä¸­æ˜¯å¦‚ä½•åº”ç”¨çš„ã€‚æœ€å¸¸ç”¨çš„ä¸¤ä¸ªå‡½æ•°æ˜¯COUNTå’ŒAVGã€‚COUNTè¿”å›è®°å½•çš„æ€»æ•°ï¼Œè€ŒAVGè®¡ç®—æŒ‡å®šå€¼çš„å¹³å‡å€¼ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬çœ‹åˆ°çš„ç¬¬ä¸€ä¸ªSQLè¯­å¥ä»…é€šè¿‡è®¡ç®—Customerè¡¨ä¸­çš„CustomerIDæ¥ç¡®å®šå®¢æˆ·çš„æ•°é‡ã€‚è¿™ä¸ªåŸºæœ¬çš„åº¦é‡ï¼Œé€šå¸¸æ˜¯æ•°æ®åˆ†æçš„èµ·ç‚¹ï¼Œè®©æˆ‘ä»¬äº†è§£åˆ°è¡¨çš„åŸºæ•°ã€‚ç¬¬äºŒä¸ªä¾‹å­å±•ç¤ºäº†å¦‚ä½•è®¡ç®—æ‰€æœ‰è´¦æˆ·çš„å¹³å‡ä½™é¢ï¼Œè¿™æ¯”å•ç‹¬æŸ¥çœ‹æ¯ä¸ªè´¦æˆ·çš„ä½™é¢æ›´æœ‰æ•ˆç‡ï¼Œå°¤å…¶æ˜¯å½“å¤„ç†å¤§é‡è´¦æˆ·æ—¶ã€‚

However, simply averaging account balances may not provide a meaningful picture in scenarios like a bankâ€™s customer analysis, where a few high-net-worth individuals can skew the average significantly. A more useful approach could be to assess the average balance per customer. One method is to apply the AVG function with a specific condition, such as calculating the average balance for customer ID 1. Yet, this becomes impractical when we have multiple customers. A better alternative is to use the GROUP BY clause, which groups records by a certain criterion and computes an average for each group. The last SQL statement shown exemplifies how to calculate the average balance per customer using GROUP BY. This approach is particularly valuable when seeking a more granular understanding of data. Typically, GROUP BY is paired with aggregate functions to avoid generalizing over the entire data set.

ç„¶è€Œï¼Œä»…ä»…è®¡ç®—è´¦æˆ·ä½™é¢çš„å¹³å‡å€¼åœ¨æŸäº›åœºæ™¯ä¸‹å¯èƒ½å¹¶ä¸æä¾›æœ‰æ„ä¹‰çš„ä¿¡æ¯ï¼Œæ¯”å¦‚åœ¨é“¶è¡Œçš„å®¢æˆ·åˆ†æä¸­ï¼Œå°‘æ•°é«˜å‡€å€¼ä¸ªäººå¯èƒ½ä¼šæ˜¾è‘—å½±å“å¹³å‡å€¼ã€‚ä¸€ä¸ªæ›´æœ‰ç”¨çš„æ–¹æ³•å¯èƒ½æ˜¯è¯„ä¼°æ¯ä¸ªå®¢æˆ·çš„å¹³å‡ä½™é¢ã€‚ä¸€ç§æ–¹æ³•æ˜¯å¯¹AVGå‡½æ•°åº”ç”¨ç‰¹å®šæ¡ä»¶ï¼Œå¦‚è®¡ç®—å®¢æˆ·ID 1çš„è´¦æˆ·å¹³å‡ä½™é¢ã€‚ç„¶è€Œï¼Œå½“æˆ‘ä»¬æœ‰å¤šä¸ªå®¢æˆ·æ—¶ï¼Œè¿™ç§æ–¹æ³•å°±å˜å¾—ä¸åˆ‡å®é™…äº†ã€‚ä¸€ä¸ªæ›´å¥½çš„é€‰æ‹©æ˜¯ä½¿ç”¨GROUP BYå­å¥ï¼Œå®ƒæ ¹æ®æŸä¸ªæ ‡å‡†å¯¹è®°å½•è¿›è¡Œåˆ†ç»„ï¼Œå¹¶ä¸ºæ¯ä¸ªç»„è®¡ç®—å¹³å‡å€¼ã€‚å±•ç¤ºçš„æœ€åä¸€ä¸ªSQLè¯­å¥ä¾‹å­è¯´æ˜äº†å¦‚ä½•ä½¿ç”¨GROUP BYè®¡ç®—æ¯ä¸ªå®¢æˆ·çš„å¹³å‡ä½™é¢ã€‚è¿™ç§æ–¹æ³•åœ¨å¯»æ±‚æ›´ç»†ç²’åº¦çš„æ•°æ®ç†è§£æ—¶ç‰¹åˆ«æœ‰ä»·å€¼ã€‚é€šå¸¸ï¼ŒGROUP BYä¸èšåˆå‡½æ•°é…å¯¹ä½¿ç”¨ï¼Œä»¥é¿å…å¯¹æ•´ä¸ªæ•°æ®é›†è¿›è¡Œæ¦‚æ‹¬ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323231930384.png" alt="image-20240323231930384" style="zoom:50%;" /> 

The GROUP BY clause is a powerful SQL feature that organizes records into groups based on one or more attributes, often used in conjunction with aggregate functions to compute a single result from each group. Here's an example demonstrating how to calculate the average balance per customer. The SQL query is: `SELECT AVG(OutstandingBalance) FROM Account GROUP BY CustomerID;`. This command consolidates the accounts by each customer and calculates an average balance for each group, effectively returning one record per customer, each representing the average balance of their accounts.

GROUP BYå­å¥æ˜¯SQLçš„ä¸€ä¸ªå¼ºå¤§åŠŸèƒ½ï¼Œå®ƒæ ¹æ®ä¸€ä¸ªæˆ–å¤šä¸ªå±æ€§å°†è®°å½•ç»„ç»‡æˆç»„ï¼Œå¹¶ä¸”ç»å¸¸ä¸èšåˆå‡½æ•°ä¸€èµ·ä½¿ç”¨ï¼Œä»¥ä»æ¯ä¸ªç»„ä¸­è®¡ç®—å‡ºä¸€ä¸ªç»“æœã€‚è¿™é‡Œæœ‰ä¸€ä¸ªç¤ºä¾‹ï¼Œæ¼”ç¤ºäº†å¦‚ä½•è®¡ç®—æ¯ä¸ªå®¢æˆ·çš„å¹³å‡ä½™é¢ã€‚SQLæŸ¥è¯¢ä¸ºï¼š`SELECT AVG(OutstandingBalance) FROM Account GROUP BY CustomerID;`ã€‚è¿™ä¸ªå‘½ä»¤æŒ‰æ¯ä¸ªå®¢æˆ·æ±‡æ€»è´¦æˆ·ï¼Œå¹¶è®¡ç®—æ¯ç»„çš„å¹³å‡ä½™é¢ï¼Œæœ‰æ•ˆåœ°ä¸ºæ¯ä¸ªå®¢æˆ·è¿”å›ä¸€ä¸ªè®°å½•ï¼Œæ¯ä¸ªè®°å½•ä»£è¡¨ä»–ä»¬è´¦æˆ·çš„å¹³å‡ä½™é¢ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323232147528.png" alt="image-20240323232147528" style="zoom: 25%;" /> 



Let's take a practical look at a table named 'accounts', which includes columns for 'custID' and 'balance'. For instance, imagine there are three accounts for customer ID 1 with balances of 100, 101, and 102. Additionally, let's say customer ID 2 has two accounts with balances of 50 and 60. We're assuming other necessary columns like 'accountID' are present to avoid primary key violations. Utilizing the GROUP BY clause, the records for the same customer are grouped, and an aggregate function, such as AVG, is applied to calculate the average balance. For customer ID 1, the average balance calculated by SQL would be 101. For customer ID 2, it would be 55. Hence, the final result would show two records indicating the average balance per customer: 101 for customer ID 1 and 55 for customer ID 2, rather than displaying individual account balances.

è®©æˆ‘ä»¬å…·ä½“çœ‹çœ‹ä¸€ä¸ªåä¸º'accounts'çš„è¡¨ï¼Œå®ƒåŒ…æ‹¬'custID'å’Œ'balance'ä¸¤åˆ—ã€‚ä¾‹å¦‚ï¼Œå‡è®¾å®¢æˆ·ID 1æœ‰ä¸‰ä¸ªè´¦æˆ·ï¼Œä½™é¢åˆ†åˆ«ä¸º100ã€101å’Œ102ã€‚æ­¤å¤–ï¼Œå‡è®¾å®¢æˆ·ID 2æœ‰ä¸¤ä¸ªè´¦æˆ·ï¼Œä½™é¢åˆ†åˆ«ä¸º50å’Œ60ã€‚æˆ‘ä»¬å‡è®¾å…¶ä»–å¿…è¦çš„åˆ—å¦‚'accountID'å­˜åœ¨ï¼Œä»¥é¿å…ä¸»é”®å†²çªã€‚ä½¿ç”¨GROUP BYå­å¥ï¼Œç›¸åŒå®¢æˆ·çš„è®°å½•è¢«åˆ†ç»„ï¼Œå¹¶åº”ç”¨èšåˆå‡½æ•°å¦‚AVGæ¥è®¡ç®—å¹³å‡ä½™é¢ã€‚å¯¹äºå®¢æˆ·ID 1ï¼ŒSQLè®¡ç®—çš„å¹³å‡ä½™é¢å°†æ˜¯101ã€‚å¯¹äºå®¢æˆ·ID 2ï¼Œå°†æ˜¯55ã€‚å› æ­¤ï¼Œæœ€ç»ˆç»“æœå°†æ˜¾ç¤ºæ¯ä¸ªå®¢æˆ·çš„å¹³å‡ä½™é¢çš„ä¸¤ä¸ªè®°å½•ï¼šå®¢æˆ·ID 1çš„å¹³å‡ä½™é¢ä¸º101ï¼Œå®¢æˆ·ID 2çš„ä¸º55ï¼Œè€Œä¸æ˜¯æ˜¾ç¤ºæ¯ä¸ªè´¦æˆ·çš„ä½™é¢ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323232249169.png" alt="image-20240323232249169" style="zoom:50%;" /> 

The HAVING clause in SQL is essential when working with GROUP BY, as it allows for conditions to be applied specifically to aggregated data, something the WHERE clause canâ€™t do. For example, if we want to list countries with more than five customers, we use the GROUP BY clause to group customers by country and then apply the HAVING clause to filter these groups. The condition would be specified as HAVING COUNT(CustomerID) > 5, ensuring only those countries with a customer count greater than five are included in the results. Always remember, use HAVING to impose conditions on aggregate data, not WHERE, and then you may order the output as needed.

åœ¨SQLä¸­ï¼ŒHAVINGå­å¥æ˜¯ä¸GROUP BYä¸€èµ·ä½¿ç”¨æ—¶è‡³å…³é‡è¦çš„ï¼Œå› ä¸ºå®ƒå…è®¸å¯¹èšåˆæ•°æ®åº”ç”¨ç‰¹å®šçš„æ¡ä»¶ï¼Œè¿™æ˜¯WHEREå­å¥æ— æ³•åšåˆ°çš„ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬æƒ³åˆ—å‡ºæœ‰è¶…è¿‡äº”ä¸ªå®¢æˆ·çš„å›½å®¶ï¼Œæˆ‘ä»¬ä½¿ç”¨GROUP BYå­å¥æŒ‰å›½å®¶å¯¹å®¢æˆ·è¿›è¡Œåˆ†ç»„ï¼Œç„¶ååº”ç”¨HAVINGå­å¥æ¥è¿‡æ»¤è¿™äº›ç»„ã€‚æ¡ä»¶å°†è¢«æŒ‡å®šä¸ºHAVING COUNT(CustomerID) > 5ï¼Œç¡®ä¿åªåŒ…æ‹¬å®¢æˆ·æ•°è¶…è¿‡äº”çš„å›½å®¶åœ¨ç»“æœä¸­ã€‚è®°ä½ï¼Œä½¿ç”¨HAVINGæ¥å¯¹èšåˆæ•°æ®æ–½åŠ æ¡ä»¶ï¼Œè€Œä¸æ˜¯WHEREï¼Œç„¶åä½ å¯ä»¥æ ¹æ®éœ€è¦å¯¹è¾“å‡ºç»“æœè¿›è¡Œæ’åºã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323232332358.png" alt="image-20240323232332358" style="zoom:50%;" /> 

Relational tables, it should be noted, are sets. As such, the sequence in which we see them does not necessarily reflect any inherent order within the dataâ€”it can change depending on retrieval methods and storage, among other variables. These are topics we will explore in more detail later in the course. To impose a specific order, however, we utilize the ORDER BY clause, which allows for sorting in ascending (ASC) or descending (DESC) order, with ascending being the default when no specific direction is given.

å…³ç³»è¡¨æ˜¯é›†åˆï¼Œè¿™ä¸€ç‚¹éœ€è¦æ³¨æ„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬çœ‹åˆ°çš„é¡ºåºå¹¶ä¸åæ˜ æ•°æ®çš„å›ºæœ‰é¡ºåºâ€”â€”å®ƒå¯ä»¥æ ¹æ®æ£€ç´¢æ–¹æ³•å’Œå­˜å‚¨ç­‰å¤šç§å› ç´ è€Œæ”¹å˜ã€‚è¿™äº›ä¸»é¢˜æˆ‘ä»¬å°†åœ¨è¯¾ç¨‹åé¢è¯¦ç»†æ¢è®¨ã€‚ç„¶è€Œï¼Œä¸ºäº†å¼ºåˆ¶ç‰¹å®šé¡ºåºï¼Œæˆ‘ä»¬ä½¿ç”¨ ORDER BY å­å¥ï¼Œå®ƒå…è®¸æŒ‰å‡åºï¼ˆASCï¼‰æˆ–é™åºï¼ˆDESCï¼‰æ’åºï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œå¦‚æœæ²¡æœ‰ç»™å‡ºå…·ä½“æ–¹å‘ï¼Œå°†æŒ‰å‡åºæ’åºã€‚

Sorting is not confined to a single column; we can order data across multiple columns, sorting first by one criterion, then another. The example on the left shows customer records sorted by last name in ascending order by default, as no order direction is specified. On the right, the DESC directive results in a descending order sort. This demonstrates the power of the ORDER BY clause to tailor data retrieval to our precise requirements.

æ’åºå¹¶ä¸é™äºå•ä¸ªåˆ—ï¼›æˆ‘ä»¬å¯ä»¥è·¨å¤šä¸ªåˆ—å¯¹æ•°æ®è¿›è¡Œæ’åºï¼Œé¦–å…ˆæŒ‰ä¸€ä¸ªæ ‡å‡†ï¼Œç„¶åæŒ‰å¦ä¸€ä¸ªæ ‡å‡†ã€‚å·¦è¾¹çš„ç¤ºä¾‹æ˜¾ç¤ºäº†æŒ‰å§“æ°é»˜è®¤å‡åºæ’åºçš„å®¢æˆ·è®°å½•ï¼Œå› ä¸ºæ²¡æœ‰æŒ‡å®šæ’åºæ–¹å‘ã€‚åœ¨å³è¾¹ï¼ŒDESC æŒ‡ä»¤å¯¼è‡´æ•°æ®æŒ‰é™åºæ’åºã€‚è¿™å±•ç¤ºäº† ORDER BY å­å¥è°ƒæ•´æ•°æ®æ£€ç´¢ä»¥æ»¡è¶³æˆ‘ä»¬ç²¾ç¡®è¦æ±‚çš„èƒ½åŠ›ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323233550099.png" alt="image-20240323233550099" style="zoom:50%;" /> 

The LIMIT clause in SQL is a tool we employ when we need to constrain the number of records displayed as output on the screen. It's particularly practical for those instances when only the top results are relevant, which is quite common. By applying the LIMIT clause with a specified number, such as 'LIMIT 5' in our example, the query is executed and only the first five records are presented. This is where the query stops and the output is cut off, ensuring a focused and concise dataset.

LIMIT å­å¥åœ¨ SQL ä¸­ç”¨äºé™åˆ¶å±å¹•ä¸Šæ˜¾ç¤ºçš„è®°å½•æ•°ã€‚è¿™åœ¨åªéœ€è¦æœ€é¡¶ç«¯çš„ç»“æœæ—¶éå¸¸å®ç”¨ï¼Œè¿™æ˜¯éå¸¸å¸¸è§çš„æƒ…å†µã€‚é€šè¿‡ä½¿ç”¨æŒ‡å®šæ•°å­—çš„ LIMIT å­å¥ï¼Œä¾‹å¦‚æˆ‘ä»¬ä¾‹å­ä¸­çš„ 'LIMIT 5'ï¼ŒæŸ¥è¯¢æ‰§è¡Œåä»…æ˜¾ç¤ºå‰äº”æ¡è®°å½•ã€‚æŸ¥è¯¢åˆ°æ­¤ä¸ºæ­¢ï¼Œè¾“å‡ºè¢«æˆªæ–­ï¼Œç¡®ä¿äº†æ•°æ®é›†çš„é›†ä¸­å’Œç®€æ´ã€‚

In conjunction with LIMIT, the OFFSET clause is used when we want to bypass a certain number of records from the beginning. It works in tandem with LIMIT to then display a set amount of records following the ones that were skipped. For example, on the right side of the slide, 'OFFSET 3' is used to skip the first three records, and then 'LIMIT 5' ensures that the next five records, starting from the fourth, are shown. This pairing of commands offers flexibility in managing the data output, allowing us to fine-tune the results to our specific viewing requirements.

ä¸ LIMIT é…åˆä½¿ç”¨æ—¶ï¼ŒOFFSET å­å¥ç”¨äºè·³è¿‡å¼€å§‹çš„ä¸€å®šæ•°é‡çš„è®°å½•ã€‚å®ƒä¸ LIMIT ååŒå·¥ä½œï¼Œç„¶åæ˜¾ç¤ºè·³è¿‡ä¹‹åçš„ä¸€å®šé‡çš„è®°å½•ã€‚ä¾‹å¦‚ï¼Œå¹»ç¯ç‰‡å³ä¾§çš„ 'OFFSET 3' è¢«ç”¨æ¥è·³è¿‡å‰ä¸‰æ¡è®°å½•ï¼Œç„¶å 'LIMIT 5' ç¡®ä¿ä»ç¬¬å››æ¡å¼€å§‹çš„æ¥ä¸‹æ¥äº”æ¡è®°å½•è¢«æ˜¾ç¤ºå‡ºæ¥ã€‚è¿™ä¸¤ä¸ªå‘½ä»¤çš„ç»“åˆä¸ºç®¡ç†æ•°æ®è¾“å‡ºæä¾›äº†çµæ´»æ€§ï¼Œå…è®¸æˆ‘ä»¬æ ¹æ®ç‰¹å®šçš„æŸ¥çœ‹éœ€æ±‚å¾®è°ƒç»“æœã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323233839589.png" alt="image-20240323233839589" style="zoom:50%;" /> 

Up to this point, our database operations have focused solely on single tables. As I have mentioned earlier, working with a single table doesn't fully harness the power of database systems. For any form of record merging, combination, or lookup, we employ joins, which you will get ample opportunity to practice. So now, let's examine how to construct various types of joins using SQL. A cross product, for instance, is easily obtained by listing the tables we wish to combine, separated by commas. Therefore, the command `SELECT * FROM Customer, Account` creates a cross product of the Customer and Account tables. To recap, a cross product combines every record from one table with every record from another, resulting in a table where all possible combinations are represented. While we see here an exhaustive merging in this new table, I pointed out that cross products are not commonly used in practice. They typically don't serve our purposes since they combine data indiscriminately, without any logical basis for the merge.

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬çš„æ•°æ®åº“æ“ä½œä»…ä¸“æ³¨äºå•ä¸ªè¡¨ä¸Šã€‚æ­£å¦‚æˆ‘ä¹‹å‰æåˆ°çš„ï¼Œä»…ä½¿ç”¨å•ä¸ªè¡¨å¹¶æ²¡æœ‰å……åˆ†å‘æŒ¥æ•°æ®åº“ç³»ç»Ÿçš„å¨åŠ›ã€‚å¯¹äºä»»ä½•ç±»å‹çš„è®°å½•åˆå¹¶ã€ç»„åˆæˆ–æŸ¥æ‰¾ï¼Œæˆ‘ä»¬éƒ½ä¼šä½¿ç”¨è¿æ¥æ“ä½œï¼Œè€Œè¿™äº›æ“ä½œä½ å°†æœ‰å……è¶³çš„æœºä¼šæ¥ç»ƒä¹ ã€‚ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥çœ‹çœ‹å¦‚ä½•ä½¿ç”¨ SQL æ„é€ ä¸åŒç±»å‹çš„è¿æ¥ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œé€šè¿‡é€—å·åˆ†éš”çš„è¡¨åˆ—è¡¨å¯ä»¥å¾ˆå®¹æ˜“åœ°å¾—åˆ°äº¤å‰ç§¯ã€‚å› æ­¤ï¼Œå‘½ä»¤ `SELECT * FROM Customer, Account` ä¼šåˆ›å»º Customer å’Œ Account è¡¨ä¹‹é—´çš„äº¤å‰ç§¯ã€‚å†å¼ºè°ƒä¸€éï¼Œäº¤å‰ç§¯å°†ä¸€ä¸ªè¡¨ä¸­çš„æ¯æ¡è®°å½•ä¸å¦ä¸€ä¸ªè¡¨ä¸­çš„æ¯æ¡è®°å½•ç›¸ç»“åˆï¼Œç»“æœäº§ç”Ÿä¸€ä¸ªæ‰€æœ‰å¯èƒ½ç»„åˆéƒ½åŒ…å«çš„æ–°è¡¨ã€‚å°½ç®¡æˆ‘ä»¬åœ¨è¿™é‡Œçœ‹åˆ°ä¸€ä¸ªå½»åº•çš„åˆå¹¶åœ¨è¿™ä¸ªæ–°è¡¨ä¸­ï¼Œä½†æˆ‘æŒ‡å‡ºäº¤å‰ç§¯åœ¨å®è·µä¸­å¹¶ä¸å¸¸ç”¨ã€‚å› ä¸ºå®ƒä»¬æ— é€‰æ‹©åœ°åˆå¹¶æ•°æ®ï¼Œæ²¡æœ‰åˆå¹¶çš„é€»è¾‘ä¾æ®ï¼Œé€šå¸¸å¹¶ä¸æ»¡è¶³æˆ‘ä»¬çš„éœ€æ±‚ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323234228394.png" alt="image-20240323234228394" style="zoom:50%;" /> 

In exploring joins in SQL, we start with the inner join, or equi join, which links tables based on a specified condition. In MySQL, this is articulated using the INNER JOIN keyword, followed by the condition stated after the ON keyword. Such a join is particularly useful when we want to merge records that have matching values in both tables. For example, by joining on CustomerID, each customer from one table is associated only with their corresponding account details from another table, not with any other accounts. 

åœ¨ SQL ä¸­æ¢ç´¢è¿æ¥æ—¶ï¼Œæˆ‘ä»¬ä»å†…è¿æ¥ï¼ˆæˆ–ç­‰å€¼è¿æ¥ï¼‰å¼€å§‹ï¼Œè¿™ç§è¿æ¥åŸºäºç‰¹å®šæ¡ä»¶è¿æ¥è¡¨ã€‚åœ¨ MySQL ä¸­ï¼Œè¿™é€šè¿‡ INNER JOIN å…³é”®å­—è¡¨è¾¾ï¼Œå…¶åæ˜¯ ON å…³é”®å­—åé¢çš„æ¡ä»¶ã€‚å½“æˆ‘ä»¬æƒ³è¦åˆå¹¶åœ¨ä¸¤ä¸ªè¡¨ä¸­éƒ½æœ‰åŒ¹é…å€¼çš„è®°å½•æ—¶ï¼Œè¿™ç§è¿æ¥ç‰¹åˆ«æœ‰ç”¨ã€‚ä¾‹å¦‚ï¼Œé€šè¿‡åœ¨ CustomerID ä¸Šè¿›è¡Œè¿æ¥ï¼Œä¸€ä¸ªè¡¨ä¸­çš„æ¯ä¸ªå®¢æˆ·åªä¸å¦ä¸€ä¸ªè¡¨ä¸­ç›¸å¯¹åº”çš„è´¦æˆ·è¯¦æƒ…ç›¸å…³è”ï¼Œè€Œä¸æ˜¯ä¸ä»»ä½•å…¶ä»–è´¦æˆ·ç›¸å…³è”ã€‚

Moving on to the natural join, it's a variant that's widely utilized, perhaps even more so than the equi join in practice. A natural join links two tables based on attributes with identical names across both tables, and as such, it doesn't require an explicit condition to be statedâ€”the condition is inferred. Notably, a natural join also performs a projection, removing duplicated columns that an equi join would retain. As you can see, natural join automatically disğŸš—ds one of the duplicate CustomerID columns. However, it's important to note that natural joins are contingent on the exact matching of attribute names, whereas an equi join allows for greater flexibility in specifying join conditions.

æ¥ä¸‹æ¥æ˜¯è‡ªç„¶è¿æ¥ï¼Œå®ƒæ˜¯ä¸€ä¸ªè¢«å¹¿æ³›ä½¿ç”¨çš„å˜ä½“ï¼Œåœ¨å®è·µä¸­å¯èƒ½æ¯”ç­‰å€¼è¿æ¥ä½¿ç”¨å¾—æ›´å¤šã€‚è‡ªç„¶è¿æ¥åŸºäºä¸¤ä¸ªè¡¨ä¸­åç§°ç›¸åŒçš„å±æ€§è¿æ¥ä¸¤ä¸ªè¡¨ï¼Œå› æ­¤å®ƒä¸éœ€è¦æ˜ç¡®è¯´æ˜æ¡ä»¶â€”â€”æ¡ä»¶æ˜¯éšå«çš„ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè‡ªç„¶è¿æ¥è¿˜æ‰§è¡ŒæŠ•å½±ï¼Œç§»é™¤ç­‰å€¼è¿æ¥ä¼šä¿ç•™çš„é‡å¤åˆ—ã€‚æ­£å¦‚ä½ æ‰€è§ï¼Œè‡ªç„¶è¿æ¥è‡ªåŠ¨ä¸¢å¼ƒäº†å…¶ä¸­ä¸€ä¸ªé‡å¤çš„ CustomerID åˆ—ã€‚ç„¶è€Œï¼Œé‡è¦çš„æ˜¯è¦æ³¨æ„ï¼Œè‡ªç„¶è¿æ¥ä¾èµ–äºå±æ€§åç§°çš„å®Œå…¨åŒ¹é…ï¼Œè€Œç­‰å€¼è¿æ¥åˆ™å…è®¸åœ¨æŒ‡å®šè¿æ¥æ¡ä»¶æ—¶æ›´å…·çµæ´»æ€§ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323234551078.png" alt="image-20240323234551078" style="zoom:50%;" /> 

Aside from the natural and inner joins we've discussed, SQL also provides outer joins, which come in two main types: left and right. An outer join is particularly useful because it includes in the result set those records that do not have corresponding matches in the other table. This means that, unlike inner joins which only return matched records from both tables, outer joins ensure that all records from one side of the join are returned, with NULL values filling in for any missing matches from the other side.

é™¤äº†æˆ‘ä»¬å·²ç»è®¨è®ºè¿‡çš„è‡ªç„¶è¿æ¥å’Œå†…è¿æ¥ï¼ŒSQL è¿˜æä¾›äº†å¤–è¿æ¥ï¼Œä¸»è¦æœ‰ä¸¤ç§ç±»å‹ï¼šå·¦è¿æ¥å’Œå³è¿æ¥ã€‚å¤–è¿æ¥ç‰¹åˆ«æœ‰ç”¨ï¼Œå› ä¸ºå®ƒä¼šåœ¨ç»“æœé›†ä¸­åŒ…æ‹¬é‚£äº›åœ¨å¦ä¸€å¼ è¡¨ä¸­æ²¡æœ‰å¯¹åº”åŒ¹é…çš„è®°å½•ã€‚è¿™æ„å‘³ç€ï¼Œä¸åªè¿”å›ä¸¤ä¸ªè¡¨ä¸­åŒ¹é…è®°å½•çš„å†…è¿æ¥ä¸åŒï¼Œå¤–è¿æ¥ç¡®ä¿äº†è¿æ¥ä¸€ä¾§çš„æ‰€æœ‰è®°å½•éƒ½ä¼šè¢«è¿”å›ï¼Œå¯¹äºå¦ä¸€ä¾§ç¼ºå¤±çš„åŒ¹é…ï¼Œåˆ™ç”¨ NULL å€¼å¡«å……ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323234228394.png" alt="image-20240323234228394" style="zoom:50%;" /> 

Revisiting our earlier example, we have employed an inner join to correlate the 'Customer' and 'Account' tables. The result of this operation, as demonstrated, links Customer 1 and Customer 2 with their respective accounts. This kind of join is fundamental when the objective is to synchronize two tables based on shared attributesâ€”in this case, ensuring that each customer is matched with their correct account details.

å›åˆ°æˆ‘ä»¬ä¹‹å‰çš„ä¾‹å­ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†å†…è¿æ¥æ¥å…³è” 'Customer' å’Œ 'Account' è¡¨ã€‚å¦‚ä½ æ‰€è§ï¼Œè¿™ä¸ªæ“ä½œçš„ç»“æœå°†å®¢æˆ· 1 å’Œå®¢æˆ· 2 ä¸ä»–ä»¬å„è‡ªçš„è´¦æˆ·ç›¸è¿æ¥ã€‚å½“ç›®æ ‡æ˜¯åŸºäºå…±äº«å±æ€§åŒæ­¥ä¸¤ä¸ªè¡¨æ—¶ï¼Œè¿™ç§è¿æ¥æ˜¯åŸºæœ¬æ“ä½œâ€”â€”åœ¨æœ¬ä¾‹ä¸­ï¼Œç¡®ä¿æ¯ä¸ªå®¢æˆ·éƒ½ä¸ä»–ä»¬æ­£ç¡®çš„è´¦æˆ·è¯¦æƒ…ç›¸åŒ¹é…ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323234742413.png" alt="image-20240323234742413" style="zoom:50%;" /> 

In this illustration of a cross product between the 'Customer' and 'Account' tables, each customer is combined with every account, which may not be immediately evident in the data presented. Not shown here, but present in the dataset, is the customer with ID three, 'Akin', who is also included in this comprehensive pairing.

åœ¨è¿™ä¸ªå±•ç¤º 'Customer' è¡¨å’Œ 'Account' è¡¨ä¹‹é—´çš„äº¤å‰ç§¯çš„ä¾‹å­ä¸­ï¼Œæ¯ä¸ªå®¢æˆ·éƒ½ä¸æ¯ä¸ªè´¦æˆ·è¿›è¡Œäº†ç»„åˆï¼Œè¿™åœ¨æ‰€å‘ˆç°çš„æ•°æ®ä¸­å¯èƒ½ä¸ç«‹å³æ˜¾è€Œæ˜“è§ã€‚è™½ç„¶åœ¨è¿™é‡Œæ²¡æœ‰æ˜¾ç¤ºï¼Œä½†åœ¨æ•°æ®é›†ä¸­ç¡®å®å­˜åœ¨çš„æ˜¯ï¼ŒID ä¸ºä¸‰çš„å®¢æˆ· 'Akin'ï¼Œä»–ä¹Ÿè¢«åŒ…å«åœ¨è¿™ä¸ªå…¨é¢çš„é…å¯¹ä¸­ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323234842908.png" alt="image-20240323234842908" style="zoom:50%;" /> 

In our dataset, we have three customers in total. When employing an inner join between the 'Customer' and 'Account' tables, it's evident that one customer is not represented in the output. This is because there is no corresponding account for this customer; thus, when an inner join is applied, such records without matches are excluded from the results. Outer joins, in contrast, are designed to include these unmatched records by displaying them alongside the matched ones.

åœ¨æˆ‘ä»¬çš„æ•°æ®é›†ä¸­ï¼Œæ€»å…±æœ‰ä¸‰ä½å®¢æˆ·ã€‚å½“ä½¿ç”¨ 'Customer' å’Œ 'Account' è¡¨ä¹‹é—´çš„å†…è¿æ¥æ—¶ï¼Œæ˜æ˜¾å¯ä»¥çœ‹å‡ºæœ‰ä¸€ä¸ªå®¢æˆ·åœ¨è¾“å‡ºä¸­æ²¡æœ‰è¢«è¡¨ç¤ºå‡ºæ¥ã€‚è¿™æ˜¯å› ä¸ºè¿™ä½å®¢æˆ·æ²¡æœ‰å¯¹åº”çš„è´¦æˆ·ï¼›å› æ­¤ï¼Œå½“åº”ç”¨å†…è¿æ¥æ—¶ï¼Œæ²¡æœ‰åŒ¹é…çš„è®°å½•ä¼šä»ç»“æœä¸­è¢«æ’é™¤ã€‚ä¸ä¹‹ç›¸åï¼Œå¤–è¿æ¥çš„è®¾è®¡å°±æ˜¯ä¸ºäº†é€šè¿‡åœ¨åŒ¹é…çš„è®°å½•æ—è¾¹æ˜¾ç¤ºè¿™äº›æœªåŒ¹é…çš„è®°å½•æ¥åŒ…å«è¿™äº›è®°å½•ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323234928584.png" alt="image-20240323234928584" style="zoom:50%;" /> 

In our dataset, we find an example of an outer join, which serves to include not only matching records from two tables but also those without corresponding matches. Specifically, a left outer join will include every record from the left table ('Customer' in our case) and if there's no matching record in the right table ('Account'), the result will display NULL values for the right table's fields. In the example shown, we can see the left outer join in action where the third customer, Akin, who has no matching account, is displayed with NULL values for the account-related fields.

åœ¨æˆ‘ä»¬çš„æ•°æ®é›†ä¸­ï¼Œæˆ‘ä»¬æ‰¾åˆ°äº†ä¸€ä¸ªå¤–è¿æ¥çš„ä¾‹å­ï¼Œå®ƒä¸ä»…åŒ…æ‹¬ä¸¤ä¸ªè¡¨ä¸­åŒ¹é…çš„è®°å½•ï¼Œè¿˜åŒ…æ‹¬é‚£äº›æ²¡æœ‰ç›¸åº”åŒ¹é…çš„è®°å½•ã€‚å…·ä½“æ¥è¯´ï¼Œå·¦å¤–è¿æ¥å°†åŒ…æ‹¬å·¦è¡¨ï¼ˆåœ¨æˆ‘ä»¬çš„æ¡ˆä¾‹ä¸­æ˜¯ 'Customer'ï¼‰çš„æ¯æ¡è®°å½•ï¼Œå¦‚æœåœ¨å³è¡¨ï¼ˆ'Account'ï¼‰ä¸­æ²¡æœ‰åŒ¹é…çš„è®°å½•ï¼Œç»“æœå°†æ˜¾ç¤º NULL å€¼ï¼Œä»£è¡¨å³è¡¨çš„å­—æ®µã€‚åœ¨æ‰€å±•ç¤ºçš„ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°å·¦å¤–è¿æ¥çš„åº”ç”¨ï¼Œå…¶ä¸­ç¬¬ä¸‰ä¸ªå®¢æˆ·ï¼ŒAkinï¼Œæ²¡æœ‰åŒ¹é…çš„è´¦æˆ·ï¼Œå…¶è´¦æˆ·ç›¸å…³å­—æ®µæ˜¾ç¤ºä¸º NULL å€¼ã€‚

The right outer join operates in a symmetrical fashion, where it includes all records from the right table ('Account'), and if there are no corresponding customers, the customer-related fields are filled with NULLs. Although not depicted here, if our data model allowed for accounts without customers, we would see those accounts represented, merged with NULL values where the customer information would be. This distinction illustrates the fundamental difference between outer and inner joins: outer joins can reveal the absence of corresponding data between two tables. Beneath the surface, outer joins utilize a combination of joins and set difference operations from relational algebra, making the direction of the join (left or right) crucial since set difference is not a symmetrical operation.

å³å¤–è¿æ¥ä»¥å¯¹ç§°çš„æ–¹å¼è¿è¡Œï¼Œå®ƒåŒ…æ‹¬å³è¡¨ï¼ˆ'Account'ï¼‰çš„æ‰€æœ‰è®°å½•ï¼Œå¦‚æœæ²¡æœ‰å¯¹åº”çš„å®¢æˆ·ï¼Œå®¢æˆ·ç›¸å…³çš„å­—æ®µå°†å¡«å…… NULL å€¼ã€‚è™½ç„¶è¿™é‡Œæ²¡æœ‰æ˜¾ç¤ºï¼Œä½†å¦‚æœæˆ‘ä»¬çš„æ•°æ®æ¨¡å‹å…è®¸æ²¡æœ‰å®¢æˆ·çš„è´¦æˆ·å­˜åœ¨ï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°è¿™äº›è´¦æˆ·è¢«è¡¨ç¤ºå‡ºæ¥ï¼Œä¸å®¢æˆ·ä¿¡æ¯åº”åœ¨çš„åœ°æ–¹åˆå¹¶çš„ NULL å€¼ã€‚è¿™ç§åŒºåˆ«è¯´æ˜äº†å¤–è¿æ¥å’Œå†…è¿æ¥ä¹‹é—´çš„æ ¹æœ¬å·®å¼‚ï¼šå¤–è¿æ¥å¯ä»¥æ­ç¤ºä¸¤ä¸ªè¡¨ä¹‹é—´å¯¹åº”æ•°æ®çš„ç¼ºå¤±ã€‚åœ¨åº•å±‚ï¼Œå¤–è¿æ¥ä½¿ç”¨äº†å…³ç³»ä»£æ•°ä¸­çš„è¿æ¥å’Œé›†åˆå·®è¿ç®—çš„ç»„åˆï¼Œè¿™ä½¿å¾—è¿æ¥çš„æ–¹å‘ï¼ˆå·¦æˆ–å³ï¼‰è‡³å…³é‡è¦ï¼Œå› ä¸ºé›†åˆå·®ä¸æ˜¯å¯¹ç§°æ“ä½œã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240323235419196.png" alt="image-20240323235419196" style="zoom:50%;" />  

Joints, being a critical concept in database systems, can be illustrated using various methods, and one effective way is through Venn diagrams, a concept you may recall from mathematics. Remembering that tables are sets, we can visualize them as two overlapping circles in a Venn diagram. The first circle encompasses all potential 'ID' values from table T1, while the second encompasses all 'ID' values from table T2. The intersection of these two sets represents the 'ID' values that are common to both tablesâ€”these are the values that joints are concerned with when combining data from T1 and T2.

è¿æ¥æ˜¯æ•°æ®åº“ç³»ç»Ÿä¸­çš„ä¸€ä¸ªå…³é”®æ¦‚å¿µï¼Œå¯ä»¥ç”¨å¤šç§æ–¹æ³•æ¥è¯´æ˜ï¼Œå…¶ä¸­ä¸€ç§æœ‰æ•ˆçš„æ–¹å¼æ˜¯é€šè¿‡æ–‡æ°å›¾ï¼Œè¿™æ˜¯ä½ å¯èƒ½ä»æ•°å­¦è¯¾ä¸Šè®°å¾—çš„æ¦‚å¿µã€‚è®°ä½è¡¨æ˜¯é›†åˆï¼Œæˆ‘ä»¬å¯ä»¥å°†å®ƒä»¬æƒ³è±¡æˆæ–‡æ°å›¾ä¸­çš„ä¸¤ä¸ªé‡å çš„åœ†åœˆã€‚ç¬¬ä¸€ä¸ªåœ†åœˆåŒ…å«äº†è¡¨ T1 ä¸­æ‰€æœ‰å¯èƒ½çš„ 'ID' å€¼ï¼Œè€Œç¬¬äºŒä¸ªåœ†åœˆåŒ…å«äº†è¡¨ T2 ä¸­æ‰€æœ‰çš„ 'ID' å€¼ã€‚è¿™ä¸¤ä¸ªé›†åˆçš„äº¤é›†ä»£è¡¨äº†ä¸¤ä¸ªè¡¨ä¸­å…±æœ‰çš„ 'ID' å€¼â€”â€”å½“æˆ‘ä»¬ç»“åˆæ¥è‡ª T1 å’Œ T2 çš„æ•°æ®æ—¶ï¼Œè¿æ¥æ­£æ˜¯å…³æ³¨è¿™äº›å€¼ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240324000154469.png" alt="image-20240324000154469" style="zoom:50%;" /> 

When we execute a join like `T1 INNER JOIN T2 ON T1.ID = T2.ID`, we're essentially looking for IDs that exist in both tables. This is visually represented in the Venn diagram where the intersection highlights the common IDs. This operation is analogous to a natural join, where the join condition is implicit, provided the attribute names are identical in both tables. Such a join results in a dataset comprising only the records with matching IDs across both tables.

å½“æˆ‘ä»¬æ‰§è¡Œåƒ `T1 INNER JOIN T2 ON T1.ID = T2.ID` è¿™æ ·çš„è¿æ¥æ—¶ï¼Œæˆ‘ä»¬å®é™…ä¸Šæ˜¯åœ¨æŸ¥æ‰¾å­˜åœ¨äºä¸¤ä¸ªè¡¨ä¸­çš„ IDã€‚è¿™åœ¨æ–‡æ°å›¾ä¸­å¾—åˆ°äº†è§†è§‰è¡¨ç¤ºï¼Œäº¤é›†çªå‡ºæ˜¾ç¤ºäº†å…±æœ‰çš„ IDã€‚è¿™ä¸ªæ“ä½œç±»ä¼¼äºè‡ªç„¶è¿æ¥ï¼Œåœ¨è‡ªç„¶è¿æ¥ä¸­ï¼Œåªè¦ä¸¤ä¸ªè¡¨ä¸­çš„å±æ€§åç§°ç›¸åŒï¼Œè¿æ¥æ¡ä»¶å°±æ˜¯éšå«çš„ã€‚è¿™æ ·çš„è¿æ¥ä¼šäº§ç”Ÿä¸€ä¸ªæ•°æ®é›†ï¼Œå…¶ä¸­åªåŒ…å«åœ¨ä¸¤ä¸ªè¡¨ä¸­éƒ½æœ‰åŒ¹é… ID çš„è®°å½•ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240324000243074.png" alt="image-20240324000243074" style="zoom:50%;" /> 

The `T1 LEFT OUTER JOIN T2 ON T1.ID = T2.ID` command not only retrieves records with IDs present in both T1 and T2 tables, as indicated by the intersection in the Venn diagram, but it also includes those records from T1 that do not have corresponding records in T2. In such cases, the missing T2 values are represented by NULLs, or "dummy values," to maintain the integrity of the result set.

é™¤äº†åœ¨ T1 å’Œ T2 ä¸¤ä¸ªè¡¨ä¸­éƒ½å­˜åœ¨çš„ ID è®°å½•ï¼Œ`T1 LEFT OUTER JOIN T2 ON T1.ID = T2.ID` å‘½ä»¤è¿˜åŒ…æ‹¬äº†é‚£äº›åœ¨ T2 ä¸­æ²¡æœ‰å¯¹åº”è®°å½•çš„ T1 ä¸­çš„è®°å½•ï¼Œè¿™åœ¨æ–‡æ°å›¾çš„äº¤é›†ä¸­æœ‰æ‰€ç¤ºã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç¼ºå¤±çš„ T2 å€¼ç”± NULL æˆ–â€œè™šæ‹Ÿå€¼â€è¡¨ç¤ºï¼Œä»¥ä¿æŒç»“æœé›†çš„å®Œæ•´æ€§ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240324000318608.png" alt="image-20240324000318608" style="zoom:50%;" /> 

The `T1 RIGHT OUTER JOIN T2 ON T1.ID = T2.ID` command, represented symmetrically in a Venn diagram, retrieves not only the records with IDs found in both tables, which is the intersection, but also all records from the right-hand table (T2) that don't have a corresponding match on the left (T1). These unmatched T2 records are paired with NULL values. This highlights the key difference between a right outer join and other join types, such as a left outer join or an inner join, which exclusively focuses on matched records.

`T1 RIGHT OUTER JOIN T2 ON T1.ID = T2.ID` å‘½ä»¤åœ¨æ–‡æ°å›¾ä¸­å¯¹ç§°åœ°è¡¨ç¤ºï¼Œä¸ä»…æ£€ç´¢åœ¨ä¸¤ä¸ªè¡¨ä¸­éƒ½æ‰¾åˆ°çš„ ID è®°å½•ï¼Œå³äº¤é›†éƒ¨åˆ†ï¼Œè¿˜åŒ…æ‹¬æ‰€æœ‰å³è¡¨ï¼ˆT2ï¼‰ä¸­æ²¡æœ‰åœ¨å·¦è¡¨ï¼ˆT1ï¼‰ä¸­å¯¹åº”åŒ¹é…çš„è®°å½•ã€‚è¿™äº›æœªåŒ¹é…çš„ T2 è®°å½•å°†ä¸ NULL å€¼é…å¯¹ã€‚è¿™çªå‡ºäº†å³å¤–è¿æ¥ä¸å…¶ä»–è¿æ¥ç±»å‹ï¼ˆå¦‚å·¦å¤–è¿æ¥æˆ–å†…è¿æ¥ï¼‰çš„ä¸»è¦åŒºåˆ«ï¼Œåè€…ä»…ä¸“æ³¨äºåŒ¹é…çš„è®°å½•ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240324000440529.png" alt="image-20240324000440529" style="zoom:50%;" /> 

The `T1 FULL OUTER JOIN T2 ON T1.ID = T2.ID` operation seeks to unify the complete set of records from both T1 and T2. It ensures that all matching records are included in the result set, and additionally, it includes records from both sides that do not have a corresponding match on the other. These unmatched records are combined with NULL values, or "dummy values," to signify the absence of a match. This type of join provides a comprehensive overview by including all possible records from both tables in the query result.

`T1 FULL OUTER JOIN T2 ON T1.ID = T2.ID` æ“ä½œæ—¨åœ¨ç»Ÿä¸€æ¥è‡ª T1 å’Œ T2 çš„å…¨éƒ¨è®°å½•é›†åˆã€‚å®ƒç¡®ä¿æ‰€æœ‰åŒ¹é…çš„è®°å½•éƒ½åŒ…å«åœ¨ç»“æœé›†ä¸­ï¼Œå¹¶ä¸”è¿˜åŒ…æ‹¬æ¥è‡ªä¸¤è¾¹çš„æ²¡æœ‰åœ¨å¦ä¸€è¾¹æ‰¾åˆ°å¯¹åº”åŒ¹é…çš„è®°å½•ã€‚è¿™äº›æœªåŒ¹é…çš„è®°å½•å°†ä¸ NULL å€¼æˆ–â€œè™šæ‹Ÿå€¼â€ç»“åˆï¼Œä»¥è¡¨ç¤ºæ²¡æœ‰æ‰¾åˆ°åŒ¹é…ã€‚è¿™ç§ç±»å‹çš„è¿æ¥é€šè¿‡åœ¨æŸ¥è¯¢ç»“æœä¸­åŒ…å«æ¥è‡ªä¸¤ä¸ªè¡¨çš„æ‰€æœ‰å¯èƒ½è®°å½•ï¼Œæä¾›äº†ä¸€ä¸ªå…¨é¢çš„æ¦‚è§ˆã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240324000654096.png" alt="image-20240324000654096" style="zoom: 33%;" /> 

Let's take a look at how SQL JOINs work with a practical example. Imagine we have a `customer` table with a `Customer ID` and other attributes. We have customers with IDs 1, 2, and 3, each having some data. Additionally, we have an `account` table with `Customer ID`, `Account ID`, `Balance`, and more. In this setup, `Customer ID` 1 has an account with `Account ID` 1 and some balance, `Customer ID` 2 has `Account ID` 2, and there's an `Account ID` 4 that is not linked to any customer. It's an unusual scenario, but let's assume our design allows for it.

ç°åœ¨æˆ‘ä»¬ç”¨ä¸€ä¸ªå®é™…ä¾‹å­æ¥è§£é‡ŠSQLçš„JOINæ“ä½œã€‚è®¾æƒ³æˆ‘ä»¬æœ‰ä¸€ä¸ª`customer`è¡¨ï¼Œæœ‰`Customer ID`å’Œå…¶ä»–å±æ€§ã€‚æˆ‘ä»¬æœ‰IDä¸º1ï¼Œ2å’Œ3çš„å®¢æˆ·ï¼Œæ¯ä¸ªå®¢æˆ·éƒ½æœ‰ä¸€äº›æ•°æ®ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ª`account`è¡¨ï¼Œæœ‰`Customer ID`ã€`Account ID`ã€`Balance`ç­‰æ•°æ®ã€‚åœ¨è¿™ä¸ªè®¾ç½®ä¸­ï¼Œ`Customer ID` 1æœ‰ä¸€ä¸ª`Account ID` 1å’Œä¸€äº›ä½™é¢ï¼Œ`Customer ID` 2æœ‰`Account ID` 2ï¼Œè¿˜æœ‰ä¸€ä¸ª`Account ID` 4æœªé“¾æ¥åˆ°ä»»ä½•å®¢æˆ·ã€‚è¿™æ˜¯ä¸€ä¸ªä¸å¯»å¸¸çš„æƒ…å†µï¼Œä½†æˆ‘ä»¬å‡è®¾æˆ‘ä»¬çš„è®¾è®¡å…è®¸è¿™æ ·ã€‚

The `INNER JOIN` will merge rows based on matching `Customer IDs` in both tables. So, `Customer ID` 1 joins with `Account ID` 1, and `Customer ID` 2 joins with `Account ID` 2. The result will be a combined table with `Customer ID`, `Account ID`, and related data for accounts 1 and 2. Note that `Customer ID` 3 won't appear in this output, as there's no corresponding account.

`INNER JOIN`å°†åŸºäºä¸¤ä¸ªè¡¨ä¸­åŒ¹é…çš„`Customer IDs`åˆå¹¶è¡Œã€‚å› æ­¤ï¼Œ`Customer ID` 1ä¸`Account ID` 1ç›¸ç»“åˆï¼Œ`Customer ID` 2ä¸`Account ID` 2ç›¸ç»“åˆã€‚ç»“æœå°†æ˜¯ä¸€ä¸ªåˆå¹¶çš„è¡¨ï¼Œæœ‰`Customer ID`ã€`Account ID`å’Œ1å·å’Œ2å·è´¦æˆ·çš„ç›¸å…³æ•°æ®ã€‚æ³¨æ„`Customer ID` 3ä¸ä¼šå‡ºç°åœ¨è¿™ä¸ªè¾“å‡ºä¸­ï¼Œå› ä¸ºæ²¡æœ‰å¯¹åº”çš„è´¦æˆ·ã€‚

Using a `LEFT OUTER JOIN`, we can include all records from the left (customer) table. This means `Customer ID` 3 will appear in the output, but it will have null values for `Account ID` and other account-related attributes because it has no matching account.

ä½¿ç”¨`LEFT OUTER JOIN`ï¼Œæˆ‘ä»¬å¯ä»¥åŒ…æ‹¬å·¦ä¾§ï¼ˆcustomerè¡¨ï¼‰çš„æ‰€æœ‰è®°å½•ã€‚è¿™æ„å‘³ç€`Customer ID` 3å°†å‡ºç°åœ¨è¾“å‡ºä¸­ï¼Œä½†å®ƒå°†å¯¹`Account ID`å’Œå…¶ä»–ä¸è´¦æˆ·ç›¸å…³çš„å±æ€§æœ‰ç©ºå€¼ï¼Œå› ä¸ºå®ƒæ²¡æœ‰åŒ¹é…çš„è´¦æˆ·ã€‚

A `RIGHT OUTER JOIN` includes all records from the right (account) table. So, we'll have an entry for `Account ID` 4 with a null `Customer ID` and the corresponding account data. Every attribute from the customer side will be null because there's no matching customer.

`RIGHT OUTER JOIN`åŒ…æ‹¬å³ä¾§ï¼ˆaccountè¡¨ï¼‰çš„æ‰€æœ‰è®°å½•ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°†æœ‰ä¸€ä¸ª`Account ID` 4çš„æ¡ç›®ï¼Œæœ‰ä¸€ä¸ªç©ºçš„`Customer ID`å’Œç›¸åº”çš„è´¦æˆ·æ•°æ®ã€‚å› ä¸ºæ²¡æœ‰åŒ¹é…çš„å®¢æˆ·ï¼Œå®¢æˆ·ç«¯çš„æ¯ä¸ªå±æ€§éƒ½å°†ä¸ºç©ºã€‚

Finally, a `FULL OUTER JOIN` combines the results of both left and right outer joins. It includes all records from both tables, with nulls in place for any unmatched columns from either side.

æœ€åï¼Œ`FULL OUTER JOIN`ç»“åˆäº†å·¦å¤–è¿æ¥å’Œå³å¤–è¿æ¥çš„ç»“æœã€‚å®ƒåŒ…æ‹¬ä¸¤ä¸ªè¡¨ä¸­çš„æ‰€æœ‰è®°å½•ï¼Œå¯¹äºä»»ä¸€ä¾§æœªåŒ¹é…çš„åˆ—ï¼Œå°†ä½¿ç”¨ç©ºå€¼ä»£æ›¿ã€‚

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240324000904526.png" alt="image-20240324000904526" style="zoom:67%;" /> 

In todayâ€™s lecture, we delved into the practical application of SQL JOIN operations, an essential tool for querying and managing databases. We examined how `INNER JOIN`, `LEFT OUTER JOIN`, `RIGHT OUTER JOIN`, and `FULL OUTER JOIN` work using a hypothetical customer-account relationship. The `INNER JOIN` combines records with matching IDs, omitting any without a match. The `LEFT OUTER JOIN` ensures all customer records appear, adding nulls where there's no account match. The `RIGHT OUTER JOIN` includes all account records, with nulls for unmatched customers. And the `FULL OUTER JOIN` captures every record from both tables, with nulls filling the gaps. As we prepare for practical sessions, it's crucial to grasp these concepts and apply them through the detailed examples and tasks in your lab materials, especially if SQL is new to you. Your workshops will provide further practice, reinforcing these operations. I encourage you to engage with these resourcesâ€”theyâ€™re designed to build your proficiency. Thank you for your attention, and I look forward to our next session.

åœ¨ä»Šå¤©çš„è®²åº§ä¸­ï¼Œæˆ‘ä»¬æ·±å…¥æ¢è®¨äº†SQL JOINæ“ä½œçš„å®é™…åº”ç”¨ï¼Œè¿™æ˜¯æŸ¥è¯¢å’Œç®¡ç†æ•°æ®åº“çš„é‡è¦å·¥å…·ã€‚æˆ‘ä»¬ç”¨ä¸€ä¸ªå‡è®¾çš„å®¢æˆ·-è´¦æˆ·å…³ç³»æ¥æ£€éªŒ`INNER JOIN`ã€`LEFT OUTER JOIN`ã€`RIGHT OUTER JOIN`å’Œ`FULL OUTER JOIN`çš„å·¥ä½œåŸç†ã€‚`INNER JOIN`ç»“åˆå…·æœ‰åŒ¹é…IDçš„è®°å½•ï¼Œçœç•¥ä»»ä½•æ²¡æœ‰åŒ¹é…çš„è®°å½•ã€‚`LEFT OUTER JOIN`ç¡®ä¿æ‰€æœ‰å®¢æˆ·è®°å½•å‡ºç°ï¼Œæ·»åŠ ç©ºå€¼åœ¨æ²¡æœ‰è´¦æˆ·åŒ¹é…çš„åœ°æ–¹ã€‚`RIGHT OUTER JOIN`åŒ…æ‹¬æ‰€æœ‰è´¦æˆ·è®°å½•ï¼Œå¯¹äºæœªåŒ¹é…çš„å®¢æˆ·åˆ™ä¸ºç©ºã€‚è€Œ`FULL OUTER JOIN`æ•æ‰ä¸¤ä¸ªè¡¨ä¸­çš„æ¯æ¡è®°å½•ï¼Œç”¨ç©ºå€¼å¡«è¡¥é—´éš™ã€‚å½“æˆ‘ä»¬ä¸ºå®è·µè¯¾ç¨‹åšå‡†å¤‡æ—¶ï¼ŒæŒæ¡è¿™äº›æ¦‚å¿µå¹¶é€šè¿‡æ‚¨çš„å®éªŒææ–™ä¸­çš„è¯¦ç»†ä¾‹å­å’Œä»»åŠ¡åº”ç”¨å®ƒä»¬è‡³å…³é‡è¦ï¼Œå°¤å…¶æ˜¯å¦‚æœSQLå¯¹æ‚¨æ¥è¯´æ˜¯æ–°çš„ã€‚æ‚¨çš„ç ”è®¨ä¼šå°†æä¾›è¿›ä¸€æ­¥çš„å®è·µï¼Œå¼ºåŒ–è¿™äº›æ“ä½œã€‚æˆ‘é¼“åŠ±æ‚¨ä½¿ç”¨è¿™äº›èµ„æºâ€”â€”å®ƒä»¬æ—¨åœ¨æé«˜æ‚¨çš„ç†Ÿç»ƒåº¦ã€‚æ„Ÿè°¢æ‚¨çš„å…³æ³¨ï¼ŒæœŸå¾…æˆ‘ä»¬çš„ä¸‹ä¸€æ¬¡è¯¾ç¨‹ã€‚