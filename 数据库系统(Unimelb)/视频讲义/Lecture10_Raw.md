

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$
<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421152442013.png" alt="image-20240421152442013" style="zoom:50%;" /> 

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421152502013.png" alt="image-20240421152502013" style="zoom:50%;" /> 

```
æˆ‘ä»¬è€ƒè¯•çš„é‡ç‚¹æ˜¯å®é™…åº”ç”¨ï¼Œè€Œä¸æ˜¯æ­»è®°ç¡¬èƒŒå®šä¹‰ã€‚æˆ‘ä»¬ä¸åªæ˜¯è¦æ±‚ä½ å›å¿†æ¯æ¡ SQL è¯­å¥çš„ä½œç”¨ï¼Œæˆ–å®šä¹‰ GROUP BYã€HAVING æˆ–åµŒå¥—ç­‰æœ¯è¯­ã€‚ç›¸åï¼Œæˆ‘ä»¬æ³¨é‡çš„æ˜¯æ‚¨åº”ç”¨è¿™äº›æ¦‚å¿µä¸ºå„ç§å®é™…åœºæ™¯ç¼–å†™ SQL æŸ¥è¯¢çš„èƒ½åŠ›ã€‚è¿™å¯¹ä½ æœªæ¥çš„èŒä¸šç”Ÿæ¶¯å’ŒèŒåœºç”Ÿæ´»éƒ½æ˜¯è‡³å…³é‡è¦çš„æŠ€èƒ½ã€‚æ„Ÿè°¢æ‚¨çš„å…³æ³¨ï¼Œæˆ‘æœŸå¾…ç€ä¸‹ä¸€å ‚è¯¾çš„åˆ°æ¥ã€‚
The focus of our examinations is on practical application rather than rote definitions. We're not just asking you to recall what each SQL statement does or to define terms like GROUP BY, HAVING, or nesting. Instead, we're concentrating on your ability to apply these concepts to write SQL queries for various real-world scenarios. This is a crucial skill for your future ğŸš—eer and life in the workforce. Thank you for your attention, and I look forward to our next session.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421152442013.png" alt="image-20240421152442013" style="zoom:50%;" /> 

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421152601994.png" alt="image-20240421152601994" style="zoom:50%;" /> 

```
æˆ‘ä»¬å·²ç»å­¦ä¼šäº†å¦‚ä½•å°†è¿™äº›è½¬åŒ–ä¸ºæ¨¡å‹ï¼Œç‰¹åˆ«æ˜¯è½¬åŒ–ä¸ºæ•°æ®åº“æ–¹æ¡ˆçš„æ¨¡å‹ã€‚
And we have learned how to transform those into models in particular into model that was translated then into a database scheme. 
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421152442013.png" alt="image-20240421152442013" style="zoom:50%;" /> 

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421152643512.png" alt="image-20240421152643512" style="zoom:50%;" /> 

```
ä¹‹åï¼Œæˆ‘ä»¬äº†è§£äº†å¦‚ä½•æ“ä½œåˆšåˆšåˆ›å»ºçš„æ•°æ®ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å·²ç»æ·±å…¥å­¦ä¹ äº† SQL 
After that, we have looked at how we can manipulate with the data we have just created. So we have covered SQL in depth 
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421152725196.png" alt="image-20240421152725196" style="zoom: 50%;" /> 

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421152745411.png" alt="image-20240421152745411" style="zoom:50%;" /> 

```
æ¬¢è¿å›åˆ°æ•°æ®åº“ç³»ç»Ÿç¬¬åè®²ã€‚ä»Šå¤©ï¼Œæˆ‘ä»¬å°†æ·±å…¥æ¢è®¨å­˜å‚¨å’Œç´¢å¼•ï¼Œå¹¶ç ”ç©¶è¿™ä¸¤è€…åœ¨æ•´ä¸ªè¯¾é¢˜æ¡†æ¶ä¸­çš„å…³ç³»ã€‚æœ€åˆï¼Œæˆ‘ä»¬ç”¨é€šä¿—æ˜“æ‡‚çš„è¯­è¨€åˆ†æäº†é«˜çº§ç”¨ä¾‹ï¼Œç°åœ¨æˆ‘ä»¬å¼€å§‹ç¬¬ä¸‰ä¸ªä¸»è¦éƒ¨åˆ†--å‰–ææ‰§è¡ŒæŸ¥è¯¢æ—¶æ•°æ®åº“ç³»ç»Ÿçš„å†…éƒ¨è¿ä½œã€‚è¿™ä¸€éƒ¨åˆ†å¯èƒ½æ›´å…·æŒ‘æˆ˜æ€§ï¼Œå°¤å…¶æ˜¯å¯¹äºé‚£äº›æ²¡æœ‰è®¡ç®—æœºç§‘å­¦èƒŒæ™¯çš„äººæ¥è¯´ï¼Œå› ä¸ºå…¶ä¸­æ¶‰åŠçš„ä¸€äº›ç®—æ³•å¯èƒ½å¯¹æŸäº›äººæ¥è¯´å¹¶ä¸ç†Ÿæ‚‰ã€‚
Welcome back to the tenth lecture of Database Systems. Today, weâ€™re delving into storage and indexing, and weâ€™ll examine how this fits within the whole framework of the subject. Initially, we analyzed high-level use cases in plain language, and now weâ€™re embarking on the third major segmentâ€”dissecting the internal workings of a database system when we execute our queries. This section may be more challenging, particularly for those without a computer science background, given it covers some algorithms that may be unfamiliar to some of you.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421152725196.png" alt="image-20240421152725196" style="zoom: 50%;" /> 

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421152745411.png" alt="image-20240421152745411" style="zoom:50%;" /> 

```
å¦‚æœä½ è§‰å¾—è¿™ä¸ªå¹¿æ³›çš„ä¸»é¢˜ä»¤äººç”Ÿç•ï¼Œè¯·ä¸è¦æ‹…å¿ƒ--æ— è®ºä½ æ˜¯è®¾è®¡ã€åŒ»å­¦æˆ–å…¶ä»–é¢†åŸŸçš„å­¦å£«ï¼Œä½ éƒ½ä¼šé€šè¿‡å®ƒï¼Œå°±åƒæ¯ä¸ªäººä¸€æ ·ã€‚æœ¬è¯¾ç¨‹æä¾›äº†æˆåŠŸæ‰€éœ€çš„ä¸€åˆ‡ã€‚äº†è§£æ•°æ®åº“çš„å†…éƒ¨ç»“æ„å¯¹äºå¤æ‚çš„æ•°æ®åº“ä½¿ç”¨è‡³å…³é‡è¦ï¼›å®ƒä¸ä»…å…³ä¹å¼€ç®±å³ç”¨çš„åŠŸèƒ½ã€‚æ•°æ®åº“ç»å¸¸éœ€è¦è°ƒæ•´ï¼Œè€Œæ‰å®æŒæ¡å†…éƒ¨è¿ä½œçš„åŸºç¡€çŸ¥è¯†å°†å¤§æœ‰è£¨ç›Šã€‚æ•°æ®åº“æŠ€æœ¯åœ¨ä¸æ–­å‘å±•ï¼Œè®¸å¤šå·¥ä½œæœºä¼šéƒ½é›†ä¸­åœ¨æ•°æ®åº“çš„æ„å»ºã€ä¼˜åŒ–å’Œè°ƒæ•´ä¸Š--è¿™äº›é¢†åŸŸéƒ½æ˜¯å›æŠ¥ä¸°åšçš„é¢†åŸŸã€‚è¿™äº›çŸ¥è¯†ä¸ä»…ä»…æ˜¯å­¦æœ¯æ€§çš„ï¼Œæ›´é‡è¦çš„æ˜¯è®©ä½ æŒæ¡å·¥ä½œæ‰€éœ€çš„æŠ€èƒ½ï¼Œè€Œæˆ‘çš„ç›®æ ‡å°±æ˜¯è®©ä½ ä¸ºè¿™äº›é«˜éœ€æ±‚çš„èŒä½åšå¥½å‡†å¤‡ã€‚
Don't worry if you're finding this broad subject matter dauntingâ€”whether you're a Bachelor of Design, Medicine, or any other field, youâ€™ll get through it, just like everyone does. Everything you need to succeed is provided in this course. Understanding the internals of databases is crucial for sophisticated database use; it's not just about out-of-the-box functionality. Databases often require tuning, and a solid grasp of the basics of internal workings is immensely beneficial. Database technology is constantly evolving, with many job opportunities focused on building, optimizing, and tuning databasesâ€”areas that are highly rewarding. This knowledge is not just academic; itâ€™s about equipping you with the skills needed in the workforce, and I aim to prepare you for these high-demand roles.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421152947963.png" alt="image-20240421152947963" style="zoom:50%;" /> 

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421153002482.png" alt="image-20240421153002482" style="zoom:50%;" /> 

This is one of several possible architectures; each system has its own slight variations.

```
å½“æˆ‘ä»¬æ‰§è¡ŒæŸ¥è¯¢æ—¶ï¼Œæˆ‘ä»¬å°†è¿›å…¥æ•°æ®åº“ç³»ç»Ÿå†…éƒ¨å‘ç”Ÿçš„é”™ç»¼å¤æ‚çš„ç»†èŠ‚--è¿™æ˜¯æœ¬è¯¾ç¨‹å…·æœ‰æŒ‘æˆ˜æ€§ä½†åˆå¿…ä¸å¯å°‘çš„éƒ¨åˆ†ï¼Œå°¤å…¶æ˜¯å¯¹äºé‚£äº›éè®¡ç®—æœºç§‘å­¦èƒŒæ™¯çš„äººæ¥è¯´ã€‚å¯¹äºæŸäº›äººæ¥è¯´ï¼Œç®—æ³•å¯èƒ½æ˜¯å…¨æ–°çš„ï¼Œé‡è¦çš„æ˜¯ä¸è¦ä¸çŸ¥æ‰€æªã€‚æœ¬è¯¾ç¨‹æ—¨åœ¨è®©æ‰€æœ‰å­¦ç”Ÿï¼Œæ— è®ºå…¶ä¸»è¦å­¦ä¹ é¢†åŸŸå¦‚ä½•ï¼Œéƒ½èƒ½å¯¹è¿™äº›æ¦‚å¿µæœ‰å¿…è¦çš„äº†è§£ã€‚è¿™äº›çŸ¥è¯†å¯¹äºä»»ä½•å¸Œæœ›æˆä¸ºæ•°æ®åº“æŠ€æœ¯é«˜çº§ç”¨æˆ·çš„äººæ¥è¯´éƒ½è‡³å…³é‡è¦ï¼Œå› ä¸ºæ•°æ®åº“éœ€è¦å¾®è°ƒæ‰èƒ½è¾¾åˆ°æœ€ä½³æ€§èƒ½ã€‚äº†è§£æ•°æ®åº“å†…éƒ¨è¿ä½œçš„åŸºç¡€çŸ¥è¯†éå¸¸æœ‰å¸®åŠ©ï¼Œè¿™é—¨è¯¾ç¨‹å¯ä»¥è®©æ‚¨ä¸ºåœ¨ç§‘æŠ€è¡Œä¸šä¸­æ‹…ä»»æ•°æ®åº“æ€§èƒ½å’Œä¼˜åŒ–æ–¹é¢çš„é«˜è–ªèŒä½åšå¥½å‡†å¤‡ã€‚
We're moving into the intricate details of what happens inside a database system when we execute queriesâ€”a challenging but essential part of this course, especially for those not from a computer science background. With algorithms that might be new to some, it's important not to be overwhelmed. The course is designed to equip all students, irrespective of their primary field of study, with the necessary understanding of these concepts. This knowledge is crucial for anyone aiming to become a sophisticated user of database technologies, as databases require fine-tuning to perform optimally. Understanding the basics of a database's internal workings is immensely helpful, and this subject prepares you for the highly sought-after, well-compensated roles in database performance and optimization that are abundant in the tech industry.
```


$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421152947963.png" alt="image-20240421152947963" style="zoom:50%;" /> 

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421153002482.png" alt="image-20240421153002482" style="zoom:50%;" /> 

This is one of several possible architectures; each system has its own slight variations.

```
è¿™éƒ¨åˆ†è¯¾ç¨‹æ·±å…¥æ¢è®¨æ•°æ®åº“çš„æŸ¥è¯¢å¤„ç†æ¨¡å—ã€å¹¶å‘æ§åˆ¶å’Œå­˜å‚¨æ¨¡å—--å†³å®šæ•°æ®åº“å¦‚ä½•å­˜å‚¨ã€è®¿é—®å’Œç®¡ç†æ•°æ®çš„å…³é”®ç»„ä»¶ã€‚æˆ‘ä»¬é¦–å…ˆå…³æ³¨æ•°æ®çš„å­˜å‚¨æ–¹å¼ï¼Œä¸ºåé¢è®¨è®ºäº‹åŠ¡å’Œæ•°æ®ç®¡ç†æ‰“ä¸‹åŸºç¡€ã€‚è¯·è®°ä½ï¼Œäº†è§£è¿™äº›å†…éƒ¨å·¥ä½œåŸç†å¹¶ä¸ä»…ä»…æ˜¯å­¦æœ¯æ€§çš„ï¼Œè€Œæ˜¯ä¸ºä½ è¿›å…¥ç°å®ä¸–ç•Œåšå¥½å‡†å¤‡ï¼Œå› ä¸ºåœ¨ç°å®ä¸–ç•Œä¸­ï¼Œæ•°æ®åº“æŠ€èƒ½æ˜¯éå¸¸å®è´µçš„ï¼Œè€Œä¸”å¾€å¾€æ˜¯å¿…éœ€çš„ã€‚
This part of the course dives into the database's query processing module, concurrency control, and storage moduleâ€”key components that determine how a database stores, accesses, and manages data. We start by focusing on how data is stored, giving a foundation for later discussions on transactions and data management. Remember, understanding these inner workings is not just academic; it's about preparing you for the real world where database skills are valuable and often required.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421153735692.png" alt="image-20240421153735692" style="zoom:50%;" /> 

- File organization (Heap \& sorted files)
- Index files \& indexes
- Index classification

```
ä»Šå¤©æˆ‘ä»¬å°†é‡ç‚¹è®¨è®ºæ–‡ä»¶ç»„ç»‡ï¼Œç‰¹åˆ«æ˜¯å †æ–‡ä»¶å’Œæ’åºæ–‡ä»¶ï¼Œå¹¶ä»‹ç»ç´¢å¼•ï¼Œå®ƒæ˜¯æ•°æ®åº“æ“ä½œçš„åŸºç¡€ã€‚ç´¢å¼•è‡³å…³é‡è¦ï¼Œå› ä¸ºå®ƒåœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šå†³å®šäº†æŸ¥è¯¢çš„æ‰§è¡Œé€Ÿåº¦ã€‚æˆ‘ä»¬è¿˜å°†æ·±å…¥ç ”ç©¶å„ç§ç´¢å¼•åˆ†ç±»ã€‚æœ¬è®²åº§çš„ææ–™å–æäº Ramakrishnan å’Œ Gehrke çš„è‘—ä½œã€Šæ•°æ®åº“ç³»ç»Ÿã€‹çš„ç¬¬ 8 ç« ã€‚ç°åœ¨ï¼Œè®©æˆ‘ä»¬å¼€å§‹æ·±å…¥å­¦ä¹ è¿™äº›æ¦‚å¿µã€‚
In our coverage today, weâ€™re focusing on file organization, specifically heap and sorted files, and discussing indices, which are fundamental to the operation of databases. Indices are crucial because they largely determine how quickly our queries are executed. We'll also delve into various index classifications. This lecture's material is based on Chapter 8 from Ramakrishnan & Gehrkeâ€™s "Database Systems" book. Now, let's get started and dive deep into these concepts.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421153819371.png" alt="image-20240421153819371" style="zoom:50%;" /> 

**1ï¸âƒ£****FILE**: A collection of **pages**, each containing a collection of **records.**

```
åœ¨æ•°æ®åº“é¢†åŸŸï¼Œæ•°æ®å­˜å‚¨åœ¨ç§°ä¸ºæ–‡ä»¶çš„ç»“æ„ä¸­ã€‚åœ¨æ¦‚å¿µä¸Šï¼Œè¿™äº›æ–‡ä»¶ä¸æˆ‘ä»¬ç†Ÿæ‚‰çš„ Excel ç”µå­è¡¨æ ¼æˆ– PowerPoint æ¼”ç¤ºæ–‡ç¨¿ç­‰æ–‡æ¡£ç±»ä¼¼ï¼Œéƒ½æ˜¯å®¹å™¨ã€‚ä¸è¿‡ï¼Œæ•°æ®åº“ä¸­çš„æ–‡ä»¶ä¸ä¼—ä¸åŒï¼Œå®ƒä»¬ç”±å›ºå®šå¤§å°çš„é¡µé¢ç»„æˆï¼Œæ¯ä¸ªé¡µé¢éƒ½åŒ…å«ä¸€ç»„è®°å½•ã€‚è¿™äº›è®°å½•æ˜¯ç”±é€—å·åˆ’åˆ†çš„æ•°æ®è¡Œï¼Œæ¯è¡ŒåŒ…å«å¤šåˆ—ã€‚è®°å½•å¯†å¯†éº»éº»åœ°æ’åˆ—åœ¨ä¸€é¡µä¸­ï¼Œç›´åˆ°é¡µæ»¡ä¸ºæ­¢ï¼Œç„¶åå†å¼€å§‹æ–°çš„ä¸€é¡µã€‚
In the realm of databases, data is stored in structures known as files. Conceptually similar to familiar documents, such as Excel spreadsheets or PowerPoint presentations, these files serve as containers. However, the files in databases are distinctive in that they are composed of fixed-size pages, each harboring a collection of records. These records are rows of data delineated by commas, each containing multiple columns. The records are densely packed into a page until it is full, at which point a new page is started.
```


$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421153819371.png" alt="image-20240421153819371" style="zoom:50%;" /> 

**1ï¸âƒ£****FILE**: A collection of **pages**, each containing a collection of **records.**

**2ï¸âƒ£**DBMS must support:

1. insert/delete/modify record
2. read a particular record (specified using record id)
3. scan all records (possibly with some conditions on the records to be retrieved)

```
æ•°æ®åº“å¿…é¡»é«˜æ•ˆåœ°æ‰§è¡Œå„ç§æ“ä½œï¼ŒåŒ…æ‹¬æ’å…¥ã€åˆ é™¤å’Œä¿®æ”¹è®°å½•ã€‚æ•°æ®åº“è¿˜å¿…é¡»æ ¹æ®ç”¨æˆ·è¦æ±‚æŸ¥æ‰¾å’Œæ£€ç´¢ç‰¹å®šè®°å½•ã€‚ä¸ºäº†å®ç°è¿™ä¸€ç›®æ ‡ï¼Œæ•°æ®åº“ä½¿ç”¨äº†ä¸€ç§ç§°ä¸º "è®°å½• ID "çš„ç³»ç»Ÿï¼Œè¿™æ˜¯ä¸€ç§å”¯ä¸€çš„æ ‡è¯†ç¬¦ï¼Œå¯ç²¾ç¡®å®šä½è®°å½•åœ¨æ–‡ä»¶ä¸­çš„ç‰©ç†ä½ç½®ã€‚è™½ç„¶è¿™é‡Œæ²¡æœ‰æ˜¾ç¤ºï¼Œä½†å¯ä»¥è®¾æƒ³æ¯æ¡è®°å½•éƒ½æœ‰ä¸€ä¸ªç‹¬ç‰¹çš„ IDï¼Œé€šå¸¸æ˜¯é¡µç å’Œè¯¥é¡µå†…ä½ç½®åç§»çš„ç»„åˆã€‚è¿™ç§æœºåˆ¶å¯ç¡®ä¿æ•°æ®åº“èƒ½ç²¾ç¡®åœ°å¯¼èˆªå’Œç®¡ç†è®°å½•ï¼Œè¿™ä¹Ÿæ˜¯æˆ‘ä»¬å°†è¿›ä¸€æ­¥è¯¦ç»†æ¢è®¨çš„ä¸€é¡¹é‡è¦åŠŸèƒ½ã€‚
Databases must efficiently perform a variety of operations, including inserting, deleting, and modifying records. They must also locate and retrieve specific records as requested by users. To achieve this, databases use a system known as 'record ID,' a unique identifier pinpointing the physical location of a record within the file. Although not shown here, envision each record possessing a distinct ID, typically a combination of the page number and a positional offset within that page. This mechanism ensures that the database can precisely navigate to and manage records, an essential feature we'll explore in further detail.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421154040761.png" alt="image-20240421154040761" style="zoom:50%;" /> 

Many alternatives exist, each good for some situations, and not so good in others:

**1ï¸âƒ£**Heap files: no particular order among records

- Suitable when typical access is a file scan retrieving all records

**2ï¸âƒ£**Sorted Files: pages and records within pages are ordered by some condition

- Best for retrieval (of a range of records) in some order

```
åœ¨æ–‡ä»¶ç»„ç»‡é¢†åŸŸï¼Œå„ç§æ›¿ä»£æ–¹æ¡ˆåœ¨ç‰¹å®šæƒ…å†µä¸‹è¡¨ç°å‡ºè‰²ï¼Œè€Œåœ¨å…¶ä»–æƒ…å†µä¸‹åˆ™ä¸å°½å¦‚äººæ„ã€‚å †æ–‡ä»¶ç»„ç»‡æ–¹å¼çš„ç‰¹ç‚¹æ˜¯è®°å½•ä¹‹é—´æ²¡æœ‰ä»»ä½•ç‰¹å®šé¡ºåºï¼Œå› æ­¤å½“å…¸å‹æ“ä½œæ˜¯å…¨æ–‡ä»¶æ‰«æä»¥æ£€ç´¢æ‰€æœ‰è®°å½•æ—¶ï¼Œå †æ–‡ä»¶ç»„ç»‡æ–¹å¼ç‰¹åˆ«æœ‰æ•ˆã€‚å¦ä¸€æ–¹é¢ï¼Œæ’åºæ–‡ä»¶ä¼šæ ¹æ®ç‰¹å®šæ ‡å‡†åœ¨é¡µé¢å†…ä¿æŒå†…éƒ¨é¡ºåºã€‚åœ¨æœç´¢ç‰¹å®šèŒƒå›´çš„è®°å½•æ—¶ï¼Œè¿™ç§æ’åºæ–¹å¼èƒ½å¤§å¤§æé«˜æ•°æ®æ£€ç´¢çš„é€Ÿåº¦ã€‚
In the realm of file organization, various alternatives are designed to excel in specific scenarios while being less optimal in others. The heap file organization is characterized by a lack of any specific order among records, making it particularly efficient when the typical operation is a full file scan to retrieve all records. On the other hand, sorted files maintain an internal order within pages according to a specific criterion. This ordering significantly enhances the speed of data retrieval when searching for a particular range of records.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421154040761.png" alt="image-20240421154040761" style="zoom:50%;" /> 

Many alternatives exist, each good for some situations, and not so good in others:

**1ï¸âƒ£**Heap files: no particular order among records

- Suitable when typical access is a file scan retrieving all records

**2ï¸âƒ£**Sorted Files: pages and records within pages are ordered by some condition

- Best for retrieval (of a range of records) in some order

**3ï¸âƒ£**Index File Organizations:

1. Special data structure that has the fastest retrieval in some order
2. Will cover shortly..

```
ç´¢å¼•æ–‡ä»¶ç»„ç»‡å¼•å…¥äº†ä¸€ç§è¾…åŠ©æ•°æ®ç»“æ„ï¼Œé€šè¿‡ä¿æŒä¸€å®šçš„é¡ºåºæ¥æ˜¾è‘—æé«˜æ£€ç´¢é€Ÿåº¦ï¼Œæˆ‘ä»¬å°†åœ¨åé¢è¯¦ç»†è®¨è®ºã€‚æ¯ç§ç»“æ„éƒ½æœ‰å…¶ç‹¬ç‰¹çš„ä¼˜åŠ¿ï¼šå †æ–‡ä»¶åœ¨æ’å…¥æ“ä½œå’Œå…¨è®°å½•è®¿é—®æ–¹é¢é€Ÿåº¦æ˜æ˜¾è¾ƒå¿«ï¼Œè€Œæ’åºæ–‡ä»¶åœ¨æŸ¥è¯¢ç»™å®šæ¡ä»¶ä¸‹çš„ç‰¹å®šå€¼æ–¹é¢è¡¨ç°å‡ºè‰²ã€‚ä¸è¿‡ï¼Œç”±äºå¿…é¡»ä¿æŒé¡ºåºï¼Œåœ¨æ’åºæ–‡ä»¶ä¸­ä¿®æ”¹æˆ–æ’å…¥æ•°æ®å¯èƒ½æ˜¯ä¸€ä¸ªå¤æ‚çš„è¿‡ç¨‹ï¼Œæˆ‘ä»¬å°†å¯¹æ­¤è¿›è¡Œæ›´æ·±å…¥çš„æ¢è®¨ã€‚
Index file organization introduces an auxiliary data structure that significantly boosts retrieval speed by maintaining some order, which we will discuss in detail later. Each structure offers distinct advantages: heap files are notably swift for insert operations and full-record access, while sorted files excel in querying for specific values under a given condition. However, modifying or inserting data in sorted files can be a complex process due to the necessity of maintaining order, which we will examine more closely.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421154320772.png" alt="image-20240421154320772" style="zoom:50%;" /> 

**1ï¸âƒ£**Simplest file structure, contains records in no particular order

**2ï¸âƒ£**As file grows and shrinks, disk pages are allocated and de-allocated

- Fastest for inserts compared to other alternatives

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421154422821.png" alt="image-20240421154422821" style="zoom:50%;" /> 

```
å †æ–‡ä»¶æ˜¯ä¸€ç§ç”¨äºå­˜å‚¨æ•°æ®çš„åˆçº§ç»“æ„ï¼Œå®ƒæ‰€åŒ…å«çš„è®°å½•æ²¡æœ‰ä»»ä½•å›ºæœ‰é¡ºåºã€‚ä¸¾ä¾‹è¯´æ˜ï¼Œæƒ³è±¡ä¸€ä¸ªç”±å››é¡µç»„æˆçš„æ–‡ä»¶ï¼Œæ¯é¡µä¿å­˜å››æ¡è®°å½•ï¼Œæ¯æ¡è®°å½•åŒ…å«ä¸¤ä¸ªå±æ€§ï¼Œå¦‚å¹´é¾„å’Œå·¥èµ„ã€‚è¿™äº›é¡µé¢çœ‹èµ·æ¥ä¼¼ä¹æ˜¯å­¤ç«‹çš„ï¼Œä½†å®é™…ä¸Šå®ƒä»¬æ˜¯ä»¥ä¸€ç§ä¸æ˜“å¯Ÿè§‰çš„æ–¹å¼è¿æ¥åœ¨ä¸€èµ·çš„ï¼›å®ƒä»¬å½¢æˆäº†ä¸€ä¸ªåºåˆ—ï¼Œå…è®¸ä»ä¸€ä¸ªé¡µé¢ç§»åŠ¨åˆ°å¦ä¸€ä¸ªé¡µé¢ã€‚è¿™ç±»ä¼¼äºè®¡ç®—æœºç§‘å­¦ä¸­çš„é“¾è¡¨--ä¸€ç§åŒæ—¶å¼•ç”¨ä¸‹ä¸€ä¸ªå’Œä¸Šä¸€ä¸ªå…ƒç´ çš„ç»“æ„ï¼Œå¯ä»¥åœ¨é¡µé¢ä¹‹é—´è¿›è¡Œå¯¼èˆªã€‚å¯¹äºä¸å¤ªç†Ÿæ‚‰é“¾è¡¨æ¦‚å¿µçš„äººæ¥è¯´ï¼Œæœ€é‡è¦çš„ä¸€ç‚¹æ˜¯è¦äº†è§£æœ‰ä¸€ç§æœºåˆ¶å¯ä»¥è½»æ¾åœ°ä»ä¸€ä¸ªé¡µé¢è·³è½¬åˆ°ä¸‹ä¸€ä¸ªé¡µé¢ã€‚
The heap file is a rudimentary structure for storing data, without any inherent order to the records it contains. To illustrate, imagine a file made up of four pages, where each page holds four records, and each record comprises two attributes, such as age and salary. These pages may seem isolated, but they are actually connected in a way that isn't immediately visible; they form a sequence allowing movement from one page to another. This is similar to a linked list in computer scienceâ€”a structure with references to both the next and previous elementsâ€”enabling navigation between pages. For those less familiar with the concept of linked lists, the critical aspect to understand is that there is a mechanism in place to jump from one page to the subsequent one with ease.
```
$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421154320772.png" alt="image-20240421154320772" style="zoom:50%;" /> 

**1ï¸âƒ£**Simplest file structure, contains records in no particular order

**2ï¸âƒ£**As file grows and shrinks, disk pages are allocated and de-allocated

- Fastest for inserts compared to other alternatives

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421154422821.png" alt="image-20240421154422821" style="zoom:50%;" /> 

```
ç°åœ¨ï¼Œåœ¨å †æ–‡ä»¶ä¸­æ·»åŠ æ–°æ•°æ®çš„è¿‡ç¨‹éå¸¸ç®€å•ï¼Œåªéœ€æ‰¾åˆ°ä¸‹ä¸€ä¸ªç©ºæ§½å³å¯ã€‚è¿™ä¸ªç©ºæ§½å¯èƒ½å°±åœ¨ç°æœ‰é¡µé¢ä¸­ï¼Œæˆ–è€…ï¼Œå¦‚æœå½“å‰é¡µé¢å·²æ»¡ï¼Œæˆ‘ä»¬å°±è·³è½¬åˆ°ä¸‹ä¸€ä¸ªå¯ç”¨é¡µé¢ã€‚è¿™å°±æ˜¯å®ƒçš„å¤æ‚ç¨‹åº¦ï¼Œæˆ–è€…è¯´æ²¡æœ‰å¤æ‚ç¨‹åº¦ã€‚ç„¶è€Œï¼Œè¦æœç´¢ä¸€ä¸ªç‰¹å®šçš„æ•°æ®ç‚¹ï¼Œæ¯”å¦‚æ‰¾å‡ºæ‰€æœ‰ 12 å²æœ‰å·¥èµ„çš„äººçš„è®°å½•ï¼Œåˆ™æ˜¯ä¸€ä¸ªæŒ‘æˆ˜ã€‚åœ¨æ²¡æœ‰ä»»ä½•é¡ºåºçš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¿…é¡»æ£€æŸ¥æ–‡ä»¶ä¸­çš„æ¯ä¸€é¡µï¼Œæ‰¾å‡ºç¬¦åˆæˆ‘ä»¬æ ‡å‡†çš„æ¯ä¸€ä¸ªå®ä¾‹ã€‚è¿™æ ·ï¼Œå †æ–‡ä»¶å°±æ˜¾ç¤ºå‡ºä¸€ç§æ˜æ˜¾çš„æƒè¡¡ï¼šå®ƒä»¬å…è®¸å¿«é€Ÿæ’å…¥æ•°æ®ï¼Œå´ä½¿æœç´¢è¿‡ç¨‹æ›´åŠ è´¹åŠ›å’Œè€—æ—¶ã€‚
Now, when it comes to adding new data to a heap file, the process is as simple as finding the next open slot. This empty slot could be within an existing page, or, if the current page is filled to capacity, we proceed to the next available page. That's the extent of its complexityâ€”or lack thereof. However, searching for a specific data point, such as identifying all records of 12-year-olds with a salary, presents a challenge. Without any sort of order, we must examine each page in the file to locate every instance that meets our criteria. In this way, heap files display a clear trade-off: they permit quick data insertion but make the search process more laborious and time-consuming.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421154520138.png" alt="image-20240421154520138" style="zoom:50%;" /> 

**1ï¸âƒ£**Similar structure like heap files (pages and records), but pages and records are **ordered**

**2ï¸âƒ£**Fast for range queries, but hard for maintenance (each insert potentially reshuffles records)

**3ï¸âƒ£****Example**: A sorted file ordered by age

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421154608240.png" alt="image-20240421154608240" style="zoom:50%;" /> 

```
æ’åºæ–‡ä»¶ä¸å †æ–‡ä»¶åœ¨ç»“æ„ä¸Šæœ‰ç›¸ä¼¼ä¹‹å¤„ï¼Œé¡µé¢å’Œè®°å½•éƒ½æ˜¯æŒ‰ç…§æ¸…æ™°æ˜ç¡®çš„é¡ºåºæ’åˆ—çš„ã€‚ä»¥æŒ‰å¹´é¾„æ’åºçš„æ–‡ä»¶ä¸ºä¾‹ï¼Œå¦‚å±å¹•åº•éƒ¨æ‰€ç¤ºã€‚åœ¨è¿™ç§æ’åˆ—ä¸­ï¼Œå¹´é¾„ä¾æ¬¡é€’å¢-11ã€12ã€13ï¼Œä»¥æ­¤ç±»æ¨-ç¡®ä¿æ•°æ®æœ‰æ¡ä¸ç´Šåœ°æ’åºã€‚è¿™ç§æ’åºå¤§å¤§æé«˜äº†æœç´¢æ•ˆç‡ï¼Œå› ä¸ºè®°å½•çš„ä½ç½®æ˜¯å¯é¢„æµ‹çš„ã€‚
Sorted files share a structural similarity with heap files, with pages and records arranged in a clear, defined order. Take, for example, a sorted file organized by age, as depicted at the bottom of the screen. In this arrangement, ages ascend sequentiallyâ€”11, 12, 13, and so forthâ€”ensuring the data is methodically ordered. This ordering significantly enhances search efficiency since records are predictably placed.
```


$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421154520138.png" alt="image-20240421154520138" style="zoom:50%;" /> 

**1ï¸âƒ£**Similar structure like heap files (pages and records), but pages and records are **ordered**

**2ï¸âƒ£**Fast for range queries, but hard for maintenance (each insert potentially reshuffles records)

**3ï¸âƒ£****Example**: A sorted file ordered by age

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421154608240.png" alt="image-20240421154608240" style="zoom:50%;" /> 

```
ç„¶è€Œï¼Œæ’åºæ–‡ä»¶çš„æœ‰åºæ€§ä¹Ÿç»™æ•°æ®ç»´æŠ¤å¸¦æ¥äº†æŒ‘æˆ˜ã€‚ä¾‹å¦‚ï¼Œè¦æ’å…¥ä¸€æ¡ 15 å²çš„è®°å½•ï¼Œå°±éœ€è¦æŒ‰ç…§æ­£ç¡®çš„é¡ºåºæ’åˆ—ï¼Œè¿™æ ·å°±ä¼šæŠŠåé¢çš„è®°å½•å¾€ä¸‹æ‹‰ã€‚å½“ä¸€é¡µçš„ç©ºé—´ç”¨å®Œæ—¶ï¼Œå¿…é¡»å°†è®°å½•è½¬ç§»åˆ°åç»­é¡µï¼Œè¿™å°±éœ€è¦é¢å¤–çš„ç©ºé—´ï¼Œå¹¶å¯èƒ½å¯¼è‡´è®°å½•è½¬ç§»çš„è¿é”æ•ˆåº”ã€‚ä¸å¤„ç†å †æ–‡ä»¶ç›¸æ¯”ï¼Œè¿™ä¸ªè¿‡ç¨‹æ˜¾ç„¶æ›´è€—è´¹äººåŠ›ï¼Œå› æ­¤é€Ÿåº¦ä¹Ÿæ›´æ…¢ã€‚ç„¶è€Œï¼Œè¿™ç§ç»„ç»‡æ–¹å¼çš„å¥½å¤„æ˜¯ä¸é«˜æ•ˆæœç´¢ç®—æ³•ï¼ˆå¦‚äºŒè¿›åˆ¶æœç´¢ï¼‰å…¼å®¹ï¼Œå…è®¸æ•°æ®åº“å¿«é€Ÿå®šä½æ‰€éœ€è®°å½•ã€‚è¿™ç§å¯¹ç«‹ä½“ç°äº†æ•°æ®åº“ç®¡ç†çš„æ ¸å¿ƒæƒè¡¡--æ’å…¥çš„ç®€ä¾¿æ€§ä¸æ£€ç´¢çš„é€Ÿåº¦ã€‚
However, the ordered nature of sorted files presents challenges during data maintenance. To insert a record for a 15-year-old, for instance, requires placement in the correct sequence, pushing subsequent records down. When space on a page runs out, records must be shifted to subsequent pages, necessitating additional space and potentially causing a cascading effect of record shifting. This process is evidently more labor-intensive compared to handling heap files and, as a result, is slower. Yet, the benefit of such organization is its compatibility with efficient searching algorithms like binary search, allowing databases to quickly locate desired records. This dichotomy exemplifies a core trade-off in database managementâ€”ease of insertion versus speed of retrieval.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421154754467.png" alt="image-20240421154754467" style="zoom:50%;" /> 

- Data is typically stored in pages on Hard Disks (HDD).
- To be able to process and analyze it - data needs to be brought to Memory (RAM).

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421154815423.png" alt="image-20240421154815423" style="zoom: 67%;" /> 

```
æ’åºæ–‡ä»¶ä¸å †æ–‡ä»¶çš„æ¡†æ¶ç›¸ä¼¼ï¼Œéƒ½æ˜¯ç”±åŒ…å«è®°å½•çš„é¡µé¢ç»„æˆã€‚ä½†å…³é”®åŒºåˆ«åœ¨äºï¼Œåœ¨æ’åºæ–‡ä»¶ä¸­ï¼Œè¿™äº›é¡µé¢å’Œè®°å½•æ˜¯æŒ‰ç…§ç‰¹å®šé¡ºåºæ’åˆ—çš„ã€‚è¿™æ–¹é¢çš„ä¸€ä¸ªä¾‹å­æ˜¯æŒ‰å¹´é¾„å±æ€§æ’åºçš„æ–‡ä»¶ï¼Œå¦‚å¹»ç¯ç‰‡åº•éƒ¨æ‰€ç¤ºã€‚è¿™ç§æœ‰åºç»“æ„æœ‰åˆ©äºæœç´¢ï¼Œå› ä¸ºå®ƒå¯ä»¥ä½¿ç”¨é«˜æ•ˆçš„æœç´¢ç®—æ³•ï¼Œå¦‚äºŒè¿›åˆ¶æœç´¢ï¼Œè¿™ç§ç®—æ³•å……åˆ†åˆ©ç”¨äº†æ•°æ®çš„æ’åºæ€§è´¨ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬è¦æŸ¥æ‰¾å¹´é¾„ä¸º 14 å²çš„è®°å½•ï¼Œæˆ‘ä»¬å°±ä¼šçŸ¥é“å°äº 14 å²çš„è®°å½•åœ¨å·¦è¾¹ï¼Œå¤§äº 14 å²çš„è®°å½•åœ¨å³è¾¹ï¼Œä»è€Œä¼˜åŒ–äº†æœç´¢è¿‡ç¨‹ã€‚
Sorted files share a similar framework with heap files, in that they are composed of pages containing records. The critical distinction, however, is that within sorted files, these pages and records are arranged in a specific order. An exemplar of this is a file sorted by the attribute of age, as depicted at the bottom of the slide. This ordered structure is beneficial for searches since it enables the use of efficient searching algorithms like binary search, which capitalizes on the sorted nature of the data. For example, if we seek a record with an age of 14, we know anything less will be to the left, and anything greater will be to the right, thus optimizing the search process.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421154754467.png" alt="image-20240421154754467" style="zoom:50%;" /> 

- Data is typically stored in pages on Hard Disks (HDD).
- To be able to process and analyze it - data needs to be brought to Memory (RAM).

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421154815423.png" alt="image-20240421154815423" style="zoom: 67%;" /> 

```
ç„¶è€Œï¼Œæ’åºæ–‡ä»¶ç»™ç»´æŠ¤å·¥ä½œå¸¦æ¥äº†æŒ‘æˆ˜ï¼Œå°¤å…¶æ˜¯åœ¨æ’å…¥è®°å½•æ—¶ã€‚è¦æ’å…¥ä¸€æ¡ 15 å²ä¸ªäººçš„è®°å½•ï¼Œæˆ‘ä»¬å¿…é¡»å°†å…¶æ”¾åœ¨æ­£ç¡®çš„é¡µé¢ä¸Šï¼Œå¹¶ç›¸åº”åœ°ç§»åŠ¨åç»­è®°å½•ï¼ŒåŒ…æ‹¬åœ¨ç©ºé—´æœ‰é™çš„æƒ…å†µä¸‹å°†ä¸€äº›è®°å½•ç§»åŠ¨åˆ°æ–°çš„é¡µé¢ã€‚è¿™å¯èƒ½æ¶‰åŠå¤§é‡çš„å·¥ä½œï¼Œä½¿æ’å…¥é€Ÿåº¦æ˜æ˜¾æ…¢äºå †æ–‡ä»¶ï¼Œä»è€Œåœ¨é«˜æ•ˆæ•°æ®æ£€ç´¢å’Œç»´æŠ¤æ–‡ä»¶é¡ºåºçš„å¤æ‚æ€§ä¹‹é—´åšå‡ºæƒè¡¡ã€‚
However, sorted files pose challenges for maintenance, particularly when inserting records. To insert a record of an individual aged 15, we must place it on the correct page and shift subsequent records accordingly, including potentially moving some to a new page if space constraints are met. This can involve a substantial amount of work, making insertions significantly slower compared to heap files, thereby presenting a trade-off between efficient data retrieval and the complexity of maintaining the file's order.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421154955705.png" alt="image-20240421154955705" style="zoom:50%;" /> 

**1ï¸âƒ£**DBMS model the cost of all operations

**2ï¸âƒ£**The cost is typically expressed in the number of page accesses (or disk I/O operations - to bring data from disk to memory)

- 1 page access (on disk) $==1 \mathrm{l} / \mathrm{O}$ (used interchangeably)

```
ä»ç£ç›˜è¯»å–æ•°æ®åˆ°å†…å­˜ä¼šäº§ç”Ÿä¸€å®šçš„ä»£ä»·ï¼Œæ•°æ®åº“ç”¨ I/O æ“ä½œæ¥è¡¡é‡è¿™ç§ä»£ä»·ã€‚I/O æ“ä½œè¡¨ç¤ºå°†æ•°æ®ä»ç£ç›˜ä¼ è¾“åˆ°å†…å­˜çš„è¿‡ç¨‹ï¼Œè¿™ç§ä¼ è¾“ä»¥é¡µä¸ºå•ä½è¿›è¡Œã€‚å› æ­¤ï¼Œæ¯æ¬¡ä»ç£ç›˜è·å–æ•°æ®éƒ½ç›¸å½“äºä¸€æ¬¡ I/O æ“ä½œã€‚å› æ­¤ï¼Œå½“æ•°æ®åº“æ¨¡æ‹Ÿæ“ä½œæˆæœ¬æ—¶ï¼Œä¼šè€ƒè™‘åˆ°è¿™ä¸ªæŒ‡æ ‡ï¼Œå°†â€œI/Oâ€å’Œâ€œé¡µè®¿é—®â€ä½œä¸ºåŒä¹‰è¯ä½¿ç”¨ã€‚è¿™æ„å‘³ç€ä»ç£ç›˜è®¿é—®çš„æ¯ä¸ªé¡µéƒ½ç›¸å½“äºä¸€æ¬¡ I/O æ“ä½œï¼Œè¿™æ˜¯æ•°æ®åº“ç³»ç»Ÿé¢†åŸŸç”¨æ¥è¯„ä¼°æ•°æ®æ£€ç´¢å’Œå­˜å‚¨è¿‡ç¨‹æ•ˆç‡çš„æ ‡å‡†è¡¡é‡æ ‡å‡†ã€‚
Accessing data stored on a disk to bring it into memory incurs a cost, which databases quantify in terms of I/O operations. An I/O operation represents the process of transferring data from the disk to memory, and this transfer occurs in units of pages. Consequently, each time data is fetched from the disk, it equates to a single I/O operation. Thus, when databases model the cost of operations, they do so with this metric in mind, using the terms "I/O" and "page access" synonymously. This means that each page access from the disk is considered equivalent to one I/O operation, a standard measure used within the realm of database systems to evaluate the efficiency of data retrieval and storage processes.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421154955705.png" alt="image-20240421154955705" style="zoom:50%;" /> 

**1ï¸âƒ£**DBMS model the cost of all operations

**2ï¸âƒ£**The cost is typically expressed in the number of page accesses (or disk I/O operations - to bring data from disk to memory)

- 1 page access (on disk) $==1 \mathrm{l} / \mathrm{O}$ (used interchangeably)

****3ï¸âƒ£**Example**: If we have a table of 100 records, and each page can store 10 records, what would be the cost of accessing the entire file

```
ä¸ºäº†ç¡®å®šæœ€å…·æˆæœ¬æ•ˆç›Šçš„æ•°æ®å­˜å‚¨æ–¹å¼ï¼Œæ•°æ®åº“ç®¡ç†ç³»ç»Ÿ (DBMS) ä¼šæ¨¡æ‹Ÿæ‰€æœ‰æ“ä½œçš„æˆæœ¬ï¼Œæˆæœ¬é€šå¸¸ç”¨ä»ç£ç›˜åˆ°å†…å­˜ä¼ è¾“æ•°æ®æ‰€éœ€çš„é¡µè®¿é—®æ¬¡æ•°ï¼ˆå³ I/O æ“ä½œæ¬¡æ•°ï¼‰æ¥è¡¡é‡ã€‚ä¸€æ¬¡ä»ç£ç›˜çš„é¡µè®¿é—®ç›¸å½“äºä¸€æ¬¡ I/O æ“ä½œï¼Œå¹¶ä¸”è¯¥æŒ‡æ ‡åœ¨æˆæœ¬å»ºæ¨¡ä¸­å¯ä»¥äº’æ¢ä½¿ç”¨ã€‚ä¾‹å¦‚ï¼Œå¯¹äºä¸€ä¸ªåŒ…å« 100 æ¡è®°å½•çš„è¡¨ï¼Œå…¶ä¸­æ¯ä¸ªé¡µå¯ä»¥å®¹çº³ 10 æ¡è®°å½•ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è€ƒè™‘è¿™äº›æ“ä½œçš„åŸºæœ¬æˆæœ¬å«ä¹‰æ¥ç›´è§‚åœ°ç†è§£è®¿é—®æ•´ä¸ªæ–‡ä»¶æ‰€éœ€çš„æˆæœ¬ã€‚
To ascertain the most cost-effective data storage option, a DBMS will model the cost of all operations, where cost is typically gauged by the number of page accessesâ€”or I/O operationsâ€”required to transfer data from disk to memory. A single page access from the disk equates to one I/O operation, and this metric is employed interchangeably in cost modeling. For example, with a table comprising 100 records, where each page can accommodate 10 records, the cost of accessing the entire file can be intuitively understood by considering the basic cost implications of these operations.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421155409793.png" alt="image-20240421155409793" style="zoom:50%;" /> 

**1ï¸âƒ£**DBMS model the cost of all operations

**2ï¸âƒ£**The cost is typically expressed in the number of page accesses (or disk I/O operations - to bring data from disk to memory)

- 1 page access (on disk) $==1 \mathrm{l} / \mathrm{O}$ (used interchangeably)

**3ï¸âƒ£**Example: If we have a table of 100 records, and each page can store 10 records, what would be the cost of accessing the entire file

**3ï¸âƒ£**==Answer: For 100 records we have 10 pages in total (100/10), thus the cost to access the entire file is $10 \mathrm{I} / \mathrm{O}$ (or 10 pages)==

```
å›åˆ°æˆ‘ä»¬çš„æˆæœ¬æ¨¡å‹ï¼Œè®¿é—®ä¸€ä¸ªåŒ…å« 100 æ¡è®°å½•çš„è¡¨ï¼ˆæ¯ä¸ªé¡µé¢å®¹çº³ 10 æ¡è®°å½•ï¼‰çš„æ“ä½œå°†éœ€è¦ 10 æ¬¡ I/O æ“ä½œï¼Œç›¸å½“äºè®¿é—® 10 ä¸ªé¡µé¢ã€‚è¿™å¾ˆç®€å•ï¼Œæˆ‘ä»¬åªéœ€å°†æ€»è®°å½•æ•°é™¤ä»¥æ¯é¡µçš„è®°å½•æ•°å³å¯ã€‚ç»“æœæ˜¯ 10 é¡µï¼Œå¾ˆå®¹æ˜“ç†è§£ã€‚éšç€æˆ‘ä»¬å¯¹è¿™ä¸ªä¸»é¢˜çš„æ·±å…¥å­¦ä¹ ï¼Œæˆ‘ä»¬å°†ç ”ç©¶æ›´å¤æ‚çš„ä¾‹å­ï¼Œä½†æ˜¯ç†è§£è¿™ä¸ªåŸºæœ¬æ¦‚å¿µè‡³å…³é‡è¦ã€‚å®ƒæ˜¯ä»¥åæŒæ¡æ›´å¤æ‚æ¦‚å¿µçš„åŸºç¡€ç›´è§‰ã€‚
Returning to our cost model, the operation to access a table of 100 recordsâ€”where each page holds 10 recordsâ€”will require 10 I/O operations, equivalent to accessing 10 pages. This is straightforward: we simply divide the total number of records by the number of records per page. The outcome, 10 pages, is quite intuitive. As we progress through the subject, we'll delve into more intricate examples, but this basic understanding is vital. It's an essential intuition that will greatly aid in grasping more complex concepts later on.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421155840161.png" alt="image-20240421155840161" style="zoom:50%;" /> 

**1ï¸âƒ£**Example: Find all records with ages between 20 and 30 , for the file that has $B$ pages. Consider both alternative: having an unsorted and sorted file. What would be the cheapest cost?

**2ï¸âƒ£**$20<$ age $<30$, num pages =$B$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421155947657.png" alt="image-20240421155947657" style="zoom:50%;" /> 

```
è®©æˆ‘ä»¬æ‰®æ¼”æ•°æ®åº“çš„è§’è‰²ï¼Œå¹¶é€šè¿‡ä¸€ä¸ªç®€å•ç¤ºä¾‹æ¥ç†è§£æœç´¢æˆæœ¬ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å°†è¦åœ¨ä¸€ä¸ªåŒ…å«æœªçŸ¥é¡µæ•°ï¼ˆè®°ä¸º Bï¼‰çš„æ–‡ä»¶ä¸­æŸ¥æ‰¾å¹´é¾„åœ¨ 20 åˆ° 30 å²ä¹‹é—´çš„è®°å½•ã€‚æˆ‘ä»¬éœ€è¦è¯„ä¼°ä½¿ç”¨æœªæ’åºæ–‡ä»¶æˆ–å·²æ’åºæ–‡ä»¶çš„æˆæœ¬æ•ˆç›Šã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ç”¨ B ç­‰äº 4 é¡µæ¥æ¼”ç¤ºäº†è¿™ç§æƒ…å†µï¼Œå¹¶æ¯”è¾ƒäº†æœªæ’åºçš„å †æ–‡ä»¶å’Œå·²æ’åºçš„æ–‡ä»¶ã€‚å½“æˆ‘ä»¬æŸ¥çœ‹å †æ–‡ä»¶æ—¶ï¼Œæˆ‘ä»¬ç«‹å³ä¼šçœ‹åˆ°è®°å½•çš„æ’åˆ—æ–¹å¼æ²¡æœ‰ä»»ä½•ç‰¹å®šçš„é¡ºåºã€‚
Let's step into the role of a database and tackle a simple example where we are searching for records with ages between 20 and 30 in a file consisting of an unknown number of pages, denoted as 'B'. We need to evaluate the cost-effectiveness of using either an unsorted or a sorted file. In this instance, I've demonstrated the situation with 'B' equating to four pages, comparing an unsorted heap file and a sorted file. When we look at the heap file, we immediately see that there's no specific order to how the records are arranged.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421155840161.png" alt="image-20240421155840161" style="zoom:50%;" /> 

**1ï¸âƒ£**Example: Find all records with ages between 20 and 30 , for the file that has $B$ pages. Consider both alternative: having an unsorted and sorted file. What would be the cheapest cost?

**2ï¸âƒ£**$20<$ age $<30$, num pages =$B$

**3ï¸âƒ£**Heap file(no order)=B;

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421155947657.png" alt="image-20240421155947657" style="zoom:50%;" /> 

```
åœ¨ä¸€ä¸ªåŒ…å« "B "é¡µæ•°çš„æ–‡ä»¶ä¸­æŸ¥æ‰¾æ‰€æœ‰å¹´é¾„åœ¨ 20 å²è‡³ 30 å²ä¹‹é—´çš„è®°å½•æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»åŒæ—¶è€ƒè™‘æ— æ’åºï¼ˆå †ï¼‰å’Œæ’åºçš„æ–‡ä»¶ç»“æ„ã€‚å¯¹äºæ²¡æœ‰ä»»ä½•ç‰¹å®šæ’åºçš„å †æ–‡ä»¶ï¼Œæˆæœ¬å¿…ç„¶æ˜¯ "B "é¡µï¼Œå› ä¸ºå¿…é¡»æ£€æŸ¥æ¯æ¡è®°å½•ï¼Œä»¥ç¡®å®šå…¶å€¼æ˜¯å¦åœ¨æ‰€éœ€çš„å¹´é¾„èŒƒå›´å†…ã€‚è¿™ç§æ–¹æ³•è¦æ±‚æˆ‘ä»¬ä¾æ¬¡æŸ¥çœ‹æ¯æ¡è®°å½•ï¼Œå› æ­¤å¿…é¡»æ‰«ææ‰€æœ‰é¡µé¢ï¼Œè€Œä¸”ä¸çŸ¥é“ä½•æ—¶æ‰èƒ½å®Œæˆã€‚
When determining the most cost-effective way to find all records with ages between 20 and 30 within a file that contains 'B' number of pages, we have to consider both unsorted (heap) and sorted file structures. For a heap file, which lacks any specific ordering, the cost will invariably be 'B' pages because every record must be checked to ascertain whether its value falls within the desired age range. This method requires us to review each record in turn, making it necessary to scan all pages without knowing when we might be done.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421155840161.png" alt="image-20240421155840161" style="zoom:50%;" /> 

**1ï¸âƒ£**Example: Find all records with ages between 20 and 30 , for the file that has $B$ pages. Consider both alternative: having an unsorted and sorted file. What would be the cheapest cost?

**2ï¸âƒ£**$20<$ age $<30$, num pages =$B$

**3ï¸âƒ£**Heap file(no order)=B;

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421155947657.png" alt="image-20240421155947657" style="zoom:50%;" /> 

```
ç›¸æ¯”ä¹‹ä¸‹ï¼Œå¯¹äºæ’åºæ–‡ä»¶ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨æœ‰åºç»“æ„æ¥æ‰§è¡ŒäºŒè¿›åˆ¶æœç´¢ã€‚è¿™ç§é«˜æ•ˆçš„æœç´¢ç®—æ³•ä¼šå°†æœç´¢ç©ºé—´åˆ†æˆä¸¤åŠï¼Œæ£€æŸ¥ä¸­ç‚¹ä»¥ç¡®å®šå“ªè¾¹åŒ…å«æ‰€éœ€çš„å¹´é¾„èŒƒå›´ï¼Œç„¶ååœ¨è¿™ä¸¤åŠç©ºé—´å†…ç»§ç»­æœç´¢ã€‚è¿™ä¸€è¿‡ç¨‹å¤§å¤§å‡å°‘äº†æˆ‘ä»¬éœ€è¦è®¿é—®çš„é¡µé¢æ•°é‡ï¼Œåœ¨æŸ¥æ‰¾ç‰¹å®šå¹´é¾„èŒƒå›´æ—¶ï¼Œé¡µé¢æ•°é‡å¯èƒ½è¿œè¿œå°‘äº "B"ã€‚
In contrast, with a sorted file, we can leverage the ordered structure to perform a binary search. This efficient searching algorithm splits the search space in half, examines the midpoint to determine which side of the split contains the desired age range, and then continues the search within that half. This process dramatically reduces the number of pages we need to access, which can potentially be far less than 'B' when looking for a specific age range.
```


$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421155840161.png" alt="image-20240421155840161" style="zoom:50%;" /> 

**1ï¸âƒ£**Example: Find all records with ages between 20 and 30 , for the file that has $B$ pages. Consider both alternative: having an unsorted and sorted file. What would be the cheapest cost?

**2ï¸âƒ£**$20<$ age $<30$, num pages =$B$

**3ï¸âƒ£**Heap file(no order)=B;

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421160337090.png" alt="image-20240421160337090" style="zoom:50%;" />  

```
æˆ‘æŠŠå››é¡µçº¸åˆ†æˆä¸¤é¡µè¿›è¡Œåˆ†æï¼Œé‡ç‚¹æ˜¯ä»¥ 20 ä½œä¸ºé˜ˆå€¼ã€‚é‰´äºæˆ‘æœç´¢çš„æ˜¯å¤§äº 20 çš„å€¼ï¼Œæˆ‘ç›¸ä¿¡å®ƒä»¬ä¼šåœ¨å³ä¾§æ‰¾åˆ°ã€‚å› æ­¤ï¼Œæ²¡æœ‰å¿…è¦è€ƒè™‘å·¦ä¾§ï¼Œå› ä¸ºè‚¯å®šä¸ä¼šæœ‰æˆ‘è¦æ‰¾çš„å€¼ã€‚æŒ‰ç…§è¿™ç§ç±»ä¼¼äºäºŒè¿›åˆ¶æœç´¢ç®—æ³•çš„æ–¹æ³•ï¼Œæˆ‘å°†æœ‰æ¡ä¸ç´Šåœ°ç¼©å°æœç´¢èŒƒå›´ï¼Œç›´åˆ°ç©·å°½æˆ‘æ„Ÿå…´è¶£çš„èŒƒå›´ã€‚
I've divided my four pages into two for analysis, focusing on the value of 20 as the threshold. Given that I am searching for values greater than 20, I am confident that they will be found on the right-hand side. Therefore, there's no need to consider the left-hand side since it's certain that the values I seek won't be there. Following this approach, akin to a binary search algorithm, I'll proceed by methodically narrowing down the search area until I exhaust the range I'm interested in.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421155840161.png" alt="image-20240421155840161" style="zoom:50%;" /> 

**1ï¸âƒ£**Example: Find all records with ages between 20 and 30 , for the file that has $B$ pages. Consider both alternative: having an unsorted and sorted file. What would be the cheapest cost?

**2ï¸âƒ£**$20<$ age $<30$, num pages =$B$

**3ï¸âƒ£**Heap file(no order)=B;

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421160555379.png" alt="image-20240421160555379" style="zoom:50%;" /> 

**4ï¸âƒ£**Sorted file(exploit order)=log2B

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421160659424.png" alt="image-20240421160659424" style="zoom: 50%;" /> 

```
åœ¨è¯„ä¼°æœç´¢æ“ä½œçš„æˆæœ¬æ—¶ï¼Œä½¿ç”¨æ’åºæ–‡ä»¶æ•ˆç‡è¦é«˜å¾—å¤šï¼Œå› ä¸ºæˆæœ¬ç”± B çš„ä»¥ 2 ä¸ºåº•çš„å¯¹æ•°å†³å®šã€‚åŸå› å¾ˆç®€å•ï¼šæœç´¢è¿‡ç¨‹ä¸­çš„æ¯æ¬¡é™¤ä»¥ 2 åœ¨å¯¹æ•°ä¸Šéƒ½å¯¹åº”äºå•ä¸ªæ­¥éª¤ã€‚å› æ­¤ï¼ŒB çš„ä»¥ 2 ä¸ºåº•çš„å¯¹æ•°æœ¬è´¨ä¸Šå°†æ¯” B æœ¬èº«æ›´å°ã€‚å› æ­¤ï¼Œä¸ºäº†æœç´¢æ•ˆç‡ï¼Œæˆ‘æ›´å€¾å‘äºä½¿ç”¨æ’åºæ–‡ä»¶è€Œä¸æ˜¯å †æ–‡ä»¶ï¼Œå› ä¸ºæ’åºæ–‡ä»¶åœ¨æœç´¢å¤æ‚åº¦ä¸Šæä¾›äº†å¯¹æ•°ä¼˜åŠ¿ï¼Œä»è€Œå¯ä»¥æ›´å¿«åœ°æ£€ç´¢æ•°æ®ã€‚
In assessing the cost of search operations, using a sorted file is significantly more efficient, given that the cost is determined by log base 2 of B. The reasoning is straightforward: each division by two in the search process corresponds to a single step in logarithmic terms. Consequently, log base 2 of B will inherently be a smaller number than B itself. Therefore, for the purpose of search efficiency, I would favor a sorted file over a heap file, since the former provides a logarithmic advantage in search complexity, leading to faster data retrieval.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240324225411474.png" alt="image-20240324225411474" style="zoom:50%;" /> 

```
Now, let's talk about indices. OK? And they are very important. 
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421160847030.png" alt="image-20240421160847030" style="zoom:50%;" /> 

**1ï¸âƒ£**Sometimes, we want to retrieve records by specifying the values in one or more fields, e.g.,

1. Find all students in the "CIS" department
2. Find all students with a gpa $>3$

**2ï¸âƒ£**An index is a data structure built on top of data pages used for efficient search. The index is built over specific fields called **search key fields**. 

E.g. we can build an index on GPA, or department name.

1. The index speeds up selections on the search key fields
2. Any subset of the fields of a relation can be the search key for an index on the relation
3. Note: Search key is not the same as key (e.g., doesn't have to be unique)

```
å·²æ’åºçš„æ–‡ä»¶ç¡®å®æ˜¯æ•°æ®åº“æœç´¢çš„åŸºçŸ³ã€‚å°½ç®¡å®ƒä»¬å¾ˆæœ‰ç”¨ï¼Œä½†ç»´æŠ¤æ’åºæ–‡ä»¶å´ä»£ä»·ä¸è²ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæ•°æ®åº“ç»å¸¸é‡‡ç”¨æ›¿ä»£æ–¹æ³•ï¼Œä¾‹å¦‚ç´¢å¼•çš„åŸå› ã€‚ç´¢å¼•æ˜¯å»ºç«‹åœ¨æ–‡ä»¶ä¹‹ä¸Šçš„è¾…åŠ©ç»“æ„ï¼Œå¯ä»¥åŠ å¿«æ•°æ®æ£€ç´¢è¿‡ç¨‹ã€‚è¿™äº›ç»“æ„ä¸ä»…ä»…æ˜¯ä»»ä½•å­—æ®µ; å®ƒä»¬ä¸“é—¨å»ºç«‹åœ¨é€‰å®šçš„å­—æ®µæˆ–ç§°ä¸ºæœç´¢é”®å­—æ®µçš„é”®å±æ€§ä¹‹ä¸Šã€‚
Sorted files are indeed the cornerstone of database searches. Despite their usefulness, maintaining sorted files can be quite costly. That's why databases often employ an alternative method, such as indexes. Indexes are auxiliary structures that are layered on top of files to expedite data retrieval processes. These structures are not just any fields; they are specifically built over chosen fields or key attributes known as search key fields.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421160847030.png" alt="image-20240421160847030" style="zoom:50%;" /> 

**1ï¸âƒ£**Sometimes, we want to retrieve records by specifying the values in one or more fields, e.g.,

1. Find all students in the "CIS" department
2. Find all students with a gpa $>3$

**2ï¸âƒ£**An index is a data structure built on top of data pages used for efficient search. The index is built over specific fields called **search key fields**. 

E.g. we can build an index on GPA, or department name.

1. The index speeds up selections on the search key fields
2. Any subset of the fields of a relation can be the search key for an index on the relation
3. Note: Search key is not the same as key (e.g., doesn't have to be unique)

```
è®©æˆ‘ä»¬æ¾„æ¸…ä¸€ä¸‹æœç´¢é”®å­—æ®µçš„å«ä¹‰ - å®ƒä»¬ä¸åŒäºâ€œé”®â€ï¼Œå°½ç®¡å‘½åç›¸ä¼¼ï¼Œä½†ä¸è¦æ··æ·†å®ƒä»¬ã€‚ç´¢å¼•å»ºç«‹åœ¨ä»»ä½•å±æ€§å­é›†ä¸Šï¼Œè¿™äº›å­é›†å°±æ˜¯æˆ‘ä»¬æ‰€è¯´çš„æœç´¢é”®å­—æ®µã€‚è€ƒè™‘æˆ‘ä»¬éœ€è¦æ‰¾åˆ°æ¥è‡ªâ€œCISâ€ç³»çš„æ‰€æœ‰å­¦ç”Ÿæˆ–æ‰€æœ‰ GPA é«˜äº 3 çš„å­¦ç”Ÿçš„æƒ…å†µã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç´¢å¼•éå¸¸å®è´µï¼Œå¯ä»¥å¤§å¤§ä¿ƒè¿›å’ŒåŠ é€Ÿæœç´¢è¿‡ç¨‹ã€‚ç°åœ¨è®©æˆ‘ä»¬æ¥çœ‹çœ‹è¿™äº›ç´¢å¼•æ˜¯å¦‚ä½•æ„å»ºçš„ä»¥åŠå®ƒä»¬å¦‚ä½•åœ¨å®è·µä¸­å‘æŒ¥ä½œç”¨ã€‚
Let's clarify what we mean by search key fieldsâ€”they're distinct from 'keys' and should not be confused with them despite the similar nomenclature. An index is constructed over any subset of attributes, and these subsets are what we refer to as the search key fields. Consider the scenarios where we need to find all students from the "CIS" department or all students with a GPA above 3. In these instances, indexes are invaluable, greatly facilitating and accelerating the search process. Let's now examine how these indexes are constructed and how they function in practice.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421161545368.png" alt="image-20240421161545368" style="zoom:50%;" /> 

An index contains a collection of **data entries**, and supports effi retrieval of **data records** matching a given **search condition**

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421161700519.png" alt="image-20240421161700519" style="zoom:50%;" /> 

```
è¿™ä¸ªä¾‹å­è¯´æ˜äº†ä¸€ç§åŸºæœ¬çš„ç´¢å¼•ç±»å‹ï¼Œç§°ä¸º B+ æ ‘ç´¢å¼•ï¼Œæˆ‘ä»¬ç¨åå°†è¯¦ç»†è®¨è®ºå®ƒã€‚å®ƒçš„ç»“æ„å›´ç»•æœç´¢é”®ï¼Œåœ¨æœ¬ä¾‹ä¸­æ˜¯ GPAã€‚è¿™è¡¨ç¤ºç´¢å¼•å»ºç«‹åœ¨ GPA åˆ—ä¹‹ä¸Šã€‚ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹æ‚¨åœ¨æ¡†ä¸­çœ‹åˆ°çš„æè¿°ã€‚ç´¢å¼•æœ¬è´¨ä¸Šç”±ä¸€ä¸ªæ•°æ®æ¡ç›®æ•°ç»„ç»„æˆï¼Œæ—¨åœ¨ç®€åŒ–æ£€ç´¢ç¬¦åˆç‰¹å®šæœç´¢æ ‡å‡†çš„æ•°æ®è®°å½•ã€‚è®©æˆ‘ä»¬è§£å¼€å¹¶æ¾„æ¸…è¿™ä¸ªæ¦‚å¿µã€‚
This example illustrates a basic type of index known as the B+ tree index, which we will delve into shortly. It's structured around the search key, in this case, the GPA. That signifies that the index is constructed over the column of GPAs. Now, let's turn to the description you see outlined in the box. An index essentially consists of an array of data entries, designed to streamline the retrieval of data records corresponding to a specific search criterion. Let's unpack and clarify this concept.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421161545368.png" alt="image-20240421161545368" style="zoom:50%;" /> 

An index contains a collection of **data entries**, and supports effi retrieval of **data records** matching a given **search condition**

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421161700519.png" alt="image-20240421161700519" style="zoom:50%;" /> 

```
åº•éƒ¨çš„è“è‰²éƒ¨åˆ†æ˜¯æˆ‘ä»¬çš„æ•°æ®æ–‡ä»¶ï¼Œå…¶ä¸­åŒ…å«å­˜å‚¨æœ‰æ•°æ®è®°å½•çš„åŸå§‹é¡µé¢ã€‚æ•°æ®è®°å½•ä¿å­˜åœ¨æ•°æ®é¡µä¸Šã€‚å»ºç«‹åœ¨æ•°æ®æ–‡ä»¶ä¹‹ä¸Šçš„ç´¢å¼•æ–‡ä»¶ï¼Œåœ¨æ­¤ä¾‹ä¸­ï¼ŒåŒ…å«æ•°æ®æ¡ç›® - åº•éƒ¨ç§°ä¸ºæ•°æ®æ¡ç›®çš„é‚£äº›æ•°å­—ä»¥åŠç´¢å¼•ä¸­å¶æ•°æ®æ¡ç›®ä½äºç´¢å¼•åº•éƒ¨çš„å¯¹åº”å€¼ã€‚å¶å€¼åŒ…æ‹¬æœç´¢é”®ï¼Œä¾‹å¦‚ï¼Œæ•°æ®æ¡ç›® 1.2 è¡¨ç¤º GPA å€¼ï¼Œå¹¶æŒ‡ç¤ºåŒ…å«æ­¤ GPA çš„å®é™…è®°å½•çš„ç¡®åˆ‡ä½ç½®ã€‚
At the bottom of this display is our data file, marked in blue. This file holds the original pages with data records stored within. Data records are kept on data pages. Built atop the data file is the index file, which in this context, comprises data entriesâ€”those figures at the bottom termed data entries and the corresponding values in the index where the leaf data entries are positioned at the index's base. The leaf values include the search key, for instance, the data entry of 1.2 represents a GPA value and indicates the precise location of the actual record that holds this GPA.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421161545368.png" alt="image-20240421161545368" style="zoom:50%;" /> 

An index contains a collection of **data entries**, and supports effi retrieval of **data records** matching a given **search condition**

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421161700519.png" alt="image-20240421161700519" style="zoom:50%;" /> 

```
è¿™é‡Œå±•ç¤ºçš„å›¾è¡¨å°±æ˜¯ä¸€ä¸ª B+ æ ‘ç»“æ„çš„ä¾‹å­ã€‚å¯ä»¥æŠŠå®ƒæƒ³è±¡æˆä¸€ä¸ªäºŒå‰æ ‘ï¼Œä½†è¦å¼ºå¤§å¾—å¤šâ€”â€”è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘æŠŠå®ƒæ¯”å–»æˆâ€œæ‰“äº†æ¿€ç´ çš„äºŒå‰æ ‘â€ã€‚è¿™ç§å¢å¼ºæ¥è‡ªäºå®ƒå…·æœ‰å¤šåˆ†æ”¯çš„ç‰¹æ€§ï¼Œä¸åƒç®€å•çš„äºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹éƒ½åªåˆ†ä¸¤ä¸ªåˆ†æ”¯ï¼Œå·¦è¾¹çš„å€¼æ°¸è¿œå°äºèŠ‚ç‚¹çš„å€¼ï¼Œå³è¾¹çš„å€¼å¤§äºæˆ–ç­‰äºèŠ‚ç‚¹çš„å€¼ã€‚
The diagram presented here exemplifies a B+ tree structure. Think of it as a binary tree, only much more robustâ€”that's why I liken it to a binary tree on steroids. The enhancement comes from its multiple branching conditions, unlike the simple binary tree where each node branches into two, and the left value is always less than the node's value, with the right value being greater or equal.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421161545368.png" alt="image-20240421161545368" style="zoom:50%;" /> 

An index contains a collection of **data entries**, and supports effi retrieval of **data records** matching a given **search condition**

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421161700519.png" alt="image-20240421161700519" style="zoom:50%;" /> 

```
B+ æ ‘çš„é¡¶ç«¯æ˜¯æ ¹èŠ‚ç‚¹ï¼Œä¹Ÿç§°ä¸ºç›®å½•ï¼Œä¸ºäº†æ¸…æ¥šèµ·è§ï¼Œæˆ‘ä¼šäº¤æ›¿ä½¿ç”¨è¿™ä¸¤ä¸ªæœ¯è¯­ã€‚æˆ‘ä»¬ä»æ ¹èŠ‚ç‚¹å¼€å§‹æœç´¢ï¼Œåœ¨é‚£é‡Œè¯„ä¼°æœç´¢é”®çš„å€¼ã€‚ä¾‹å¦‚ï¼Œä»»ä½•å°äº 2 çš„å€¼éƒ½å‘å·¦åˆ†æ”¯ï¼Œè€Œä»‹äº 2 å’Œ 2.5 ä¹‹é—´ä»¥åŠ 2.5 å’Œ 3 ä¹‹é—´çš„å€¼åˆ™éµå¾ªè¿™äº›ç‰¹å®šçš„æŒ‡é’ˆï¼Œå¼•å¯¼æˆ‘ä»¬æ‰¾åˆ°å¯¹åº”çš„æ•°æ®æ¡ç›®ã€‚
At the pinnacle of the B+ tree is the root, also referred to as the directory, and I'll use these terms interchangeably for clarity. We initiate our search from the root, where we evaluate the search key values. For example, anything less than the value of two branches off to the left, while values ranging between two and 2.5, and 2.5 and three follow these specific pointers, guiding us to the corresponding data entries.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421161545368.png" alt="image-20240421161545368" style="zoom:50%;" /> 

An index contains a collection of **data entries**, and supports effi retrieval of **data records** matching a given **search condition**

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421161700519.png" alt="image-20240421161700519" style="zoom:50%;" /> 

```
è¯¥æ’å›¾æç»˜äº†ä¸€ä¸ª B+ æ ‘ç´¢å¼•ã€‚å¯ä»¥æŠŠå®ƒæƒ³è±¡æˆä¸€ä¸ªå…·æœ‰å¤šåˆ†æ”¯ï¼ˆä¸ä»…ä»…æ˜¯ä¸¤ä¸ªåˆ†æ”¯ï¼‰çš„å¢å¼ºå‹äºŒå‰æ ‘ã€‚å·¦è¾¹çš„å€¼å§‹ç»ˆå°äºä¸­é—´å€¼ï¼Œå³è¾¹çš„å€¼å¤§äºæˆ–ç­‰äºä¸­é—´å€¼ã€‚æœç´¢ä»é¡¶éƒ¨å¼€å§‹ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºæ ¹èŠ‚ç‚¹æˆ–ç›®å½•ã€‚å¯¹äºå°äº 2 çš„ GPAï¼Œè¯·éµå¾ªå·¦ä¾§æŒ‡é’ˆã€‚ä»‹äº 2 å’Œ 2.5 ä¹‹é—´çš„ GPA å¯ä»¥é€šè¿‡éµå¾ªä¸‹ä¸€ä¸ªæŒ‡é’ˆæ‰¾åˆ°ï¼Œç­‰ç­‰ã€‚
This illustration depicts a B+ tree index. Think of it as a binary tree enhanced with multiple branchingâ€”not just two. The values on the left are always less than the middle value, and the right values are greater than or equal. Starting at the top, which we call the root or directory, the search begins. For a GPA less than two, follow the left-hand pointer. GPAs between two and 2.5 are found by following the next pointer, and so on.
```
$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421161545368.png" alt="image-20240421161545368" style="zoom:50%;" /> 

An index contains a collection of **data entries**, and supports effi retrieval of **data records** matching a given **search condition**

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421161700519.png" alt="image-20240421161700519" style="zoom:50%;" /> 

```
å½“æœç´¢ä»‹äº 2 å’Œ 2.4 ä¹‹é—´çš„ GPA æ—¶ï¼Œæˆ‘ä»¬ä»é¡¶éƒ¨å¼€å§‹å¯¼èˆªï¼Œè¯†åˆ«åˆ°ä»‹äº 2.2 å’Œ 2.4 ä¹‹é—´çš„ GPA ä½äºæ­¤å¤„ï¼Œç„¶åæ²¿ç€è¯¥æŒ‡é’ˆæ‰¾åˆ°ç¬¬ä¸€ä¸ªç¬¦åˆæˆ‘ä»¬æ¡ä»¶çš„ 2.2 çš„æ•°æ®æ¡ç›®ã€‚æˆ‘ä»¬å°†ç»§ç»­è¿™ä¸ªè¿‡ç¨‹ï¼Œæ²¿ç€æŒ‡å‘æ•°æ®è®°å½•çš„æŒ‡é’ˆï¼Œç›´åˆ°è¾¾åˆ°æˆ‘ä»¬èŒƒå›´çš„ä¸Šé™ã€‚ä¸€æ—¦é‡åˆ°è¶…å‡ºæˆ‘ä»¬èŒƒå›´çš„å€¼ï¼ˆä¾‹å¦‚ 2.7ï¼‰ï¼Œæˆ‘ä»¬å°±çŸ¥é“è¦åœæ­¢ï¼Œå› ä¸ºæ‰€æœ‰åç»­æ•°æ®éƒ½å°†è¶…å‡ºèŒƒå›´ã€‚è¿™ç§æ•ˆç‡å¯¹äºåŒ…å«å¤§é‡è®°å½•çš„æ•°æ®åº“æ¥è¯´è‡³å…³é‡è¦ï¼Œå› ä¸ºå®ƒå¯ä»¥æ˜¾ç€æé«˜æŸ¥è¯¢æ€§èƒ½ã€‚è¯·è®°ä½ï¼ŒB+ æ ‘ç”¨äºæ ¹æ® GPA æ’åºçš„ç»“æ„å…è®¸è¿›è¡Œè¿™ç§æœ‰æ•ˆçš„åŸºäºèŒƒå›´çš„æœç´¢å’Œæ£€ç´¢ã€‚
When searching for a GPA between two and 2.4, we navigate from the top, recognizing that GPAs between 2.2 and 2.4 are here, following this pointer to the first data entry at 2.2, which meets our criteria. We continue this process, following pointers to the data records, until reaching the upper limit of our range. Upon hitting a value like 2.7, which exceeds our range, we know to stop, as all subsequent data will be out of scope. This efficiency is vital in databases with vast numbers of records, as it significantly enhances query performance. Remember, the B+ tree's structure for sorting on the GPA allows this effective range-based search and retrieval.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240324231708904.png" alt="image-20240324231708904" style="zoom:50%;" /> 

```
Now, let's see uh what types of fitnesses we can have. 
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421162346324.png" alt="image-20240421162346324" style="zoom:50%;" /> 

Classification based on various factors:

- Clustered vs. Unclustered
- Primary vs. Secondary
- Single Key vs. Composite
- Indexing technique:
  - Tree-based, hash-based, other

```
ç´¢å¼•å¯ä»¥æ ¹æ®å‡ ä¸ªå…³é”®å› ç´ è¿›è¡Œåˆ†ç±»ï¼šèšé›†æˆ–éèšé›†ç´¢å¼•ã€ä¸»é”®æˆ–è¾…åŠ©ç´¢å¼•ã€ä½¿ç”¨å•ä¸ªé”®æˆ–å¤åˆé”®ï¼Œä»¥åŠç´¢å¼•æŠ€æœ¯ - åŸºäºæ ‘æˆ–åŸºäºå“ˆå¸Œã€‚è¿™ç§åˆ†ç±»æœ‰åŠ©äºåŒºåˆ†æ•°æ®åº“ç³»ç»Ÿä¸­ç´¢å¼•çš„ç±»å‹å’ŒåŠŸèƒ½ã€‚æˆ‘ä»¬å°†å•ç‹¬æ¢ç´¢è¿™äº›åˆ†ç±»ã€‚è¿™å¾ˆé‡è¦ï¼Œå› ä¸ºè¿™äº›æœ¯è¯­åœ¨äº’è”ç½‘ã€æ•™ç§‘ä¹¦å’Œä¸“ä¸šè®¨è®ºä¸­æ™®éå­˜åœ¨ã€‚ä¸€äº›å‚è€ƒæ–‡çŒ®å¯èƒ½åªæåˆ°ä¸»é”®æˆ–è¾…åŠ©ç´¢å¼•ï¼Œè€Œå¦ä¸€äº›å‚è€ƒæ–‡çŒ®å¯èƒ½ä¼šå°†ç´¢å¼•åŒºåˆ†ä¸ºèšé›†ç´¢å¼•æˆ–éèšé›†ç´¢å¼•ã€‚ç†è§£è¿™äº›æœ¯è¯­å¯ä»¥ç¡®ä¿æ‚¨è‡ªä¿¡åœ°é©¾é©­ä¸»é¢˜å¹¶å……åˆ†ç†è§£æ•°æ®åº“ä¸­ç´¢å¼•åˆ†ç±»çš„è®¨è®ºã€‚
Indexes can be classified based on several key factors: whether they are clustered or unclustered, primary or secondary, use a single key or a composite key, and the indexing techniqueâ€”tree-based or hash-based. This classification helps to distinguish the type and functionality of an index in a database system. Weâ€™ll explore these classifications individually. This is important because these terms are prevalent across the internet, in textbooks, and in professional discussions. Some references may simply mention primary or secondary indexes, others might distinguish indexes as clustered or unclustered. Understanding these terms ensures you can confidently navigate the subject matter and fully grasp the discussions around index classification in databases.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421162455006.png" alt="image-20240421162455006" style="zoom: 50%;" /> 

**Clustered vs. unclustered**: If order of **data records** is the same as the order of **index data entries**, then the index is called clustered index. Otherwise is unclustered.

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421162644005.png" alt="image-20240421162644005" style="zoom:50%;" /> 

```
é›†ä¸­å¼ä¸å¦å–å†³äºæ•°æ®è®°å½•çš„é¡ºåºæ˜¯å¦ä¸ç´¢å¼•æ•°æ®é¡¹çš„é¡ºåºç›¸å¯¹åº”ã€‚å¦‚æœå †çš„æ•°æ®è®°å½•ä¸å¶å­é¡µä¸­ç´¢å¼•é¡¹çš„é¡ºåºä¸€è‡´ï¼Œåˆ™è¯¥ç´¢å¼•ä¸ºèšé›†ç´¢å¼•ã€‚å¦åˆ™ï¼Œå®ƒæ˜¯éèšé›†çš„ã€‚æ’å›¾å·¦ä¾§æ˜¾ç¤ºäº†ä¸€ä¸ªèšé›†çš„ B+ æ ‘ç´¢å¼•ï¼Œå…¶ä¸­é¡µé¢å†…çš„æ•°æ®é¡¹é¡ºåºåæ˜ äº†å †ä¸­æ•°æ®è®°å½•çš„é¡ºåºã€‚å³ä¾§ä¸ºéèšé›† B+ æ ‘ç´¢å¼•ç¤ºä¾‹ï¼Œè™½ç„¶æ•°æ®é¡¹æ˜¯æ’åºçš„ï¼Œä½†å…³è”çš„æ•°æ®è®°å½•å¹¶éµå¾ªç‰¹å®šé¡ºåºã€‚è¿™æ˜¯èšé›†ç´¢å¼•å’Œéèšé›†ç´¢å¼•çš„ä¸»è¦åŒºåˆ«ã€‚ä¸‰è§’å½¢å›¾æ˜¯ B+ æ ‘çš„æŠ½è±¡è¡¨ç¤ºï¼Œå¸¸ç”¨äºæ•™ç§‘ä¹¦ä¸­ï¼Œè¡¨ç¤ºä»æ ¹èŠ‚ç‚¹åˆ°åŒ…å«æ•°æ®é¡¹çš„å¶èŠ‚ç‚¹çš„å¯¼èˆªè¿‡ç¨‹ã€‚è¯¥å›¾è¡¨ç®€åŒ–äº† B+ æ ‘çš„ç»“æ„ï¼šå·¦ä¾§è¡¨ç¤ºèšé›†æ’åˆ—ï¼Œå³ä¾§è¡¨ç¤ºéèšé›†æ’åˆ—ã€‚
Clustering is determined by whether the order of data records corresponds with the order of index data entries. If a heapâ€™s data records match the sequence of index entries in the leaf pages, thatâ€™s a clustered index. Otherwise, it's unclustered. The left side of the illustration shows a clustered B+ tree index where the order of data entries within a page reflects the sequential order of data records in the heap. When it comes to an unclustered B+ tree index, depicted on the right, while the data entries are sorted, the associated data records do not follow a particular order. This is the primary distinction between clustered and unclustered. The triangular diagrams are abstract representations of B+ trees, commonly used in textbooks to symbolize the navigation through the tree, from the root down to the leaf nodes where the data entries reside. The diagram simplifies the B+ tree's structure: the left signifies a clustered arrangement, and the right, unclustered.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421162803204.png" alt="image-20240421162803204" style="zoom:50%;" /> 

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421162822085.png" alt="image-20240421162822085" style="zoom:50%;" /> 

```
è®©æˆ‘ä»¬ä»”ç»†è§‚å¯Ÿæ•°æ®åº“æ–‡ä»¶é¡¶éƒ¨çš„ B+ æ ‘ç´¢å¼•æ˜¯å¦‚ä½•æ„å»ºæ•°æ®çš„ã€‚æœç´¢å§‹äºæ ¹èŠ‚ç‚¹ï¼ˆä¹Ÿç§°ä¸ºç›®å½•ï¼‰ï¼Œç„¶ååˆ°è¾¾å†…éƒ¨èŠ‚ç‚¹ï¼Œæœ€ç»ˆåˆ°è¾¾åº•éƒ¨çš„å¶èŠ‚ç‚¹ã€‚æ­£å¦‚æˆ‘ä¹‹å‰æåˆ°çš„ï¼Œè¿™äº›å¶èŠ‚ç‚¹åŒ…å«æ•°æ®é¡¹ï¼Œå®ƒä»¬é€šè¿‡æŒ‡é’ˆæˆ–è®°å½• ID ä¸æ•°æ®ç›¸å…³è”ï¼Œè¿™äº›æŒ‡é’ˆæˆ–è®°å½• ID ç²¾ç¡®åœ°æŒ‡å‘æ‰€éœ€æ•°æ®çš„å­˜æ”¾ä½ç½®ã€‚å¦‚å›¾æ‰€ç¤ºï¼Œè¿™ä¸ªé¡ºåºç»è¿‡ç²¾å¿ƒæ’åºï¼Œä»è€Œä¼˜åŒ–äº†æœç´¢è¿‡ç¨‹ã€‚ç„¶è€Œï¼Œè¿™ç§ç»“æ„åœ¨æ•°æ®æ›´æ–°è¿‡ç¨‹ä¸­ä¼šå¸¦æ¥å¤æ‚æ€§ï¼Œéœ€è¦å¯¹ç›¸åº”çš„ç´¢å¼•è¿›è¡Œæ›´æ”¹ï¼Œè€Œè¿™åˆæ˜¯ä¸€é¡¹ç¹é‡çš„æ“ä½œã€‚
Zooming into the details of how data is structured, we observe the B+ tree index built atop our heap file. It starts with the root, or directory, where every search begins. This leads to internal nodes and, ultimately, to the leaf nodes at the bottom. These leaf nodes contain data entries linked with pointers or record IDs, which I mentioned at the beginning of the lecture, pinpointing the exact location of the desired data. As shown, the sequence is meticulously ordered, optimizing the search process. However, this structure introduces complexities during data updates, necessitating alterations in the corresponding index, which is an extensive operation.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421162930816.png" alt="image-20240421162930816" style="zoom:50%;" /> 

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421162937573.png" alt="image-20240421162937573" style="zoom:50%;" />  

```
ç°åœ¨è®©æˆ‘ä»¬æ¥çœ‹çœ‹è¿™é‡Œæç»˜çš„éèšé›†ç´¢å¼•ï¼Œç´¢å¼•æœ¬èº«çš„ç»“æ„ä»ç„¶å’Œæˆ‘ä»¬ä¹‹å‰è®¨è®ºçš„ä¸€è‡´ï¼šå®ƒæœ‰æ ¹èŠ‚ç‚¹ã€å†…éƒ¨èŠ‚ç‚¹å’Œå¶èŠ‚ç‚¹ã€‚ç„¶è€Œï¼ŒåŒºåˆ«ä¹‹å¤„åœ¨äºæˆ‘ä»¬ä»å¶èŠ‚ç‚¹è·Ÿè¸ªæ•°æ®é¡¹åˆ°å †æ–‡ä»¶æ—¶çš„è¡¨ç°ã€‚åœ¨è¿™é‡Œï¼Œæ•°æ®æ²¡æœ‰ç‰¹å®šçš„å­˜å‚¨é¡ºåºï¼Œè¿™ä½¿å¾—æˆ‘ä»¬æ— æ³•é¢„å…ˆç¡®å®šæ‰¾åˆ°æ‰€éœ€è®°å½•çš„è·¯å¾„ã€‚è¿™ä¸€ç‚¹åœ¨æœç´¢ä¸€ç³»åˆ—å€¼æ—¶å°¤å…¶é‡è¦ï¼Œå› ä¸ºåœ¨æœç´¢æ•ˆç‡æ–¹é¢ï¼Œä¸€ç§ç±»å‹çš„ç´¢å¼•å¯èƒ½æ¯”å¦ä¸€ç§ç±»å‹å…·æœ‰æ˜æ˜¾çš„ä¼˜åŠ¿ï¼Œè¿™ä¸€ç‚¹å°†åœ¨æˆ‘ä»¬æ›´æ·±å…¥åœ°ç ”ç©¶è¯¥ä¸»é¢˜æ—¶å˜å¾—æ›´åŠ æ˜æ˜¾ã€‚
Turning our attention to the unclustered index depicted here, the structure of the index itself remains consistent with what weâ€™ve discussed: there's a root, internal nodes, and leaf nodes. However, the distinguishing feature arises when we trace the data entries from the leaf nodes to the heap file. Here, the data is stored in no particular order, leaving us without a predetermined path to locate the desired record. This aspect becomes particularly critical when searching for a range of values, as one type of index may offer a significant advantage over the other in terms of search efficiency, which will become apparent as we delve deeper into the topic.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421162951520.png" alt="image-20240421162951520" style="zoom:50%;" /> 

**1ï¸âƒ£**A data file can have a clustered index on at most one search key combination (i.e. we cannot have multiple clustered indexes over a single table)

**2ï¸âƒ£**Cost of retrieving data records through index varies greatly based on whether index is clustered (cheaper for clustered)

**3ï¸âƒ£**Clustered indexes are more expensive to maintain (require file reorganization), but are really efficient for range search

```
åœ¨èšé›†æ–¹é¢ï¼Œå­˜åœ¨ä¸€äº›å›ºæœ‰çš„ç‰¹æ€§ã€‚ä¸€ä¸ªæ•°æ®æ–‡ä»¶åªèƒ½å¯¹å•ä¸ªæœç´¢é”®ç»„åˆæ‹¥æœ‰ä¸€ä¸ªèšé›†ç´¢å¼•ï¼Œè¿™æ„å‘³ç€å•ä¸ªè¡¨ä¸Šä¸å¯èƒ½å­˜åœ¨å¤šä¸ªèšé›†ç´¢å¼•ã€‚è¿™ç§é™åˆ¶æ˜¯ç”±äºèšé›†ç´¢å¼•çš„æ€§è´¨æ‰€è‡´ï¼Œå®ƒå°†è¡Œçš„ç‰©ç†é¡ºåºä¸ç´¢å¼•å¯¹é½ï¼Œå› æ­¤åªå…è®¸ä¸€ç§è¿™æ ·çš„æ’åºé¡ºåºã€‚
In terms of clustering, certain properties are inherent. A data file may only have a clustered index on a single search key combination, meaning multiple clustered indexes on a single table are not possible. This constraint is due to the nature of clustered indexes, which align the physical order of rows with the index, thus only one such ordering is feasible.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421162803204.png" alt="image-20240421162803204" style="zoom:50%;" /> 

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421162822085.png" alt="image-20240421162822085" style="zoom:50%;" /> 

```
å¦‚æœæˆ‘ä»¬é‡æ–°å®¡è§†è¿™ä¸ªæ¦‚å¿µï¼Œå°±ä¼šæ˜æ˜¾å‘ç°ä¸ºä»€ä¹ˆä¸èƒ½åœ¨åŒä¸€å¼ è¡¨ä¸Šæ‹¥æœ‰ä¸¤ä¸ªèšé›†ç´¢å¼•ã€‚èšé›†ç´¢å¼•çš„æœ¬è´¨åœ¨äºæ•°æ®è¾“å…¥çš„é¡ºåºï¼Œå®ƒç»´æŠ¤ç€å·²æ’åºé¡µé¢çš„çº¿æ€§åºåˆ—ã€‚å¼•å…¥ç¬¬äºŒä¸ªèšé›†ç´¢å¼•å°†éœ€è¦ä¸€ä¸ªå®Œå…¨ä¸åŒçš„é¡ºåºï¼Œè¿™å¯¹äºä¸€ç»„é¡µé¢æ¥è¯´æ˜¯ä¸å¯è¡Œçš„ã€‚ä¾‹å¦‚ï¼Œæƒ³è±¡ä¸€ä¸‹ï¼Œå¦‚æœä¸€ä¸ªé¡µé¢åŒæ—¶è¦æŒ‰å¹´é¾„å’Œè–ªæ°´æ’åºï¼›å®ƒæ ¹æœ¬æ— æ³•åŒæ—¶å®¹çº³ä¸¤ç§ä¸åŒçš„é¡ºåºã€‚å› æ­¤ï¼ŒåŒé‡èšé›†ç´¢å¼•æ˜¯ä¸å¯èƒ½çš„ã€‚
If we revisit the concept, it becomes apparent why we cannot have two clustered indexes on the same table. The essence of a clustered index lies in the order of data entry, maintaining a linear sequence of sorted pages. Introducing a second clustered index would necessitate an entirely different order, which is infeasible for a single set of pages. Imagine, for instance, if a page were to be simultaneously sorted by age and salary; it simply cannot accommodate two distinct orders simultaneously. Hence, the impossibility of dual clustered indexes.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421162951520.png" alt="image-20240421162951520" style="zoom:50%;" /> 

**1ï¸âƒ£**A data file can have a clustered index on at most one search key combination (i.e. we cannot have multiple clustered indexes over a single table)

**2ï¸âƒ£**Cost of retrieving data records through index varies greatly based on whether index is clustered (cheaper for clustered)

**3ï¸âƒ£**Clustered indexes are more expensive to maintain (require file reorganization), but are really efficient for range search

```
åœ¨è®¨è®ºæ£€ç´¢æ•°æ®è®°å½•çš„æˆæœ¬æ—¶ï¼Œé‡è¦çš„æ˜¯è¦æ³¨æ„è¿™äº›æˆæœ¬å¯èƒ½å·®åˆ«å¾ˆå¤§ã€‚ç›®å‰ï¼Œåªéœ€æåŠåœ¨æœç´¢ç‰¹å®šå€¼æ—¶ï¼Œèšç±»ç´¢å¼•é€šå¸¸æ¯”éèšç±»ç´¢å¼•æ›´å…·æˆæœ¬æ•ˆç›Šã€‚ä¸è¿‡ï¼Œå®ƒä»¬çš„ç»´æŠ¤æˆæœ¬å¯èƒ½ç›¸å½“é«˜ã€‚æˆ‘ä»¬å°†åœ¨åé¢çš„ä¸»é¢˜ä¸­æ·±å…¥æ¢è®¨è¿™äº›ç‰¹æ€§ï¼Œè¿›ä¸€æ­¥é˜æ˜å®ƒä»¬çš„ç‰¹ç‚¹ã€‚
When discussing the cost of retrieving data records, it's important to note that these costs can vary greatly. For the time being, it suffices to mention that clustered indexes are generally more cost-effective than unlu when searching for specific values. However, they can be quite expensive to maintain. We will delve deeper into these properties later in the subject, shedding further light on their characteristics.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421162803204.png" alt="image-20240421162803204" style="zoom:50%;" /> 

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421162822085.png" alt="image-20240421162822085" style="zoom:50%;" /> 

```
è€ƒè™‘åˆ°éèšé›†ç´¢å¼•ï¼Œå¦‚å‰æ‰€è¿°ï¼Œæ’å…¥æ•°æ®çš„æˆæœ¬ç›¸å½“é«˜ã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬å¿…é¡»åœ¨é¡µé¢ä¸­ç§»åŠ¨æ•°æ®ï¼Œå¹¶å¯èƒ½éœ€è¦è°ƒæ•´ç´¢å¼•ï¼Œä»è€Œå¯¼è‡´å¤§é‡çš„å¼€é”€ã€‚å°½ç®¡å¦‚æ­¤ï¼Œé€šè¿‡è¿™ç§ç´¢å¼•è¿›è¡Œæœç´¢æ˜¯éå¸¸é«˜æ•ˆçš„ã€‚ä¸¾ä¾‹æ¥è¯´ï¼Œå‡è®¾æˆ‘ä»¬çš„å¹´é¾„å€¼èŒƒå›´åœ¨20åˆ°30å²ä¹‹é—´ï¼Œè¿™ä¸ªæ¡ä»¶ç­›é€‰å‡ºäº†300åç¬¦åˆæ¡ä»¶çš„å­¦ç”Ÿã€‚å‡è®¾æˆ‘ä»¬æ¯é¡µå­˜å‚¨100åå­¦ç”Ÿï¼Œç”±äºæ•°æ®æ˜¯å®Œå…¨æ’åºçš„ï¼Œä¸€æ—¦ç´¢å¼•å®šä½åˆ°æ»¡è¶³æ¡ä»¶çš„ç¬¬ä¸€ä¸ªè®°å½•ï¼Œæˆ‘ä»¬åªéœ€è¦è®¿é—®ä¸‰é¡µå³å¯æ£€ç´¢æ‰€æœ‰300åå­¦ç”Ÿã€‚ä¸å…¶ä»–åœºæ™¯ç›¸æ¯”ï¼Œè¿™ç§æœ‰é’ˆå¯¹æ€§çš„æ–¹æ³•æ˜¾è‘—å‡å°‘äº†è®¿é—®çš„é¡µé¢æ•°é‡ã€‚
Considering an unclustered index, as previously mentioned, inserting data incurs significant cost. This is because we must shift data within the pages and potentially adjust the index as well, resulting in substantial overhead. Nonetheless, searching through this index is highly efficient. To illustrate, imagine we have a range of values for age between 20 and 30, a condition that yields 300 qualifying students. Assuming we store 100 students per page, due to the fully sorted nature of the data, once the index locates the first record satisfying the condition, we need only access three pages to retrieve all 300 students. This targeted approach significantly reduces the number of pages accessed compared to other scenarios.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421162803204.png" alt="image-20240421162803204" style="zoom:50%;" /> 

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421162822085.png" alt="image-20240421162822085" style="zoom:50%;" /> 

```
ç„¶è€Œï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè™½ç„¶éèšé›†ç´¢å¼•åœ¨æœç´¢é€Ÿåº¦æ–¹é¢è¡¨ç°å‡ºè‰²ï¼Œä½†å…¶ç»´æŠ¤æˆæœ¬å¯èƒ½éå¸¸é«˜ï¼Œå°¤å…¶æ˜¯å¯¹äºé¢‘ç¹çš„æ•°æ®æ’å…¥æ“ä½œã€‚é‡æ–°æ’åˆ—æ•°æ®é¡µé¢å’Œç´¢å¼•æœ¬èº«çš„éœ€è¦å¢åŠ äº†æ˜¾è‘—çš„å¤æ‚æ€§ï¼Œå¹¶å¯èƒ½å½±å“æ•´ä½“æ€§èƒ½ã€‚å› æ­¤ï¼Œåœ¨è¯„ä¼°éèšé›†ç´¢å¼•çš„é€‚ç”¨æ€§æ—¶ï¼Œå¿…é¡»æƒè¡¡æœç´¢æ•ˆç‡å’Œç»´æŠ¤å¼€é”€ä¹‹é—´çš„å¹³è¡¡ã€‚
However, it's worth noting that while unclustered indexes excel in search speed, their maintenance cost can be prohibitive, especially for frequent data insertions. The need to rearrange both data pages and the index itself adds significant complexity and can impact overall performance. Thus, when evaluating the suitability of an unclustered index, it's crucial to consider the balance between search efficiency and maintenance overhead.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421162930816.png" alt="image-20240421162930816" style="zoom:50%;" /> 

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421162937573.png" alt="image-20240421162937573" style="zoom:50%;" />  

```
ç°åœ¨æƒ³è±¡ä¸€ä¸‹ï¼Œæˆ‘ä»¬æ­£åœ¨ä½¿ç”¨å®Œå…¨ç›¸åŒçš„æ¡ä»¶æœç´¢ç›¸åŒçš„ 300 åå­¦ç”Ÿã€‚ å’Œèšé›†ç´¢å¼•ä¸€æ ·ï¼Œæˆ‘ä»¬å†æ¬¡åœ¨æ ¹èŠ‚ç‚¹æ‰¾åˆ°ç›¸å…³æ•°æ®ï¼Œå¹¶ä¸”ç”±äºæ•°æ®æ˜¯æ’åºçš„ï¼Œè¿™å¸¦æ¥äº†ä¼˜åŠ¿ã€‚ ä½†æ˜¯ï¼Œå¯¹äºéèšé›†ç´¢å¼•ï¼Œå¯¹äºæ¯ä¸ªç¬¦åˆæ¡ä»¶çš„å­¦ç”Ÿï¼Œæˆ‘ä»¬éƒ½å¿…é¡»è·³è½¬æ‰èƒ½æ‰¾åˆ°ä»–ä»¬ç‰¹å®šçš„æ•°æ®ç‰¹å¾ã€‚ ç”±äºæ²¡æœ‰ä¿è¯çš„é¡ºåºï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦è·³è½¬å¹¶è®¿é—®è¿™ 300 åå­¦ç”Ÿçš„ 300 ä¸ªä¸åŒçš„é¡µé¢ã€‚ å°†å…¶ä¸èšé›†ç´¢å¼•åœºæ™¯ä¸­è®¿é—®çš„ä¸‰ä¸ªé¡µé¢è¿›è¡Œæ¯”è¾ƒï¼Œå¾ˆæ˜æ˜¾å“ªç§æ–¹æ³•æ›´å¿«ã€‚ è¿™æ‰æ˜¯æˆæœ¬å·®å¼‚çœŸæ­£æ‰€åœ¨çš„åœ°æ–¹ã€‚
Imagine now that we are searching for the same 300 students, under the exact same conditions. Once again, we locate the relevant data in the root, and just like in the case of the clustered index, the data is sorted, which is advantageous. However, in the case of an unclustered index, for each qualifying student, we must jump to find their specific data features. Since there is no guaranteed order, we could potentially need to jump and access 300 distinct pages for these 300 students. Compare this to the three pages accessed in the clustered index scenario, and it becomes clear which approach is faster. This is where the cost difference truly lies.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421163403492.png" alt="image-20240421163403492" style="zoom:50%;" /> 

- (Approximated) cost of retrieving records found in range scan:

**1ï¸âƒ£**Clustered: cost $\approx \#$ pages in data file with matching records

**2ï¸âƒ£**Unclustered: cost $\approx \#$ of matching index data entries (data records)

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421163451903.png" alt="image-20240421163451903" style="zoom:50%;" /> 

```
æˆ‘åˆšæ‰å¼•å¯¼ä½ ä»¬çš„é€»è¾‘å°†åœ¨è¯„ä¼°å¤‡é€‰æ–¹æ¡ˆæ—¶å¾—åˆ°åº”ç”¨ã€‚å¯¹äºèšé›†ç´¢å¼•ï¼Œæˆæœ¬æ˜¯é€šè¿‡æ•°æ®æ–‡ä»¶ä¸­åŒ…å«åŒ¹é…è®°å½•çš„é¡µæ•°æ¥ä¼°ç®—çš„ã€‚ç¨åæˆ‘ä»¬å°†æ·±å…¥ç ”ç©¶å®é™…çš„å…¬å¼ã€‚ç›®å‰ï¼Œæˆ‘ä»¬æ­£åœ¨å»ºç«‹ä¸€ç§ç›´è§‰ï¼Œè¿™å°†æœ‰åŠ©äºæˆ‘ä»¬åœ¨ä»¥åçš„æˆæœ¬å†³ç­–ä¸­ï¼Œç‰¹åˆ«æ˜¯åœ¨éèšé›†ç´¢å¼•æ–¹é¢ã€‚å¯¹äºéèšé›†ç´¢å¼•ï¼Œæˆæœ¬æ˜¯é€šè¿‡åŒ¹é…çš„ç´¢å¼•æ•°æ®æ¡ç›®æˆ–æ•°æ®è®°å½•çš„æ•°é‡æ¥ä¼°è®¡çš„ã€‚è¿™æ˜¯å› ä¸ºåœ¨ç¬¬ä¸€ä¸ªåœºæ™¯ä¸­ï¼Œ300åå­¦ç”Ÿè¢«æ”¾ç½®åœ¨ä¸‰é¡µå†…ï¼Œä¸€æ—¦è®¿é—®è¿™äº›é¡µé¢ï¼Œæˆ‘ä»¬å°±å®Œæˆäº†ã€‚ä¸€åˆ‡éƒ½æ˜¯æ’åºçš„ï¼Œæ‰€ä»¥æ²¡æœ‰å¿…è¦è¿›ä¸€æ­¥æˆ–æ›´æ·±å…¥åœ°æ£€æŸ¥å€¼ã€‚ä½¿ç”¨æ ‘æ‰¾åˆ°èŒƒå›´åï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°è®¿é—®æ‰€éœ€çš„æ•°æ®ã€‚ç„¶è€Œï¼Œåœ¨éèšé›†ç´¢å¼•çš„æƒ…å†µä¸‹ï¼Œå³ä½¿æ•°æ®æ¡ç›®æ˜¯æ’åºçš„ï¼Œæ¯ä¸ªæ¡ç›®ä¹Ÿå¯èƒ½äº§ç”ŸIOæ“ä½œã€‚åœ¨æˆ‘ä»¬çš„ç¤ºä¾‹ä¸­ï¼Œè¿™ç›¸å½“äº300é¡µã€‚
The logic I have guided you through will be applied when costing the alternatives. In the case of a clustered index, the cost is approximated by the number of pages in the data file containing matching records. We will delve into the actual formulas later. Currently, we are building an intuition that will aid in costing decisions, especially when it comes to unclustered indexes. For unclustered indexes, the cost is estimated by the number of matching index data entries or data records. This is because, in the first scenario, where 300 students are placed within three pages, once these pages are accessed, we are done. Everything is sorted, so there's no need to go further or deeper to examine values. Using the tree to find the range, we can simply access the required data. However, in the case of unclustered indexes, even though the data entries are sorted, each entry potentially incurs an IO operation. In our example, that amounts to 300 pages.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421163403492.png" alt="image-20240421163403492" style="zoom:50%;" /> 

- (Approximated) cost of retrieving records found in range scan:

**1ï¸âƒ£**Clustered: cost $\approx \#$ pages in data file with matching records

**2ï¸âƒ£**Unclustered: cost $\approx \#$ of matching index data entries (data records)

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421163451903.png" alt="image-20240421163451903" style="zoom:50%;" /> 

```
æ­¤å¤–ï¼Œè¿™ç§åŒºåˆ«çªå‡ºäº†èšé›†ç´¢å¼•çš„æ•ˆç‡ã€‚ä¸€æ—¦å®šä½åˆ°ç›¸å…³é¡µé¢ï¼Œæ‰€æœ‰å¿…è¦çš„æ•°æ®éƒ½å¯ä»¥ä»¥æœ€å°çš„åŠªåŠ›è®¿é—®ã€‚ç›¸åï¼Œå¯¹äºéèšé›†ç´¢å¼•ï¼Œæ¯ä¸ªæ•°æ®æ¡ç›®å¯èƒ½éœ€è¦å•ç‹¬çš„IOæ“ä½œï¼Œä»è€Œå¢åŠ æˆæœ¬ã€‚åœ¨è¯„ä¼°ä¸åŒç´¢å¼•ç­–ç•¥çš„æ€§èƒ½å’Œæˆæœ¬æ•ˆç›Šæ—¶ï¼Œè¿™ç§ç†è§£è‡³å…³é‡è¦ã€‚
Continuing on, this distinction highlights the efficiency of clustered indexes. With a clustered index, once the relevant pages are located, all the necessary data is accessible with minimal effort. Conversely, with an unclustered index, each data entry may require a separate IO operation, leading to increased costs. This understanding is crucial when evaluating the performance and cost-effectiveness of different indexing strategies.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421163623963.png" alt="image-20240421163623963" style="zoom:50%;" /> 

- Primary index includes the table's primary key
- Secondary is any other index
- Properties:
- Primary index never contains duplicates
- Secondary index may contain duplicates

```
åœ¨è®¨è®ºä¸»ç´¢å¼•å’Œæ¬¡ç´¢å¼•åˆ†ç±»æ—¶ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸»ç´¢å¼•æ˜¯æŒ‡å»ºç«‹åœ¨ä¸»é”®ä¸Šçš„ç´¢å¼•ï¼Œè€Œæ¬¡ç´¢å¼•åˆ™æ¶µç›–å…¶ä»–ç±»å‹çš„ç´¢å¼•ã€‚è¿™ä¸ªæœ¯è¯­è™½ç„¶å¸¸ç”¨ï¼Œä½†å¾€å¾€ä¼šè®©å­¦ç”Ÿæ„Ÿåˆ°å›°æƒ‘ã€‚ç„¶è€Œï¼ŒåŒºåˆ«å…¶å®å¾ˆç®€å•ï¼šç”±äºä¸»ç´¢å¼•æ˜¯å»ºç«‹åœ¨ä¸»é”®ä¸Šçš„ï¼Œå› æ­¤å®ƒæ°¸è¿œä¸ä¼šåŒ…å«é‡å¤é¡¹ï¼Œå› ä¸ºä¸»é”®æœ¬èº«å°±ä¸å…è®¸é‡å¤ã€‚å¦ä¸€æ–¹é¢ï¼Œæ¬¡ç´¢å¼•å¯èƒ½åŒ…å«é‡å¤é¡¹ã€‚è¿™ç§ç»“æ„ä¸Šçš„å·®å¼‚å¯èƒ½ä¼šå¯¹æ•°æ®åº“æ€§èƒ½å’Œæˆæœ¬äº§ç”Ÿå½±å“ï¼Œå…·ä½“å–å†³äºç‰¹å®šçš„ç”¨ä¾‹ã€‚
When discussing primary and secondary index classification, it's important to note that a primary index refers to an index created over a primary key, while a secondary index encompasses any other type of index. This terminology is commonly used and can often lead to confusion among students. However, the distinction is quite simple: a primary index, being built on the primary key, will never contain duplicates as primary keys themselves do not allow duplicates. On the other hand, a secondary index may contain duplicates. This difference in structure can have implications for database performance and costing, depending on the specific use case.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421163811064.png" alt="image-20240421163811064" style="zoom:50%;" /> 

**1ï¸âƒ£**An index can be built over a combination of search keys

**2ï¸âƒ£**Data entries in index sorted by search keys

**3ï¸âƒ£**- Examples:
1. Index on <age, sal>
2. Index on <sal, age>
3. Efficient to answer:
    age $=12$ and sal $=10$
    age $=12$ and sal $>15$â€‹

 <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421163906832.png" alt="image-20240421163906832" style="zoom:50%;" /> 

```
ç´¢å¼•ä¹Ÿå¯ä»¥å»ºç«‹åœ¨å¤åˆæœç´¢é”®ä¸Šï¼Œè¿™è¢«ç§°ä¸ºå¤åˆç´¢å¼•ï¼Œä»¥åŒºåˆ«äºä»…è¦†ç›–å•ä¸ªåˆ—çš„ç®€å•ç´¢å¼•ã€‚é‚£ä¹ˆï¼Œå¤åˆç´¢å¼•æ˜¯ä»€ä¹ˆæ ·çš„å‘¢ï¼Ÿè¿™é‡Œï¼Œæˆ‘å±•ç¤ºäº†ä¸¤ä¸ªç´¢å¼•ç¤ºä¾‹ï¼šä¸€ä¸ªå»ºç«‹åœ¨å¹´é¾„å’Œè–ªæ°´çš„ç»„åˆä¸Šï¼Œå¦ä¸€ä¸ªå»ºç«‹åœ¨è–ªæ°´å’Œå¹´é¾„çš„ç»„åˆä¸Šã€‚ä½ å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬æœ‰ä¸€ç»„æœç´¢é”®çš„ç»„åˆã€‚è¿™å°±æ˜¯å¤åˆç´¢å¼•ã€‚åœ¨å±å¹•çš„å³ä¾§ï¼Œæˆ‘å±•ç¤ºäº†ä¸€ä¸ªæ•°æ®é¡µé¢çš„ç¤ºä¾‹ã€‚ä¸ºäº†ç®€åŒ–ï¼Œå‡è®¾æˆ‘ä»¬åªæœ‰ä¸€ä¸ªåŒ…å«å››æ¡æŒ‰å§“åæ’åºçš„è®°å½•çš„æ•°æ®é¡µã€‚è¿™ä»…ä»…æ˜¯ä¸ºäº†è¯´æ˜ç›®çš„ã€‚
An index can also be built over a composite search key, which is then called a composite index, as opposed to a simple index that covers a single column. So, what does a composite index look like? Here, I'm showing two examples of indexes: one built on the combination of age and salary, and the other on the combination of salary and age. As you can see, we have a combination of search keys. That's a composite index. On the right-hand side of the screen, I'm showing an example of just one data page. For simplicity, imagine we have only one data page with four records sorted by name. This is just for illustrative purposes.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421163811064.png" alt="image-20240421163811064" style="zoom:50%;" /> 

**1ï¸âƒ£**An index can be built over a combination of search keys

**2ï¸âƒ£**Data entries in index sorted by search keys

**3ï¸âƒ£**- Examples:

1. Index on <age, sal>
2. Index on <sal, age>
3. Efficient to answer:
   age $=12$ and sal $=10$
   age $=12$ and sal $>15$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421164052741.png" alt="image-20240421164052741" style="zoom:50%;" /> 

```
æˆ‘æ­£åœ¨æ„å»ºä¸¤ä¸ªç´¢å¼•ã€‚ä¸€ä¸ªä¸»è¦æŒ‰å¹´é¾„æ’åºï¼Œè–ªæ°´ä½œä¸ºæ¬¡è¦æ ‡å‡†ï¼›å¦ä¸€ä¸ªåˆ™ä¸»è¦æŒ‰è–ªæ°´æ’åºï¼Œç„¶åæŒ‰å¹´é¾„æ’åºã€‚è¿™äº›ç´¢å¼•ä»¥å‚ç›´æ–¹å¼å±•ç¤ºï¼Œæ—‹è½¬äº†90åº¦ï¼Œè¿™æ˜¯æ•™ç§‘ä¹¦ä¸­å¸¸è§çš„è¡¨ç¤ºæ–¹æ³•ã€‚è¿™ä¸åº”è¯¥å¼•èµ·æ··æ·†ï¼›å®ƒåªæ˜¯ä¸€ç§ä¸åŒçš„å¯è§†åŒ–æ–¹å¼ã€‚ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œæˆ‘ä»¬éå†æ ‘ç»“æ„ï¼Œç›´åˆ°é‡åˆ°å®Œå…¨æ’åºçš„æ•°æ®æ¡ç›®ã€‚ç„¶åï¼Œæˆ‘ä»¬åˆ©ç”¨æŒ‡é’ˆä»ä¸€ä¸ªæ•°æ®æ¡ç›®å¯¼èˆªåˆ°å¦ä¸€ä¸ªï¼Œå®šä½æ‰€éœ€çš„ä¿¡æ¯ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œè¿™äº›ç´¢å¼•æ˜¯ä»¥äºŒå‰B+æ ‘çš„å½¢å¼å®ç°çš„ã€‚
I am constructing two indices. One sorts the values primarily based on age, with salary as the secondary criterion, while the other sorts primarily by salary and then by age. These indices are represented vertically, rotated by 90 degrees, a common presentation found in textbooks. This shouldn't cause confusion; it's simply a different visualization. Starting from the root, we traverse the tree structure until we encounter fully sorted data entries. We then utilize pointers to navigate from one data entry to another, locating the desired information. Imagine that these indices are implemented as binary B+ trees.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421163811064.png" alt="image-20240421163811064" style="zoom:50%;" /> 

**1ï¸âƒ£**An index can be built over a combination of search keys

**2ï¸âƒ£**Data entries in index sorted by search keys

**3ï¸âƒ£**- Examples:

1. Index on <age, sal>
2. Index on <sal, age>
3. Efficient to answer:
   age $=12$ and sal $=10$
   age $=12$ and sal $>15$
4. Efficient to answer:
   age $=12$ and sal $=10$
   age $=12$ and sal $>15$



<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421164052741.png" alt="image-20240421164052741" style="zoom:50%;" /> 

```
â€œæŒ‰å¹´é¾„å’Œè–ªæ°´æ’åºâ€æ„å‘³ç€ä»€ä¹ˆå‘¢ï¼Ÿå®ƒè¡¨ç¤ºæ•°æ®é¦–å…ˆæŒ‰å¹´é¾„æ’åºï¼Œç„¶ååœ¨æ¯ä¸ªå¹´é¾„ç»„å†…å†æŒ‰è–ªæ°´æ’åºã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘åˆ°å¹´é¾„ä¸º12å²çš„æƒ…å†µï¼Œæ•°æ®å°†é¦–å…ˆæŒ‰å¹´é¾„æ’åºï¼Œç„¶ååœ¨è¿™ä¸ªå¹´é¾„ç»„å†…ï¼Œè–ªæ°´å°†è¢«æ’åºï¼Œæ¯”å¦‚è¯´10åœ¨20ä¹‹å‰ã€‚å¯¹äºå¦ä¸€ä¸ªç´¢å¼•æ¥è¯´ï¼Œä¸»è¦æ’åºæ˜¯æŒ‰è–ªæ°´è¿›è¡Œçš„ã€‚è¯·æ³¨æ„ï¼Œå¦‚æœå­˜åœ¨é‡å¤é¡¹ï¼ˆåœ¨æœ¬åœºæ™¯ä¸­ä¸å­˜åœ¨ï¼‰ï¼Œå®ƒä»¬ä¹Ÿå°†æŒ‰å¹´é¾„æ’åºã€‚è¿™ä¸¤ç§ç±»å‹çš„ç´¢å¼•ä¾¿äºé«˜æ•ˆæœç´¢ï¼Œä¾‹å¦‚æŸ¥æ‰¾æ‰€æœ‰12å²çš„äººæˆ–å…·æœ‰ç‰¹å®šè–ªæ°´æˆ–å¹´é¾„å’Œè–ªæ°´ç»„åˆæ ‡å‡†çš„äººã€‚æœç´¢è¿‡ç¨‹æ¶‰åŠè·Ÿéšæ ‘ç»“æ„å®šä½æ‰€éœ€çš„å€¼ï¼Œå¦‚12ï¼Œç„¶ååˆ©ç”¨æŒ‡é’ˆæ£€ç´¢ç›¸å…³æ•°æ®ã€‚ä¸€æ—¦æ‰¾åˆ°æ‰€éœ€çš„å¹´é¾„ï¼Œæˆ‘ä»¬å°±å¯ä»¥åœæ­¢æœç´¢ï¼Œå› ä¸ºæ•°æ®å·²å®Œå…¨æŒ‰å¹´é¾„æ’åºï¼Œæ­¤ç‚¹ä¹‹åçš„ä»»ä½•å†…å®¹éƒ½å°†å¤§äºæŒ‡å®šçš„å¹´é¾„ã€‚
What does "sorted on age and salary" imply? It means the data is primarily sorted by age, and within each age group, it is further sorted by salary. For instance, considering an age of 12, the data would first be sorted by age, and then within that age group, salaries would be sorted, say 10 comes before 20. In the case of the other index, the primary sorting is done by salary. Note that if duplicates existed, which they don't in this scenario, they would be sorted by age as well. These two types of indices facilitate efficient searches, such as finding all 12-year-olds or those with a specific salary or a combination of age and salary criteria. The search process involves following the tree structure to locate the desired value, such as 12, and then utilizing pointers to retrieve the associated data. Once the desired age is found, we can stop searching because the data is fully sorted by age, and anything beyond that point would be greater than the specified age.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421163811064.png" alt="image-20240421163811064" style="zoom:50%;" /> 

**1ï¸âƒ£**An index can be built over a combination of search keys

**2ï¸âƒ£**Data entries in index sorted by search keys

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421164221294.png" alt="image-20240421164221294" style="zoom:50%;" /> 

```
å½“æˆ‘ä»¬ä»…æœç´¢é«˜äºç‰¹å®šé˜ˆå€¼ï¼ˆå¦‚70ï¼‰çš„è–ªæ°´æ—¶ï¼Œæ— æ³•é«˜æ•ˆåœ°ä½¿ç”¨ç¬¬ä¸€ä¸ªç´¢å¼•æ¥åŠ é€Ÿåˆ†æã€‚å°½ç®¡æŠ€æœ¯ä¸Šå¯ä»¥ä½¿ç”¨è¿™ä¸ªç´¢å¼•ï¼Œä½†å®ƒä¸ä¼šæé«˜æœç´¢é€Ÿåº¦ã€‚èƒŒåçš„åŸå› æ˜¯æ•°æ®ä¸»è¦æŒ‰å¹´é¾„æ’åºï¼Œæ²¡æœ‰ç›´æ¥æ˜¾ç¤ºè–ªæ°´çš„é¡ºåºã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°†è¢«è¿«æ£€æŸ¥æ¯ä¸ªæ¡ç›®å¹¶éµå¾ªç›¸å…³çš„æŒ‡é’ˆï¼Œè¿™å®è´¨ä¸Šç›¸å½“äºè®¿é—®å…¨éƒ¨æ•°æ®ã€‚å› æ­¤ï¼Œå‡ºäºæˆ‘ä»¬çš„ç›®çš„ï¼Œä½¿ç”¨æ­¤ç‰¹å®šç´¢å¼•æ²¡æœ‰ä»»ä½•ä¼˜åŠ¿ã€‚ç›¸åï¼Œå¯¹äºè–ªæ°´è¶…è¿‡70çš„æƒ…å†µï¼Œç¬¬äºŒä¸ªç´¢å¼•ï¼ˆä¸»è¦æŒ‰è–ªæ°´æ’åºï¼Œå…¶æ¬¡æŒ‰å¹´é¾„æ’åºï¼‰å°†æ˜¯æœ‰ç›Šçš„ï¼Œå› ä¸ºå®ƒå…è®¸è¿›è¡Œæ›´ç›´æ¥å’Œé«˜æ•ˆçš„æœç´¢ã€‚
We cannot efficiently use the first index to accelerate analysis when searching solely for salaries above a certain threshold, such as 70. While technically possible to employ this index, it wouldn't enhance the search speed. The reason behind this is that the data is primarily sorted by age, providing no direct indication of the salary order. Therefore, we would be compelled to examine each entry and follow the associated pointers, essentially amounting to accessing the entirety of the data. Hence, there's no advantage in using this particular index for our purpose. Conversely, for salaries exceeding 70, the second indexâ€”sorted primarily by salary and secondly by ageâ€”would be beneficial, as it allows for a more direct and efficient search.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421164304681.png" alt="image-20240421164304681" style="zoom:50%;" /> 

**1ï¸âƒ£**Hash-based index:

1. Represents index as a collection of buckets. Hash function maps the search key to the corresponding bucket.
   - $\mathbf{h}(r$.search_key $)=$ bucket in which record $r$ belongs

2. Good for equality selections

**2ï¸âƒ£**Example: Hash-based index on (sal)

 <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421164445500.png" alt="image-20240421164445500" style="zoom: 80%;" />

```
æœ€åçš„åˆ†ç±»ä¾èµ–äºç”¨äºåˆ›å»ºç´¢å¼•çš„æ•°æ®ç»“æ„ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘å±•ç¤ºäº†ä¸€ä¸ªåŸºäºå“ˆå¸Œçš„ç´¢å¼•çš„ä¾‹å­ã€‚ç´¢å¼•å¯ä»¥æ˜¯æ ‘çŠ¶çš„ï¼Œä¹Ÿå¯ä»¥æ˜¯å“ˆå¸Œçš„ï¼›åè€…åŸºäºå“ˆå¸Œè¡¨ã€‚å¯¹äºä¸ç†Ÿæ‚‰çš„äººæ¥è¯´ï¼Œå“ˆå¸Œè¡¨æœ¬è´¨ä¸Šæ˜¯ä¸€ç³»åˆ—æ¡¶ï¼Œå…¶ä¸­å“ˆå¸Œå‡½æ•°å°†æœç´¢é”®å€¼æ˜ å°„åˆ°å®ƒä»¬å„è‡ªçš„æ¡¶ä¸­ã€‚è¿™ä¸ªå“ˆå¸Œå‡½æ•°å¯ä»¥æ˜¯ä»»ä½•æ¥å—ä¸€ä¸ªè¾“å…¥å€¼å¹¶äº§ç”Ÿå¦ä¸€ä¸ªå€¼çš„å‡½æ•°ã€‚åœ¨æ•°æ®åº“ä¸­ï¼Œæ¨¡è¿ç®—æ˜¯ä¸€ç§å¸¸è§ä¸”å…¸å‹çš„å“ˆå¸Œå‡½æ•°ã€‚
The final classification relies on the data structure used to create an index. Here, I present an example of a hash-based index. Indices can be tree-based or hash-based; the latter is founded on hash tables. For those unfamiliar, hash tables are essentially collections of buckets where a hash function maps search key values to their respective buckets. This hash function can be any function that takes an input value and produces another. In databases, the modulo operation is a common and typical hash function.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421164304681.png" alt="image-20240421164304681" style="zoom:50%;" /> 

**1ï¸âƒ£**Hash-based index:

1. Represents index as a collection of buckets. Hash function maps the search key to the corresponding bucket.
   - $\mathbf{h}(r$.search_key $)=$ bucket in which record $r$ belongs

2. Good for equality selections

**2ï¸âƒ£**Example: Hash-based index on (sal)

 <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421164445500.png" alt="image-20240421164445500" style="zoom: 80%;" />



```
è®©æˆ‘ä»¬æ·±å…¥äº†è§£å“ˆå¸Œçš„å·¥ä½œåŸç†ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œæˆ‘ä»¬æœ‰å¾ˆå¤šæ¡¶ï¼Œæ¯ä¸ªæ¡¶å†…éƒ½æœ‰ä¸€ç»„è®°å½•ã€‚è¿™äº›è®°å½•æ²¡æœ‰ç‰¹å®šçš„é¡ºåºï¼›å®ƒä»¬åªæ˜¯å› ä¸ºå“ˆå¸Œå‡½æ•°ä¸ºå®ƒä»¬è¾“å‡ºäº†ç›¸åŒçš„å€¼è€Œè¢«åˆ†ç»„åœ¨ä¸€èµ·ã€‚åœ¨å±å¹•çš„åº•éƒ¨ï¼Œæˆ‘å±•ç¤ºäº†ä¸€ä¸ªå“ˆå¸Œå‡½æ•°ï¼šæ¨¡å››ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬é™¤ä»¥å››å¹¶å­˜å‚¨ä½™æ•°ã€‚å› æ­¤ï¼Œå½“é™¤ä»¥å››æ—¶ä½™æ•°ä¸ºé›¶çš„å€¼ä¼šè¢«æ”¾åœ¨é›¶å·æ¡¶ä¸­ã€‚åœ¨äºŒè¿›åˆ¶ä¸­ï¼Œè¿™å¯èƒ½çœ‹èµ·æ¥åƒ3000æˆ–5004ã€‚æ‰€æœ‰é™¤ä»¥å››åä½™æ•°ä¸ºé›¶çš„å€¼éƒ½ä¼šæ”¾åœ¨è¿™é‡Œã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œå¦‚æœæˆ‘æœ‰å››ä¸ªæ¡¶ï¼Œåœ¨æœ€åä¸€ä¸ªæ¡¶ä¸­ï¼Œä½™æ•°æ˜¯ä¸‰ã€‚
Let's delve into how hashing works. Imagine we have numerous buckets, and within each bucket, there's a group of records. These records have no particular order; they're simply grouped because the hash function outputted the same value for them. At the bottom of the screen, I'm showing a hash function: modulo four. This means we divide by four and store the remainder. So, bucket zero holds values with a remainder of zero when divided by four. In binary, this might look like 3000 or 5004. Everything that, when divided by four, leaves a remainder of zero ends up here. Imagine if I had four buckets and in the last one, the remainder was three.
```


$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421164304681.png" alt="image-20240421164304681" style="zoom:50%;" /> 

**1ï¸âƒ£**Hash-based index:

1. Represents index as a collection of buckets. Hash function maps the search key to the corresponding bucket.
   - $\mathbf{h}(r$.search_key $)=$ bucket in which record $r$ belongs

2. Good for equality selections

**2ï¸âƒ£**Example: Hash-based index on (sal)

 <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421164445500.png" alt="image-20240421164445500" style="zoom: 80%;" />


```
åœ¨è¿™é‡Œï¼Œæˆ‘ä¸¾ä¾‹è¯´æ˜äº†ä¸€ä¸ªåŸºäºå“ˆå¸Œçš„ç´¢å¼•ï¼Œå®ƒæ˜¯å»ºç«‹åœ¨ä¸€ä¸ªæ•°æ®æ–‡ä»¶ä¸Šçš„ã€‚åœ¨å·¦ä¾§ï¼Œæˆ‘ä»¬æœ‰ä¸‰ä¸ªé¡µé¢ï¼Œæ¯ä¸ªé¡µé¢æœ‰ä¸‰æ¡è®°å½•ï¼Œæ˜¾ç¤ºå§“æ°ã€å¹´é¾„å’Œè–ªæ°´ã€‚ä¸ºäº†ç®€æ´èµ·è§ï¼Œæˆ‘åªå±•ç¤ºäº†ä¸¤ä¸ªæ¡¶ï¼Œä½†ä½ å¯ä»¥æ¨æ–­å‡ºå…¶ä»–ä¸¤ä¸ªæ¡¶ä¸­çš„å†…å®¹ã€‚ä¸€å·æ¡¶åŒ…å«åƒ6000ã€5004å’Œ5004è¿™æ ·çš„å€¼ã€‚è¿™æ˜¯æˆ‘çš„ç´¢å¼•æ–‡ä»¶ã€‚æœç´¢è¿‡ç¨‹ç±»ä¼¼ï¼šä¸€æ—¦æˆ‘åœ¨ç´¢å¼•ä¸­æ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„æ•°æ®æ¡ç›®ï¼Œæˆ‘å°±ä¼šè·ŸéšæŒ‡é’ˆã€‚è¿™æ— è®ºæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯æ ‘çŠ¶ç´¢å¼•è¿˜æ˜¯å“ˆå¸Œç´¢å¼•éƒ½é€‚ç”¨ã€‚å…³é”®çš„åŒºåˆ«åœ¨äºï¼Œæˆ‘çš„æ•°æ®åœ¨ç´¢å¼•æ–‡ä»¶ä¸­å¹¶ä¸æ˜¯å®Œå…¨æ’åºçš„ï¼›ç›¸åï¼Œå®ƒæ˜¯æ ¹æ®å“ˆå¸Œå‡½æ•°è¿›è¡Œåˆ†ç»„çš„ã€‚
Here, I'm illustrating an example of a hash-based index built over a data file. On the left, we have three pages, each with three records showing surname, age, and salary. For brevity, I'm only displaying two buckets, but you can extrapolate what's in the other two. Bucket one contains values like 6000, 5004, and 5004. This is my index file. The search process is similar: once I find the qualifying data entry in the index, I follow the pointer. This applies regardless of whether we have a tree-based or hash-based index. The key difference is that my data isn't fully sorted in the index file; instead, it's grouped based on the hash function.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421164304681.png" alt="image-20240421164304681" style="zoom:50%;" /> 

**1ï¸âƒ£**Hash-based index:

1. Represents index as a collection of buckets. Hash function maps the search key to the corresponding bucket.
   - $\mathbf{h}(r$.search_key $)=$ bucket in which record $r$ belongs

2. Good for equality selections

**2ï¸âƒ£**Example: Hash-based index on (sal)

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421164445500.png" alt="image-20240421164445500" style="zoom: 80%;" /> 

``` 
Find Sal = 2007
2007 mod 4 = 3 go to Buck.4
```

```
å“ˆå¸Œç´¢å¼•åœ¨ç²¾ç¡®æ•°æ®æ£€ç´¢æ–¹é¢éå¸¸æœ‰æ•ˆã€‚è®©æˆ‘æ¥è§£é‡Šä¸€ä¸‹åŸºäºå“ˆå¸Œçš„ç´¢å¼•æœç´¢æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚ä¾‹å¦‚ï¼Œå½“æœç´¢2007å¹´çš„ç‰¹å®šå·¥èµ„æ—¶ï¼Œåˆå§‹æ­¥éª¤åŒ…æ‹¬åº”ç”¨å“ˆå¸Œå‡½æ•°ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä½¿ç”¨æ¨¡æ•°ä¸ºå››çš„å“ˆå¸Œå‡½æ•°ï¼Œå®ƒäº§ç”Ÿçš„ä½™æ•°ä¸ºä¸‰ï¼ŒæŒ‡å‘ç¬¬å››å·æ¡¶ã€‚æˆ‘è¿›å…¥è¯¥æ¡¶å¹¶å¼€å§‹æœç´¢ã€‚æˆ‘æ‰«æå…¶ä¸­çš„å€¼ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰ä¸2007å¹´å¯¹åº”çš„é¡¹ã€‚åœ¨é‡åˆ°ç¬¬äºŒä¸ªæ¡ç›®â€œ1, 2007â€æ—¶ï¼Œæˆ‘è·Ÿéšç›¸å…³çš„æŒ‡é’ˆå¹¶æ£€ç´¢ç›¸å…³æ•°æ®ï¼Œå³6003ã€‚ä¸€æ—¦æˆ‘ç©·å°½äº†è¯¥æ¡¶å†…çš„æ‰€æœ‰å¯èƒ½æ€§ï¼Œæˆ‘å°±å¯ä»¥ç¡®ä¿¡æ²¡æœ‰å…¶ä»–æ¡¶åŒ…å«2007å¹´çš„å·¥èµ„æ•°æ®ã€‚å³ä½¿å­˜åœ¨è®¸å¤šå…¶ä»–æ¡¶ï¼Œä¹Ÿè®¸å¤šè¾¾ä¸€åƒä¸ªï¼Œè¿™ç§ç¡®å®šæ€§ä¹Ÿæ˜¯æˆç«‹çš„ã€‚å“ˆå¸Œè¿‡ç¨‹ç¡®ä¿æ‰€æœ‰ä¸2007å¹´å·¥èµ„ç›¸å…³çš„å€¼éƒ½ä»…ä½äºæ­¤æ¡¶å†…ï¼Œä»è€Œæ˜¾è‘—æé«˜äº†æœç´¢æ•ˆç‡ã€‚
Hash indices are highly effective for precise data retrieval. Let me explain how a hash-based index search works. When searching for a specific salary from 2007, for instance, the initial step involves applying a hash function. In this case, I use a modulus of four, which yields a remainder of three, indicating bucket number four. I proceed to that bucket and commence my search. I scan the values within, checking if any correspond to 2007. Upon encountering the second entry, â€œ1, 2007,â€ I follow the associated pointer and retrieve the relevant data, which is 6003. Once Iâ€™ve exhausted the possibilities within this bucket, I can confidently conclude that no other bucket contains the salary data for 2007. This certainty holds true even if there are numerous other buckets, perhaps as many as a thousand. The hashing process ensures that all values related to the salary for 2007 are located exclusively within this bucket, significantly enhancing search efficiency.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421164304681.png" alt="image-20240421164304681" style="zoom:50%;" /> 

**1ï¸âƒ£**Hash-based index:

1. Represents index as a collection of buckets. Hash function maps the search key to the corresponding bucket.
   - $\mathbf{h}(r$.search_key $)=$ bucket in which record $r$ belongs

2. Good for equality selections

**2ï¸âƒ£**Example: Hash-based index on (sal)

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421164445500.png" alt="image-20240421164445500" style="zoom: 80%;" /> 

``` 
Find Sal = 2007
2007 mod 4 = 3 go to Buck.4
```

```
ç„¶è€Œï¼Œå½“æœç´¢ä¸€ç³»åˆ—å€¼æ—¶ï¼Œå“ˆå¸Œç´¢å¼•çš„æ•ˆç”¨ä¼šé™ä½ã€‚è€ƒè™‘ä¸€ä¸ªæœç´¢æ¡ä»¶æ¶‰åŠ1,000,000åˆ°2,000,000ä¹‹é—´å·¥èµ„çš„åœºæ™¯ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå“ˆå¸Œç´¢å¼•å°±ä¸é‚£ä¹ˆæœ‰ç”¨äº†ï¼Œå› ä¸ºæ•°æ®æ˜¯æŒ‰ç»„åˆ†ç±»çš„ï¼Œè€Œä¸æ˜¯æ’åºçš„ã€‚å› æ­¤ï¼Œåƒ3000è¿™æ ·çš„å€¼å¯èƒ½ä¼šå‡ºç°åœ¨ç¬¬ä¸€æ¡¶ä¸­ï¼Œè€Œ3001å¯èƒ½ä¼šå‡ºç°åœ¨ç¬¬äºŒæ¡¶ä¸­ï¼Œä¾æ­¤ç±»æ¨ã€‚è¿™ç§æ¨¡å¼åœ¨æ‰€æœ‰æ¡¶ä¸­éƒ½æ˜¯ä¸€è‡´çš„ï¼Œè¿™æ„å‘³ç€ä¸ºäº†æ‰¾åˆ°æ‰€éœ€çš„å·¥èµ„èŒƒå›´ï¼Œæˆ‘å¯èƒ½éœ€è¦è®¿é—®æ¯ä¸ªæ¡¶ã€‚è™½ç„¶ä»æŠ€æœ¯ä¸Šè®²æ˜¯å¯è¡Œçš„ï¼Œä½†ä¸ç®€å•è®¿é—®å®Œå…¨æ’åºçš„æ•°æ®æ–‡ä»¶ç›¸æ¯”ï¼Œè¿™ç§æ–¹æ³•çš„æ•ˆç‡è¦ä½å¾—å¤šã€‚å› æ­¤ï¼Œè™½ç„¶å“ˆå¸Œç´¢å¼•åœ¨ç²¾ç¡®æ•°æ®æ£€ç´¢æ–¹é¢è¡¨ç°å‡ºè‰²ï¼Œä½†å®ƒä»¬å¯èƒ½ä¸æ˜¯åŸºäºèŒƒå›´çš„æœç´¢çš„æœ€ä½³é€‰æ‹©ã€‚
However, the utility of hash indices diminishes when searching for a range of values. Consider a scenario where the search criteria involve salaries between 1,000,000 and 2,000,000. In this instance, the hash index is less helpful because the data is grouped rather than sorted. Consequently, values such as 3000 may be found in bucket one, while 3001 could be in bucket two, and so on. This pattern continues across all buckets, meaning that to locate the desired salary range, I would potentially need to access every bucket. Although technically feasible, this approach is far less efficient compared to simply accessing a fully sorted data file. Therefore, while hash indices excel at precise data retrieval, they may not be the optimal choice for range-based searches.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421165634992.png" alt="image-20240421165634992" style="zoom:50%;" /> 

**1ï¸âƒ£**Tree-based index:

- Underlying data structure is a binary $\left(\mathrm{B}^{+}\right)$tree. Nodes contain pointers to lower levels (search left for lower, right for higher).
  Leaves contain data entries sorted by search key values.
- Good for range selections
- So far we have shown those

**2ï¸âƒ£**Example: Tree-based index on (age)

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421165728855.png" alt="image-20240421165728855" style="zoom: 33%;" /> 

``` 
ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ·±å…¥æ¢è®¨ä¸€ä¸‹åŸºäºæ ‘çš„ç´¢å¼•çš„å·¥ä½œæœºåˆ¶ã€‚æœ¬è´¨ä¸Šï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘æ‰€å±•ç¤ºçš„ç´¢å¼•æ˜¯ä»¥äºŒè¿›åˆ¶B+æ ‘æ•°æ®ç»“æ„ä¸ºåŸºç¡€çš„ã€‚åœ¨è¿™ç§è®¾ç½®ä¸­ï¼Œæ ‘ä¸­çš„èŠ‚ç‚¹åŒ…å«æŒ‡å‘è¾ƒä½çº§åˆ«çš„æŒ‡é’ˆã€‚æœç´¢æ—¶ï¼Œäººä»¬ä¼šå‘å·¦å¯»æ‰¾è¾ƒå°çš„å€¼ï¼Œå‘å³å¯»æ‰¾è¾ƒå¤§æˆ–ç›¸ç­‰çš„å€¼ã€‚è¿™ç§ç»“æ„å¯¹äºèŒƒå›´é€‰æ‹©æˆ–ç­‰å€¼æ¡ä»¶æŸ¥è¯¢ç‰¹åˆ«æœ‰åˆ©ã€‚ä¸ºäº†è¿›ä¸€æ­¥è¯´æ˜è¿™ä¸€ç‚¹ï¼Œæˆ‘åœ¨å±å¹•åº•éƒ¨åŠ å…¥äº†ä¸€æ®µä¹¦ä¸­çš„æ‘˜å½•ã€‚æˆ‘çš„ç›®çš„æ˜¯æ­å¼€è¿™ä¸ªæ¦‚å¿µçš„ç¥ç§˜é¢çº±ï¼Œå¹¶å‘ä½ ä»¬å±•ç¤ºä¸åŒçš„äººå¯èƒ½ä¼šå¦‚ä½•è¡¨ç¤ºä¸€æ£µæ ‘ã€‚ä½ å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªæ ¹ï¼Œå®ƒåœ¨ä¸åŒçš„è¡¨ç¤ºä¸­æ˜¯ä¸€è‡´çš„ã€‚æˆ‘ä»¬è¿˜æœ‰æŒ‡é’ˆã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªå€¼ä¸º12çš„èŠ‚ç‚¹ï¼ŒæŒ‡é’ˆæŒ‡å‘1ã€12ã€78ã€19å’Œ56ã€‚è¿™çœ‹èµ·æ¥å¯èƒ½æœ‰ç‚¹ä¸å¯»å¸¸ï¼Œä½†ä½ å¯ä»¥åœ¨ä¹¦ä¸­æ‰¾åˆ°è¿™ä¸ªç¡®åˆ‡çš„ä¾‹å­ã€‚
Now, let's delve into the mechanics of a tree-based index. Essentially, what I've been presenting thus far is an index whose foundation lies in the binary B+ tree data structure. In this setup, the nodes within the tree house pointers that lead to lower levels. When searching, one would go left for smaller values and right for larger or equal values. This structure is particularly advantageous for range selection or equal condition queries. To illustrate this further, I've included an excerpt from a book at the bottom of the screen. My aim is to demystify this concept and show you how different individuals might represent a tree. As you can see, we have a root, which is consistent across representations. We also have pointers. In this example, we have a value of 12, and the pointers lead to 1, 12, 78, 19, and 56. It may seem slightly unusual, but you can find this exact example in the book.
```


$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421165634992.png" alt="image-20240421165634992" style="zoom:50%;" /> 

**1ï¸âƒ£**Tree-based index:

- Underlying data structure is a binary $\left(\mathrm{B}^{+}\right)$tree. Nodes contain pointers to lower levels (search left for lower, right for higher).
  Leaves contain data entries sorted by search key values.
- Good for range selections
- So far we have shown those

**2ï¸âƒ£**Example: Tree-based index on (age) ==Find age>39==

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421165933628.png" alt="image-20240421165933628" style="zoom:50%;" /> 

```
è®©æˆ‘ä»¬è®¾æƒ³ä¸€ä¸ªåœºæ™¯ï¼Œæˆ‘ä»¬æ­£åœ¨æœç´¢æ‰€æœ‰å¹´é¾„è¶…è¿‡39å²çš„ä¸ªä½“ã€‚è¯·è®°ä½ï¼Œæˆ‘ä»¬çš„æ•°æ®æ–‡ä»¶åŒ…å«è¯¸å¦‚å§“æ°ã€å¹´é¾„å’Œè–ªæ°´ç­‰ä¿¡æ¯ï¼Œå®ƒæ˜¯ä¸€ä¸ªç‹¬ç«‹çš„å®ä½“ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä»¥ä¸‰ä¸ªæ•°æ®é¡µé¢å’Œç›¸åº”çš„ç´¢å¼•ç»“æ„ä¸ºä¾‹è¿›è¡Œè¯´æ˜ã€‚æˆ‘ä»¬çš„æœç´¢ä»ç´¢å¼•çš„æ ¹å¼€å§‹ã€‚æˆ‘ä»¬ç¡®å®š39ä½äº12åˆ°78çš„èŒƒå›´å†…ï¼Œè¿™å¼•å¯¼æˆ‘ä»¬è¿›å…¥ä¸‹ä¸€å±‚çº§ã€‚éšåï¼Œæˆ‘ä»¬ç¡®å®š39ä½äº19å’Œ56ä¹‹é—´ï¼Œè¿›ä¸€æ­¥å¼•å¯¼æˆ‘ä»¬æ·±å…¥æ ‘çŠ¶ç»“æ„ã€‚æœ€åï¼Œæˆ‘ä»¬å°†æœç´¢èŒƒå›´ç¼©å°åˆ°33åˆ°44ä¹‹é—´ã€‚æ­¤æ—¶ï¼Œæˆ‘ä»¬å¼€å§‹æ£€æŸ¥æ•°æ®ï¼Œä»33å¼€å§‹ï¼Œé€æ¸è¿›å±•åˆ°40ã€‚æ­£æ˜¯åœ¨è¿™ä¸ªå…³é”®æ—¶åˆ»ï¼Œæˆ‘ä»¬è¿…é€Ÿå‘ç°äº†æ„Ÿå…´è¶£çš„ç›¸å…³æ•°æ®ã€‚
Let's envision a scenario where we are searching for all individuals whose age exceeds 39. Recall that our data file, containing information such as surname, age, and salary, exists as a distinct entity. Here, we illustrate with an example of three data pages and a corresponding index structure. Our search commences at the root of the index. We ascertain that 39 falls within the range of 12 to 78, leading us to the next level. Subsequently, we determine that 39 lies between 19 and 56, guiding us further down the tree. Finally, we narrow our search to the range of 33 to 44. At this point, we commence our data inspection, commencing with 33 and progressing to 40. It is at this juncture that we swiftly discover the pertinent data of interest.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421170013313.png" alt="image-20240421170013313" style="zoom: 50%;" />  

**1ï¸âƒ£**Many alternative file organizations exist, each appropriate in some situation

**2ï¸âƒ£**If selection queries are frequent, sorting the file or building an index is important

**3ï¸âƒ£**Index is an additional data structure (i.e. file) introduced to quickly find entries with given key values

- Hash-based indexes only good for equality search
- Sorted files and tree-based indexes best for range search; also good for equality search
- Files rarely kept sorted in practice (because of the cost of maintaining them); $\mathrm{B}+$ tree index is better

```
åœ¨æœ¬æ¬¡è®²åº§ä¸­ï¼Œæˆ‘ä»¬æ¢è®¨äº†å¤šç§é€‚ç”¨äºç‰¹å®šæƒ…å¢ƒçš„1025ç»„ç»‡æ–¹å¼ã€‚å°½ç®¡æˆ‘ä»¬å°†æ¥ä¼šæ·±å…¥æ¢è®¨è¿™äº›ä¸»é¢˜ï¼Œä½†æˆ‘å½“å‰çš„ç›®æ ‡æ˜¯å¸®åŠ©ä½ ä»¬ç›´è§‚åœ°ç†è§£å®ƒä»¬çš„é«˜çº§æ“ä½œã€‚è¿™ä¸ªåŸºç¡€å°†ä¸ºä½ ä»¬æœªæ¥çš„å­¦ä¹ åšå¥½å‡†å¤‡ã€‚å¦‚æœä½ ä»¬åœ¨åŒºåˆ†å“ˆå¸Œç´¢å¼•å’Œæ ‘åŸºç´¢å¼•ç­‰æ–¹é¢é‡åˆ°å›°éš¾ï¼Œæˆ‘å¼ºçƒˆå»ºè®®ä½ ä»¬å‚è€ƒæˆ‘æä¾›çš„ç¤ºä¾‹ã€‚è¿™äº›å›¾ç¤ºå…è®¸ä½ ä»¬ä¸ä¸åŒçš„Bæ ‘å’Œå“ˆå¸ŒåŸºç´¢å¼•è¿›è¡Œäº¤äº’ï¼Œæ­ç¤ºå®ƒä»¬åº•å±‚çš„æ•°æ®ç»“æ„ã€‚å°½ç®¡å®ƒä»¬å¾ˆå¤æ‚ï¼Œä½†è¦è®°ä½ï¼Œæˆ‘ä»¬çš„é‡ç‚¹æ˜¯åˆ†æè¿™äº›æ›¿ä»£æ–¹æ¡ˆçš„æˆæœ¬æ•ˆç›Šã€‚å³ä½¿æœ‰äº›æ¦‚å¿µä»ç„¶éš¾ä»¥ç†è§£ï¼Œä½†æŒæ¡æˆæœ¬æ˜¯å¦‚ä½•ç¡®å®šçš„è‡³å…³é‡è¦ã€‚
In this lecture, we have explored a variety of manual 1025 organizations, each suitable for specific situations. While we will delve deeper into these topics in the future, my current objective was to cultivate an intuitive understanding of their high-level operations. This foundation will prepare you for what lies ahead. If you encounter difficulties distinguishing between, say, hash indexes and tree-based indexes, I urge you to refer to the examples I've provided. These illustrations allow you to interact with different B-tree and hash-based indexes, revealing their underlying data structures. Despite their complexity, remember that our focus is on analyzing the cost-effectiveness of these alternatives. Even if some concepts remain elusive, grasping how costs are determined is crucial.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421170013313.png" alt="image-20240421170013313" style="zoom: 50%;" />  

**1ï¸âƒ£**Many alternative file organizations exist, each appropriate in some situation

**2ï¸âƒ£**If selection queries are frequent, sorting the file or building an index is important

**3ï¸âƒ£**Index is an additional data structure (i.e. file) introduced to quickly find entries with given key values

- Hash-based indexes only good for equality search
- Sorted files and tree-based indexes best for range search; also good for equality search
- Files rarely kept sorted in practice (because of the cost of maintaining them); $\mathrm{B}+$ tree index is better

```
å¿…é¡»ç‰¢è®°çš„æ˜¯ï¼Œå“ˆå¸ŒåŸºç´¢å¼•æ“…é•¿ç²¾ç¡®æœç´¢ï¼Œä½†ç”±äºæ•°æ®æœªæ’åºï¼Œå› æ­¤ä¸é€‚ç”¨äºèŒƒå›´æŸ¥è¯¢ã€‚ç›¸åï¼Œå·²æ’åºçš„æ–‡ä»¶æˆ–åŸºäºæ ‘çš„ç»“æ„æ—¢ä¾¿äºèŒƒå›´æœç´¢ï¼Œä¹Ÿé€‚ç”¨äºç²¾ç¡®æŸ¥æ‰¾ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œåœ¨å®è·µä¸­ï¼Œç”±äºç›¸å…³æˆæœ¬è¾ƒé«˜ï¼Œæ•°æ®æ–‡ä»¶å¾ˆå°‘ä¿æŒå®Œå…¨æ’åºã€‚åœ¨çœŸå®ä¸–ç•Œçš„æ•°æ®åº“ä¸­ï¼Œé€šå¸¸ä½¿ç”¨éèšé›†ç´¢å¼•æ¥åŠ é€Ÿæœç´¢ã€‚éèšé›†ç´¢å¼•çš„ä¼˜ç‚¹åœ¨äºæ— éœ€æ›´æ–°åº•å±‚æ•°æ®ã€‚ç›¸åï¼Œæ–°æ¡ç›®å¯ä»¥æ”¾ç½®åœ¨ä¸‹ä¸€ä¸ªå¯ç”¨ä½ç½®ï¼Œè¿™æä¾›äº†ä¾¿åˆ©å’Œæ•ˆç‡ã€‚
It's essential to remember that hash-based indices excel at precise searches but are unsuitable for range queries as the data lacks sorting. Conversely, sorted files or tree-based structures facilitate range searches while also accommodating precise lookups. It's worth noting that in practice, data files are rarely kept fully sorted due to the associated costs. In real-world databases, unclustered indexes are commonly employed to expedite searches. The advantage of unclustered indexes is that they obviate the need to update the underlying data. Instead, new entries can be placed in the next available location, offering convenience and efficiency.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240324233238220.png" alt="image-20240324233238220" style="zoom:50%;" /> 

```
æœ¬æ¬¡è®²åº§çš„çœŸæ­£é‡ç‚¹åœ¨äºç†è§£è¿™äº›ä¸åŒçš„æ›¿ä»£æ–¹æ¡ˆã€‚éšç€å­¦ä¹ çš„æ·±å…¥ï¼Œæˆ‘ä»¬å°†ç»ƒä¹ å¦‚ä½•è¿ç”¨è¿™äº›ç´¢å¼•ï¼Œå¹¶åˆ¤æ–­åœ¨ç‰¹å®šæƒ…å†µä¸‹å“ªç§ç´¢å¼•æœ€ä¸ºé€‚ç”¨ã€‚è¿™ç§å…¨é¢çš„æ–¹æ³•å°†å¼•å¯¼æˆ‘ä»¬åœ¨æ¥ä¸‹æ¥çš„è¯¾ç¨‹ä¸­é€æ­¥æ·±å…¥æ¢è®¨è¿™ä¸€ä¸»é¢˜ã€‚æ„Ÿè°¢æ‚¨çš„è†å¬ï¼ŒæœŸå¾…ä¸‹æ¬¡ä¸æ‚¨å†ä¼šã€‚
What is truly essential from this lecture is understanding these various alternatives. As we progress, we will practice applying these indexes and determine which index is best suited for specific cases. This comprehensive approach will guide us as we gradually delve deeper into the topic over the upcoming lectures. Thank you for your attention, and I look forward to seeing you next time.
```

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{åˆ†å‰²çº¿}\Huge{-------}}
$$
