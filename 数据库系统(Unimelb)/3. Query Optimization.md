# $\text{Query Optimization}$ 

# $\text{1. Storage}$​ 

> ## $\text{1.1. File Hierarchy}$  
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1043190004.png" alt="1043190004" style="zoom: 30%;" /> 
> >
> > |         术语          |                             描述                             |
> > | :-------------------: | :----------------------------------------------------------: |
> > | $\text{Record/Tuple}$ |                         表格中的一行                         |
> > |     $\text{Page}$     | $\text{Fixed-size}$的数据块($\text{MySQL}$中为$\text{16KB}$) |
> > |     $\text{File}$     |                  包含若干多的$\text{Page}$                   |
>
> ## $\text{1.2. File Orgnisation}$​
>
> > |       文件类型       |        存放         |      记录的排列方式      |             适用情况             |
> > | :------------------: | :-----------------: | :----------------------: | :------------------------------: |
> > |  $\text{Heap file}$  | $\text{Data File}$  |     记录间无特定顺序     | 检索所有记录($\text{Heap Scan}$) |
> > | $\text{Sorted file}$ | $\text{Data File}$  |   页和记录按某条件排序   |        按特定顺序检索记录        |
> > | $\text{Index file}$  | $\text{Index File}$ | 存放目录，某顺序检索最快 |      快速检索特定顺序的记录      |
> >
> > **1️⃣**$\text{Heap File}$ 
> >
> > 1. $\text{Data File}$结构：$\text{Tuple}$按顺序填满一个个$\text{Page}$ 
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/18238755500.png" alt="18238755500" style="zoom: 39%;" /> 
> >
> > 2. 特点：能快速插入记录+扫描所有页 / 查找慢
> >
> > **2️⃣**$\text{Sorted File}$
> >
> > 1. $\text{Data File}$结构：$\text{Pages and records are sorted}$, 上图是根据年龄-薪水复合排序
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1218859907.png" alt="1218859907" style="zoom: 33%;" /> 
> >
> > 2. 特性：查找快(二分查找) / 插入慢(为了保证顺序)
> >
> > **3️⃣**$\text{Index File}$ 
> >
> > 1. $\text{Data File}$之上建立用于快速搜索的$\text{Index File}$数据结构
> > 2. 特点：$\text{Index}$可以允许快速查找
> > 3. 相比$\text{Sorted File}$优势在于，$\text{Index}$可以在不改变$\text{Data File}$的情况下，建立多种排序方式
>
> ## $\text{1.3. Cost}$评估标准
>
> > **1️⃣**$\text{DBMS}$评估$\text{Transactions/Buffer Pool}$等操作需要开销，但最主要的开销是$\text{IO}$操作
> >
> > **2️⃣**开销衡量(忽略$\text{IO}$开销以外的开销)：
> >
> > 1. $\text{DBMS}$的数据存储方式$\begin{cases}存储在\text{Non-Volatile(非活性)介质}\to{\text{RAM}}\\\\执行时移动到\text{Volatile(活性)介质}\to{\text{Hard Disk / SSD}}\end{cases}$​
> > 2. 衡量：从硬盘到主存转移数据时所涉及的$\text{IO}$​​​操作的页数
>
> ## $\text{1.4. Index and Index File}$详解
>
> > ### $\text{1.4.1. Index}$的$\text{Search Key}$
> >
> > > **1️⃣**$\text{Search Key Field}$(搜索关键字字段): 用于建立索引的特定字段($\text{Fields}$​)，比如按年龄排序
> > >
> > > **2️⃣**==$\text{Composite Search Key}$==处理方法
> > >
> > > 1. 以比如`<Age, Sal, Name>`先按`Age`排序再按`Sal`排序最后按`Name`排序
> > > 2. 重点关注$\text{Index}$​的顺序
> >
> > ### $\text{1.4.2. Indexing Implementation: Hash/B}^{+}\text{Tree Index}$ 
> >
> > > **==决定$\text{Index File}$​的顺序==**
> > >
> > > **1️⃣**$\text{B}^{+}\text{Tree Index}$: 对$\text{Range Search}$和$\text{Equality Search}$效果都很好
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421165933628.png" alt="image-20240421165933628" style="zoom:49%;" />  
> > >
> > > | $\text{Index File}$结构结构 |                          特点                           |
> > > | :-------------------------: | :-----------------------------------------------------: |
> > > | $\text{Leaf Node}$(最底层)  | 包含所有可能的值$\text{Data Entries}$(这点不同于二叉树) |
> > > |          中间节点           |   相当于$\text{Guiding}$的作用，包含指向下一层的指针    |
> > >
> > > **2️⃣**$\text{Hash Index}$
> > >
> > > 1. 哈希是什么：$\text{Key(Record)}\xrightarrow{\text{Hash函数}}\text{Hash值}\xrightarrow{\text{一个Hash值对应一个Buckedt}}放入对应桶$
> > >
> > > | $\text{Record}$ | $\text{Key}$ | $\text{Hash}$ |  $\text{Bucket}$   |
> > > | :-------------: | :----------: | :-----------: | :----------------: |
> > > | $\text{Alice}$  |  $\text{A}$  |  $\text{1}$   | $\text{1}$对应的桶 |
> > > |  $\text{Bob}$   |  $\text{B}$  |  $\text{2}$   | $\text{2}$对应的桶 |
> > > | $\text{David}$  |  $\text{D}$  |  $\text{4}$   | $\text{4}$对应的桶 |
> > >
> > > 2. $\text{Hash Index}$​原理：哈希函数$\text{H=Sal(Mod4)}$​
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image.png" alt="image" style="zoom:50%;" /> 
> > >
> > >    - 先确定要查找的数在哪个$\text{Bucket}$中
> > >    - 再到相应$\text{Bucket}$​中寻找
> > >
> > > 3. 特点：
> > >
> > >    - $\text{Index File}$按照$\text{Bucket}$排列因此无序$\xrightarrow{\text{}}$==极难作$\text{Range Search}$​==
> > >    - 但是作$\text{Equality Search}$是可以的，比如寻找$\text{Sal=3000}$​
> >
> > ### $\text{1.4.3. Index Storage: Cluster/Uncluster Index}$ 
> >
> > > **==决定$\text{Data File}$顺序(无序/与$\text{Index File}$​顺序一致)==**
> > >
> > > **1️⃣**$\text{Cluster/Uncluster Index}$​概述
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421162644005.png" alt="image-20240421162644005" style="zoom:55%;" />   
> > >
> > >
> > > |      $\text{Type}$       |     $\text{Data File}$     |
> > > | :----------------------: | :------------------------: |
> > > |  $\text{Cluster Index}$  | ==按照$\text{Index}$排序== |
> > > | $\text{Uncluster Index}$ | $\text{Heap File}$(未排序) |
> > >
> > > - ==这就是为什么一个表格的$\text{Cluster Index}$唯一==
> > >
> > > **2️⃣**$\text{Cluster/Uncluster Index}$的$\text{Range Scan}$开销：例如要搜索成绩在$\text{10→50}$的学生 
> > >
> > > |   $\text{Type}$    |              开销               |                     示例                      |
> > > | :----------------: | :-----------------------------: | :-------------------------------------------: |
> > > |  $\text{Cluster}$  |     存放所需范围数据的页数      | 假设$\text{10→50}$存放在$3$页中$\to$开销是$3$ |
> > > | $\text{Uncluster}$ | 符合要求的$\text{Data Entry}$数 |                   $40(41)$                    |
> > >
> > > 1. $\text{Cluster Index}$开销原理
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240510140340276.png" alt="image-20240510140340276" style="zoom: 50%;" />  
> > >
> > > 2. $\text{Uncluster Index}$开销原理
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240510141358438.png" alt="image-20240510141358438" style="zoom:50%;" /> 
> >
> > ### $\text{1.4.3. Index Role: Primary/Secondary Index}$
> >
> > > |   $\text{Type}$    |    $\text{Search Key}$     | $\text{Duplicates}$ |             示例              |
> > > | :----------------: | :------------------------: | :-----------------: | :---------------------------: |
> > > |  $\text{Primary}$  |  包含$\text{Primary Key}$  |       不存在        | 按照`Student.ID`排序建立索引  |
> > > | $\text{Secondary}$ | 不包含$\text{Primary Key}$ |      可能存在       | 按照`Student.Age`排序建立索引 |

# $\text{2. Query Processing}$

> ## $\text{2.1. SELECTION Processing}$
>
> > ### $\text{2.1.1. }$有关参数
> >
> > > ==高亮为影响$\text{SELECTION}$开销的决定性参数== 
> > > 
> > > |              $\text{Factor}$              | 含义                                         |
> > > | :---------------------------------------: | :------------------------------------------- |
> > > |          ==$\text{NPages(I)}$==           | $\text{Index File}$一共有多少页              |
> > > |            $\text{NTuples(R)}$            | $\text{Data File}$一共有多少条数据           |
> > > |            $\text{NPages(R)}$             | $\text{Data File}$一共有多少页               |
> > > |       ==$\text{Result Size(RS)}$==        | $\text{Data File}$一共有多少页**是需要的**   |
> > > |     $\text{NTuplesPerPage}\text{(R)}$     | $\text{Data File}$每页存放多少条数据         |
> > > | $\text{Reduction Factor(RF)/Selectivity}$ | 有多少百分比的数据符合$\text{SELECTION}$条件 |
> > >
> > > **1️⃣**$\text{NTuples(R)=}\text{NPages(R)}\times\text{NTuplesPerPage}\text{(R)}$
> > >
> > > **2️⃣**$\text{NPages(R)}\xrightarrow[剩下的]{经过\text{WHERE + Condition}字句的筛选}\text{RS}$​
> > >
> > > - 例如整个表格有$\text{100}$页，经过`WHERE+condition`筛选后只有$\text{20}$页，那$\text{RS=20, RF=0.2}$​
> >
> > ### $\text{2.1.2. SELECTION Cost}$
> >
> > > **1️⃣**非索引情况下的开销($\text{Sorted File}$基本不考)
> > >
> > > | $\text{File Structure}$ |       $\text{Cost}$(单位是$\text{IO}$次数)       |               原理               |
> > > | :---------------------: | :----------------------------------------------: | :------------------------------: |
> > > |   $\text{Heap File}$    |                $\text{NPages(R)}$                | $\text{Heap Scan}$读取表中每一页 |
> > > |  $\text{Sorted File}$   | $\log_{2}\text{[NPages(R)]+RF×}\text{NPages(R)}$ |   二分查找定位$+$所需读多少页    |
> > >
> > > **2️⃣**索引情况下的开销
> > >
> > > |    $\text{Index}$实现     |    $\text{Index}$存储/角色     |                             开销                             |
> > > | :-----------------------: | :----------------------------: | :----------------------------------------------------------: |
> > > | $\text{B}^{+}\text{Tree}$ |     $\text{Primary Index}$     |                 $\text{树高Height(Index)+1}$                 |
> > > |       $\text{Hash}$       |     $\text{Primary Index}$     |     $\text{ProbeCost(Index)+1}\xrightarrow{默认为}1.2+1$     |
> > > | $\text{B}^{+}\text{Tree}$ | ==$\text{Unclustered index}$== | $\text{[NPages(I)+NTuples(R)]×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}$ |
> > > | $\text{B}^{+}\text{Tree}$ |  ==$\text{Clustered index}$==  | $\text{[NPages(I)+NPages(R)]×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}$ |
> > > |       $\text{Hash}$       |   $\text{Unclustered index}$   | $\text{NTuples(R)×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}\times{}2.2$ |
> > > |       $\text{Hash}$       |    $\text{Clustered index}$    | $\text{NPages(R)×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}\times{}2.2$ |
> > >
> > > 1. $\text{Unclustered/Clustered index}$的两部分开销为读取所需$\text{Index+Page}$
> > > 2. $\text{Unclustered index}$中$\text{NTuples(R)}$是因为此时读取需要反复回到$\text{Index File}$​
> > > 3. 多个$\text{RF}$​都需要乘起来，至于有多少个，取决于`WHERE`子句后面是什么
> >
> > ### $\text{2.1.3. SELECTION Cost}$补充：$\text{RF Estimate}$ 
> >
> > > **1️⃣**基本假设：$\text{Assume Uniform Distribution}$
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/82928265853.png" alt="82928265853" style="zoom: 38%;" /> 
> > >
> > > **2️⃣**简单情况下的$\text{RF}$估算
> > >
> > > 1. 参数含义
> > >
> > >    |        参数         |                    含义                    |
> > >    | :-----------------: | :----------------------------------------: |
> > >    | $\text{NKeys(Col)}$ | 一列中含有多少种独一无二的值，即`DISTINCT` |
> > >    | $\text{High(Col)}$  |               一列种的最高值               |
> > >    |  $\text{Low(Col)}$  |               一列种的最低值               |
> > >
> > > 2. $\text{RF}$​估算
> > >
> > >    |         条件         |                       $\text{RF}$等于                        |      $\text{SQL}$示例       |       备注       |
> > >    | :------------------: | :----------------------------------------------------------: | :-------------------------: | :--------------: |
> > >    | ${}\text{Col=Value}$ |           $\cfrac{\text{Num}}{\text{NKeys(Col)}}$            | `level=5,6`$\text{(Num=2)}$ | ==处理离散变量== |
> > >    |  $\text{Col>Value}$  | $\cfrac{\text{High(Col)}-\text{Value}}{\text{High(Col)}-\text{Low(Col)}}$ |          `time>8`           | ==变量必须连续== |
> > >    |  $\text{Col<Value}$  | $\cfrac{\text{Value}-\text{Low(Col)}}{\text{High(Col)}-\text{Low(Col)}}$ |          `time<8`           | ==变量必须连续== |
> > >
> > >    - 离散变量的不等条件可以转化为相等条件
> > >    - 假设有$\text{10}$个$\text{Level}$，则$\text{Level>7}$可以转化为$\text{Level=8,9,10}\to{}\text{Num=3}$​
> > >
> > > **3️⃣**$\text{Join}$操作下的$\text{RF}$估算：$\text{RF}=\cfrac{1}{\text{Max[NKeys(JoinCol\_A), NKeys(JoinCol\_B)]}}$
> > >
> > > 1. 示例：$\text{Student/Subject}$是两个$\text{JoinCol}$
> > >
> > >    ```sql
> > >    Student INNER JOIN Subject ON Student.stuid=Subject.stuid
> > >    ```
> > >
> > >
> > > 2. $\text{Primary Key}$所在列$\text{JoinCol}$唯一值更多​
> > >
> > >    | $\text{Entity}$ |   $\text{Student}$   |   $\text{Subject}$   |
> > >    | :-------------: | :------------------: | :------------------: |
> > >    |     `stuid`     | $\text{Primary Key}$ | $\text{Foreign Key}$ |
> > >
> > >    此处$\text{RF}=\cfrac{1}{\text{NTuples(Student)}}$ 
> > >
> > > 3. 特殊情况：
> > >
> > >    - 若$\text{Student}$筛选剩下$\text{20\%}$再去$\text{Join}$，$\text{RF}$计算无需$\text{×20\%}$，永远保持原来的大小。因为$\text{Subject}$中还有未被筛选的那$\text{80\% Student}$​数据
> > >    
> > >    - 如下例子中：两种情况下$\text{NLJ}$都有$\text{RF}=\text{RF(Test}\bowtie{}\text{DTR)}$​   
> > >    
> > >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/41570539127.png" alt="41570539127" style="zoom:39.9%;" /> 
> > >
> > > **4️⃣**玄学情况：比如告诉你`age=5`但是不告诉你`DISTINCT age`的数量，则默认$\text{RF=}\cfrac{1}{10}$
> > >
> > > **5️⃣**$\text{RF}$​估算的优化​
> > >
> > > 1. 存在的问题：数据不可能是平均分布的，如果数据集中向一个方向靠近，误差就会很大
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240512175609718.png" alt="image-20240512175609718" style="zoom: 43%;" /> 
> > >
> > > 2. 优化方法$\text{1: Variable-Width Histogram}$​(柱状图)
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240512180432571.png" alt="image-20240512180432571" style="zoom:40%;" /> 
> > >
> > >    - 分$\text{Bucket}\to{}$尽量每个$\text{Bucket}$中数量差不多$\to{}$再去用$\text{Bucket}$估计
> > >    - 估算`age=5`(在$\text{Bucket1}$里)：$\text{RF=}\cfrac{1}{共4个\text{Bucket}\times{}\text{Bucket1}里有5个值}=\cfrac{1}{20}$​
> > >
> > > 3. 优化方法$\text{2: }$取样出一部分数据，得出大致的数据分布
> >
> > ### $\text{2.1.4. SELECTION Condition:}$​如何处理`WHERE`子句
> >
> > > **1️⃣**原理
> > >
> > > 1. 寻找最便宜的$\text{Access Path}$：估算成本($\text{IO}$次数)
> > >    - 利用==索引匹配的谓词==来计算$\text{RF}$，从而达到简化效果​
> > >    - $\text{Apply other predicates on-the-fly}$(实时)
> > > 2. 选取成本最小的方式($\text{Index}$或$\text{File Scan}$)
> > >
> > > **2️⃣**索引匹配的谓词：$\text{Composite Search Key}$与`WHERE + Condition`匹配
> > >
> > > 1. 匹配条件：
> > >
> > >    - `WHERE + Condition`要包含$\text{Composite Search Key}$的$\text{Prefix}$​
> > >    - `WHERE + Condition`中`AND`的顺序不重要
> > >
> > > 2. 匹配示例：`<a,b,c>`的$\text{Prefix}$包含`a/ab/abc`
> > >
> > >    | $\text{Composite Search Key}$ | $\text{ WHERE Conditions}$  | 匹配的$\text{Prefix}$ |
> > >    | :---------------------------: | :-------------------------- | :-------------------- |
> > >    |           `<a,b,c>`           | `WHERE a=1`                 | `a`                   |
> > >    |           `<a,b,c>`           | `WHERE a=1 AND b=2`         | `a,b`                 |
> > >    |           `<a,b,c>`           | `WHERE a=1 AND b=2 AND c=3` | `a,b,c`               |
> > >    |           `<a,b,c>`           | `WHERE a=1 AND b=2 AND d=3` | `a,b`                 |
> > >    |           `<a,b,c>`           | `WHERE a=1 AND c=2`         | `a`                   |
> > >    |           `<a,b,c>`           | `WHERE b=2 AND c=3`         | `NULL`                |
> > >
> > > **3️⃣**基于索引匹配的谓词的$\text{RF}$​计算示例
> > >
> > > | $\text{Composite Search Key}$ | $\text{ WHERE Conditions }$ | 匹配的$\text{Prefix}$ |     $\text{RF}$     |
> > > | :---------------------------: | :-------------------------- | :-------------------: | :-----------------: |
> > > |           `<a,b,c>`           | `WHERE a AND c`             |          `a`          |   $\text{RF(a)}$    |
> > > |            `<a,c>`            | `WHERE a AND b AND c`       |         `a,c`         | $\text{RF(a)RF(c)}$ |
> > >
> > > **4️⃣**其他注意事项：$\text{Hash}不能作\text{Range Search}$，见如下的综合示例中$\text{Day}$是$\text{Range Search}$
> > >
> > > ```sql
> > > WHERE day<8/9/94 AND bid=5 AND sid=3
> > > ```
> > >
> > > |       $\text{Type}$       | $\text{Index}$ | $匹配的\text{Prefix}$ |      是否适用于示例的查询       |       $\text{RF}$        |
> > > | :-----------------------: | :------------: | :-------------------: | :-----------------------------: | :----------------------: |
> > > | $\text{B}^{+}\text{Tree}$ | `<rname,day>`  |     $\text{N/A}$      | $\text{N}(无匹配\text{Prefix})$ |        $\text{1}$        |
> > > | $\text{B}^{+}\text{Tree}$ | `<day,rname>`  |         `day`         |           $\text{Y}$            |     $\text{RF(day)}$     |
> > > | $\text{B}^{+}\text{Tree}$ |  `<day,sid>`   |       `day,sid`       |           $\text{Y}$            | $\text{RF(day)*RF(sid)}$ |
> > > |       $\text{Hash}$       | `<day,rname>`  |         `day`         |  $\text{N(Hash不能范围搜索)}$   |        $\text{1}$        |
>
> ## $\text{2.2. Projection}$(很少考)
>
> > ### $\text{2.2.1. Overview}$
> >
> > > **1️⃣**投影$\text{Process}$的流程
> > >
> > > |             场所             | 操作                                         |
> > > | :--------------------------: | -------------------------------------------- |
> > > |       磁盘$\to{}$内存        | 读取$\text{Data File}$中所有要处理的页到内存 |
> > > |       内存$\to{}$磁盘        | 在内存中投影(筛掉一些页)，剩下页写回磁盘     |
> > > | 磁盘(但排序时不断和内存交换) | 对投影后的页进行排序                         |
> > > |       磁盘$\to{}$内存        | 将投影+排序后的页，重新读回内存              |
> > >
> > > **2️⃣**为何$\text{Projection}$操作中需要$\text{Sort}$
> > >
> > > |                  原因                   | 解释                                                         |
> > > | :-------------------------------------: | ------------------------------------------------------------ |
> > > |            支持`DISTICT`操作            | ==去重时==，如果数据已经排序，那么合并相邻的相同记录即可     |
> > > | 提高$\text{B}^{+}\text{Tree}$的加载效率 | 已排序的数据插入$\text{B}^{+}\text{Tree}$时，不太可能导致大量的节点重新分配 |
> > > |           优化`GROUP BY`操作            | 比如按照`Age`分类，需要直到有几种`Age`，那就需要排序         |
> > >
> > > - 关于==去重==：$\text{Projection}$可能会$\text{Removing duplicates}$，例如假设$\text{20}$个员工隶属于$\text{4}$​个部门
> > >
> > >   ```sql
> > >   SELECT Depart FROM Employees;         -- 返回20个员工的20个部门(共20行)
> > >   SELECT DISTINCT Depart FROM Employees;-- 返回20个员工的4种部门(共4行)
> > >   ```
> > >
> > > **3️⃣**投影处理的决定因素$\text{Projection Factor(PF)}$：即选取的$\text{Column}$占$\text{Column}$​总数的比
> >
> > ### $\text{2.2.2. External Merge Sort: Divide \& Conquer}$(分治)
> >
> > > **1️⃣**排序原理
> > >
> > > |   $\text{Trem}$    |                   含义                    |
> > > | :----------------: | :---------------------------------------: |
> > > |  $\text{Passes}$   |     排序过程中数据读写硬盘的循环次数      |
> > > | $\text{NumPasses}$ | $\text{Passes}$数量(分多少次可以完成排序) |
> > > |   $\text{Runs}$    |            已排序的有序数据段             |
> > > |   $\text{N-Way}$   |     每次合并$\text{N}$个$\text{Runs}$     |
> > >
> > > 1. 分割整个数据集为多个小$\text{Runs}\to{}$每个$\text{Runs}$加载进内存排好序$\to{}$排序后的$\text{Runs}$写回磁盘
> > > 2. 将磁盘中的$\text{Runs}$有序合并为有关大的$\text{Runs}$​
> > >
> > > **2️⃣**$\text{2-Way External Merge Sort}$示例
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/33983312621.png" alt="33983312621" style="zoom:55%;" />  
> > >
> > > |     $\text{Trem}$      |                $\text{Value}$                |                       $\text{E.g.}$                        |
> > > | :--------------------: | :------------------------------------------: | :--------------------------------------------------------: |
> > > |   $\text{NumPasses}$   | $1 + \lceil \log_2 [\text{NPages(R)]}\rceil$ | $1 + \lceil \log_2 \text{7}\rceil=1 + \lceil 2.3\rceil=3 $ |
> > > | $\text{Total IO Cost}$ |        $\text{2×NPages(R)×NumPasses}$        |              $\text{2}\times{}7\times{}3=42$               |
> > >
> > > **3️⃣**基于外归并排序的$\text{Projection}$开销：等于以下每列之和(==记下即可==)
> > >
> > > | 步骤 | 操作                                             | $\text{Cost}$值                   |
> > > | :--: | ------------------------------------------------ | :-------------------------------- |
> > > | 读取 | 读取表($\text{Data File}$)中所有要排序的页到内存 | $\text{NPages(R)}$                |
> > > | 投影 | 投影筛掉一些页，将投影后的页写回磁盘             | $\text{NPages(R)×PF}$             |
> > > | 排序 | 对投影后的数据排序(每轮都要读写一次)             | $\text{NPages(R)×PF×2×NumPasses}$ |
> > > | 写回 | 将投影+排序后的页，重新读回内存                  | $\text{NPages(R)×PF}$             |
> >
> > ### $\text{2.2.3. External Hashing}$
> >
> > > **1️⃣**原理
> > >
> > > 1. 第一轮：内存有限$\to{}1$页用作缓存$+$剩下$\text{B-1}$页当作$\text{Bucket}$​
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/30913827511.png" alt="image-20240511073935359" style="zoom: 47%;" />  
> > >
> > >    - 硬盘的每页$\xrightarrow[缓存]{读取}$内存中的缓存页
> > >    - 缓存页的数据$\xrightarrow[\text{Hash}]{\text{H1}}$剩下的$\text{B-1}$个$\text{Bucket}$​中
> > >    - 满了的$\text{Bucket}\xrightarrow{读出}$硬盘中**若干**页(由于不够细分一个$\text{Bucket}$​​可能输出多页)
> > >    - 最终硬盘中有$\text{Bucket1→Bucket(B-1)}$共$\text{B-1}$个$\text{Bucket}$，每个$\text{Bucket}$中有若干页
> > >
> > > 2. 第二轮：试图用有限内存充分分类
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/13807891517.png" alt="13807891517" style="zoom:45%;" />  
> > >
> > >    - 硬盘$\text{Bucket1}$的每页/$\text{Bucket2}$的每页/..../$\text{Bucket(B-1)}$的每页$\xrightarrow[缓存]{读取}$内存中的缓存页
> > >    - 缓存页的数据$\xrightarrow[\text{Hash}]{\text{H2(注意是一个新的Hash函数)}}$新的$\text{B-1}$个$\text{Bucket}$​中
> > >    - 以此类推.............
> > >
> > > 3. 最后一轮：所有的数据得到了充分的细分，以至于最后每个$\text{Bucket}$​中只包含一个数据
> > >
> > > **2️⃣**基于$\text{External Hashing}$的$\text{Projection}$开销
> > >
> > > | 步骤 | 操作                                             | $\text{Cost}$值       |
> > > | :--: | ------------------------------------------------ | :-------------------- |
> > > | 读取 | 读取表($\text{Data File}$)中所有要排序的页到内存 | $\text{NPages(R)}$    |
> > > | 投影 | 投影筛掉一些页，将投影后的页写回磁盘             | $\text{NPages(R)×PF}$ |
> > > | 写回 | 将投影后的页，重新读回内存                       | $\text{NPages(R)×PF}$ |
>
> ## $\text{2.3. Join Algorithms}$ 
>
> > ### $\text{2.3.1. Nested Loops Join}$
> >
> > > **0️⃣**关于$\text{Inner/Outer Table}$​
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240511093730591.png" alt="image-20240511093730591" style="zoom:59%;" />  
> > >
> > > 1. 如果可以选$\text{→}$一般设定$\text{Outer}$为$\text{NPages}$​较小的表
> > > 2. 默认左边是$\text{Outer}$右边是$\text{Inner}$
> > >
> > > **1️⃣**原理
> > >
> > > |     $\text{Type}$      | $\text{Outer Table}$的每___ | $\xrightarrow{扫描}$ | $\text{Inner Table}$的每___ |
> > > | :--------------------: | :-------------------------: | :------------------: | :-------------------------: |
> > > |    $\text{Simple}$     |             行              | $\xrightarrow{扫描}$ |             页              |
> > > | $\text{Page-Oriented}$ |             页              | $\xrightarrow{扫描}$ |             页              |
> > > |     $\text{Block}$     |       块(包含多个页)        | $\xrightarrow{扫描}$ |             页              |
> > >
> > > **2️⃣**示意图与工作流程
> > >
> > > 1. $\text{Simple Nested Loops Join}$​
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240511123035510.png" alt="image-20240511123035510" style="zoom: 26.5%;" />  
> > >
> > >    |       $\text{Outer Page}$       |  $\text{Inner Page}$  |
> > >    | :-----------------------------: | :-------------------: |
> > >    | $\text{Outer Page 1, Tuple 1}$  | $\text{Inner Page 1}$ |
> > >    | $\text{Outer Page 1, Tuple 1}$  | $\text{Inner Page 2}$ |
> > >    | $\text{Outer Page 1, Tuple 1}$  | $\text{Inner Page 3}$ |
> > >    | $\text{Outer Page 1, Tuple 1}$  | $\text{Inner Page 4}$ |
> > >    | $\text{Outer Page 1, Tuple 2}$  | $\text{Inner Page 1}$ |
> > >    |              .....              |         .....         |
> > >    | $\text{Outer Page 10, Tuple N}$ | $\text{Inner Page 4}$ |
> > >
> > > 2. $\text{Page-Oriented Nested Loops Join}$
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240511101634537.png" alt="image-20240511101634537" style="zoom:50%;" />  
> > >
> > >    |  $\text{Outer Page}$   |  $\text{Inner Page}$  |
> > >    | :--------------------: | :-------------------: |
> > >    | $\text{Outer Page 1}$  | $\text{Inner Page 1}$ |
> > >    | $\text{Outer Page 1}$  | $\text{Inner Page 2}$ |
> > >    | $\text{Outer Page 1}$  | $\text{Inner Page 3}$ |
> > >    | $\text{Outer Page 1}$  | $\text{Inner Page 4}$ |
> > >    | $\text{Outer Page 2}$  | $\text{Inner Page 1}$ |
> > >    |         .....          |         .....         |
> > >    | $\text{Outer Page 10}$ | $\text{Inner Page 4}$ |
> > >
> > > 3. $\text{Block Nested Loops Join}$   
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240513080234516.png" alt="image-20240513080234516" style="zoom:33%;" /> 
> > >
> > >    |              $\text{Outer Page}$              |  $\text{Inner Page}$  |
> > >    | :-------------------------------------------: | :-------------------: |
> > >    | $\text{Outer Page 1 + Outer Page 2(Block1)}$  | $\text{Inner Page 1}$ |
> > >    | $\text{Outer Page 1 + Outer Page 2(Block1)}$  | $\text{Inner Page 2}$ |
> > >    | $\text{Outer Page 1 + Outer Page 2(Block1)}$  | $\text{Inner Page 3}$ |
> > >    | $\text{Outer Page 1 + Outer Page 2(Block1)}$  | $\text{Inner Page 4}$ |
> > >    | $\text{Outer Page 3 + Outer Page 4(Block2)}$  | $\text{Inner Page 1}$ |
> > >    |                     .....                     |         .....         |
> > >    | $\text{Outer Page 9 + Outer Page 10(Block5)}$ | $\text{Inner Page 4}$ |
> > >
> > > **3️⃣**开销：外表扫描成本$+$内表扫描成本
> > >
> > > |     $\text{Type}$      |      外表扫描成本      |                    内表扫描成本                     |
> > > | :--------------------: | :--------------------: | :-------------------------------------------------: |
> > > |    $\text{Simple}$     | $\text{NPages(Outer)}$ | $\text{NTuples(Outer)}\text{×}\text{NPages(Inner)}$ |
> > > | $\text{Page-Oriented}$ | $\text{NPages(Outer)}$ | $\text{NPagees(Outer)}\text{×}\text{NPages(Inner)}$ |
> > > |     $\text{Block}$     | $\text{NPages(Outer)}$ | $\text{NBlocks(Outer)}\text{×}\text{NPages(Inner)}$ |
> > >
> > > 1. 外表所有页都要被读一次，所以成本为$\text{NPages(Outer)}
> > > 2. $\text{NBlocks(Outer)=NPages(Outer)/(Memory-2)}$
> > >    - $\text{Memory-2}$为$\text{RAM}$中$\text{Outer Pages}$的数量，即一次从$\text{Outer Table}$​读入多少页
> > >    - 当$\text{NBlocks(Outer)}$​​​​​不为整数时，要==向上取整==
> > >    - 分配$\text{RAM(Memory)}$越多，就会$\text{NBlocks(Outer)}$越低，从而开销越小
> > >
> > > **4️⃣**开销的最优解：$\begin{cases}\text{RAM}可把\text{Outer Table}全放进\to{}大小至少为\text{NPages(Outer)+2}\\\\最优解\to{}\text{Cost=NPages(Outer)+NPages(Inner)}\end{cases}$
> > >
> > > 1. 这其实不仅是$\text{NLJ}$​的最优解，==也是全局最优解，因为这个解刚好是把两个表读进来==
> > >
> > > 2. 在最优解不变的情况下为了节省内存$\to{}$==$\text{Outer}$表要尽量小(小表)==
> >
> > ### $\text{2.3.2. Sort-Merge Join}$ 
> >
> > > **1️⃣**原理：以`A INNER JOIN B ON A.age = B.number`为例
> > >
> > > 1. 第一步：按照$\text{Join Column}$(此处分别为`age`和`number`)排序
> > >    - $\text{A}$表按照`age`排序
> > >    - $\text{B}$​表按照`numver`排序
> > > 2. 第二步：$\text{AB}$两表再进行$\text{Join}$​操作(==让相同/相关的值物理上靠近，可以顺序访问，加快合并==)
> > > 3. $\text{Output}$: 一定是按照$\text{Join Column}$排好序的
> > >
> > > **2️⃣**排序的成本为$\text{0}$的情况：$\text{Clustered + }$$\text{B}^{+}\text{Tree + }$$\text{Join Column}$是索引依据的$\text{Prefix}$​
> > >
> > > ```sql
> > > A INNER JOIN B ON A.age = B.number
> > > ```
> > >
> > > | 索引根据($\text{Composite Search Key}$) |          索引类型          | 表$\text{A}$无需排序 |
> > > | --------------------------------------- | :------------------------: | :------------------: |
> > > | `<A.age>`                               | $\text{Clustered B}^{+}$树 |          ✔️           |
> > > | `<A.name>`                              | $\text{Clustered B}^{+}$树 |          ❌           |
> > > | `<A.age, A.name>`                       | $\text{Clustered B}^{+}$树 |          ✔️           |
> > > | `<A.name, A.age>`                       | $\text{Clustered B}^{+}$树 |          ❌           |
> > >
> > > **3️⃣**$\text{Cost = Sort(Outer)+ Sort(Inner)+ NPages(Outer)+ NPages(Inner)}$ 
> > >
> > > |     $\text{Cost}$      |              成因              |
> > > | :--------------------: | :----------------------------: |
> > > |  $\text{Sort(Outer)}$  |       将外表所有元素排序       |
> > > |  $\text{Sort(Inner)}$  |       将内表所有元素排序       |
> > > | $\text{NPages(Outer)}$ | 遍历外表的所有页以执行合并操作 |
> > > | $\text{NPages(Inner)}$ | 遍历内表的所有页以执行合并操作 |
> > >
> > > - $\text{Sort(X)=}\begin{cases} \text{2×NumPasses×NPages(X)}\\\\0\text{ (Clustered B}^{+}\text{ Index on Join Column Prefix)}\end{cases}$ 
> >
> > ### $\text{2.3.3. Hash Join}$(一般情况开销最小)
> >
> > > **1️⃣**原理：以按照`A.id = B.id`$\text{Join}$为例，其中`id`为连接键
> > >
> > > 1. $\text{Build Phase}$: `A.id`$\xrightarrow[\text{Hash}]{\text{H1哈希函数}}$​`H1(A.id)`构建$\text{Hash}$表$\text{A}$，==通常是选小表($\text{Inner}$)来构建$\text{Hash}$表==
> > > 2. $\text{Probe Phase}$(探测阶段):  
> > >    - `B.id`$\xrightarrow[\text{Hash}]{\text{H1哈希函数}}$`H1(B.id)`得到$\text{Hash}$值$\text{B(n)}$ 
> > >    - 在$\text{Hash}$表$\text{A}$中检索$\text{Hash}$​值$\text{B(n)}$则匹配，那么匹配的行进行$\text{Join}$
> > >
> > > **2️⃣**$\text{Cost=3×NPages(Outer)+3×NPages(Inner)}$​​​ ​
> >
> > ### $\text{2.3.4. Join Pipeline}$：减少$\text{Cost}$的一种方式
> >
> > > **1️⃣**$\text{Left-Deep Join Tree}$：
> > >
> > > 1. 执行多重$\text{Join}$的最优顺序，方便在$\text{RAM}$​​中并行处理
> > >
> > > 2. 默认左边的为$\text{Outer Table}$
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240512191103986.png" alt="image-20240512191103986" style="zoom: 43%;" />  
> > >
> > >  
> > >
> > > **2️⃣**$\text{Pipeline}$
> > >
> > > 1. 概念：
> > >
> > >    - $\text{Direct “streaming” in memory}$
> > >    - $\text{Of the output of one operation as the input of another operation}$
> > >    - $\text{Without writing output to disk}$
> > >
> > > 2. 基于$\text{Left-Deep Join Tree}$的$\text{Pipeline}$​​示例
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240513002106358.png" alt="image-20240513002106358" style="zoom: 67%;" /> 
> > >
> > >    | $\text{Stage}$ |             $\text{Outer Page}$              | $\text{Inner Page}$ | $\text{Output Page}$                                         |
> > >    | :------------: | :------------------------------------------: | :-----------------: | :----------------------------------------------------------- |
> > >    |   $\text{1}$   |                  $\text{A}$                  |     $\text{B}$      | $\text{A}\bowtie{}\text{B}\xrightarrow{\text{Move to}}\text{Outer Page}$ |
> > >    |   $\text{2}$   |         $\text{A}\bowtie{}\text{B}$          |     $\text{C}$      | $\text{A}\bowtie{}\text{B}\bowtie{}\text{C}\xrightarrow{\text{Move to}}\text{Outer Page}$ |
> > >    |   $\text{3}$   | $\text{A}\bowtie{}\text{B}\bowtie{}\text{C}$ |     $\text{D}$      | $\text{A}\bowtie{}\text{B}\bowtie{}\text{C}\bowtie{}\text{D}\xrightarrow{\text{Finally}}\text{Output}$ |
> > >
> > > **3️⃣**$\text{Pipeline}$​中的简化计算$\text{1}$：$\text{Heap Scan}$不算$\text{Cost + }$上层$\text{Join}$也不减其$\text{Pipelining}$​
> > >
> > > 1. 原因：$\text{Heap Scan}$扫描的成本，和其对应减去的$\text{Pipelining}$，都等于对应表大小，互相抵消
> > >
> > > 2. 示例$\text{1: Join}$(顶层)开销$\text{=NLJ}$开销
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/49521839130.png" alt="49521839130" style="zoom:30%;" /> 
> > >
> > > 3. 示例$\text{2: Join}$(顶层)开销$\text{=SMJ}$开销$-\text{RSA(Result Size A)}$，==注意$\text{RSA}$是以$\text{Pages}$为单位==
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/77537735808.png" alt="77537735808" style="zoom:30%;" />  
> > >
> > >
> > > **4️⃣**$\text{Pipeline}$中的简化计算$\text{2: Heap Scan}$自动忽略所有$\text{Index}$

# $\text{3. Query Optimization}$

> ## $\text{3.1. Relational Algebra Equivalences}$
>
> > ### $\text{3.1.1. Selection/Projection Equivalences}$
> >
> > > **1️⃣**概览
> > >
> > > |               定律                |                             公式                             |          含义           |
> > > | :-------------------------------: | :----------------------------------------------------------: | :---------------------: |
> > > | $\small\text{Selection Cascade}$  | $\sigma_{\text{c}_1 \wedge \cdots \wedge \text{c}_\text{n}}(\text{R})\equiv \sigma_{\text{c}_1}\left(\ldots\left(\sigma_{\text{c}_\text{n}}(\text{R})\right)\right)$ | 多条件筛行$=$每个都筛下 |
> > > | $\small\text{Selection Commute}$  | $\sigma_{\text{c}_\text{1}}\left(\sigma_{\text{c}_2}(\text{R})\right)\equiv \sigma_{\text{c}_2}\left(\sigma_{\text{c}_\text{1}}(\text{R})\right)\equiv{}\sigma_{\text{c}_\text{1} \wedge \text{c}_\text{2}}(\text{R})$ | 先用哪个条件筛选无所谓  |
> > > | $\small\text{Projection Cascade}$ | $\pi_{\text{a}_\text{1}}(R) \equiv \pi_{\text{a}_\text{1}}\left(\ldots\left(\pi_{\text{a}_n}(R)\right)\right)$ | 随便投，最后一下说了算  |
> > >
> > > ⚠️注意事项：$\text{Projection Cascade}$中，假设$\text{A}$是$\text{Attributes}$的集合$\left(\text{A=}\{\text{a}_\text{1},\text{a}_2,...,\text{a}_\text{n}\}\right)$
> > >
> > > 1. 在$\pi{_{\text{A}_\text{1}}}(\ldots(\pi{_{\text{A}}}_\text{n}(\text{R})))$中，必须满足$\text{A}_{\text{n}}\subseteq{}\text{A}_{\text{m}}(\text{n<m})$
> > >
> > > 2. 以$\pi{_{\text{A}_\text{1}}}(\pi{_{\text{A}}}_\text{2}(\text{R}))$为例
> > >
> > >    |       ${\text{A}_\text{1}}$        |                    ${\text{A}_\text{2}}$                     |             是否适用$\text{Projection Cascade}$              |
> > >    | :--------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
> > >    | $\{\text{a}_\text{1},\text{a}_2\}$ |              $\{\text{a}_\text{1},\text{a}_2\}$              | $\text{A}_{\text{1}}\subseteq{}\text{A}_{\text{2}}\to{}\pi{_{\text{a}_\text{1},\text{a}_\text{2}}}(\pi{_{\text{a}_\text{1},\text{a}_\text{2}}}(\text{R}))=\pi{_{\text{a}_\text{1},\text{a}_\text{2}}}(\text{R})$ |
> > >    | $\{\text{a}_\text{1},\text{a}_2\}$ | $\{\text{a}_\text{1},\text{a}_2,\text{a}_\text{3},\text{a}_4\}$ | $\text{A}_{\text{1}}\subseteq{}\text{A}_{\text{2}}\to{}\pi{_{\text{a}_\text{1},\text{a}_\text{2}}}(\pi{_{\text{a}_\text{1},\text{a}_\text{2},\text{a}_\text{3},\text{a}_\text{4}}}(\text{R}))=\pi{_{\text{a}_\text{1},\text{a}_\text{2}}}(\text{R})$ |
> > >    | $\{\text{a}_\text{1},\text{a}_4\}$ |     $\{\text{a}_\text{1},\text{a}_2,\text{a}_\text{3}\}$     | $\text{A}_{\text{1}} \not\subseteq{}\text{A}_{\text{2}}$不适用 |
> > >
> > > **2️⃣**示例：关于第$\text{3}$个，注意要让==外部操作的$\text{Column}\subseteq$ 里面表$\text{Column}$==
> > >
> > > 1. $\large{}\sigma_{\text{age<18 }\wedge \text{ rating}>5}\text{(Sailors)}\Leftrightarrow\begin{cases} \sigma_{\text{age}<18}\left(\sigma_{\text{rating}>5}\text{(Sailors)}\right)\\\\ \left.\sigma_{\text{rating}>5}\left(\sigma_{\text{age}<18}\text{(Sailors}\right)\right)\end{cases}$ 
> > >
> > > $$
> > > 
> > > $$
> > >
> > > 2. $\large\pi_{\text{age,rating}}(\text{Sailors})\Leftrightarrow \pi_{\text{age,rating}}\left(\pi_{\text{age,rating,sid}}\text{(Sailors)}\right)$ ​
> > >
> > > $$
> > > 
> > > $$
> > >
> > > 3. $\large\begin{cases}\begin{flalign*}& \pi_{\text{age,sid}}( \sigma_{\text{age<18 }\wedge \text{ rating}>5}\text{(Sailors))} &\\& \Updownarrow &\\& \begin{cases}\text{错误的: }\sigma_{\text{age<18 } \wedge \text{ rating}>5}\left(\pi_{\text{age, sid}}(\text{Sailors})\right)\\\\\text{正确的: }\sigma_{\text{age<18 } \wedge \text{ rating}>5}\left(\pi_{\text{age, sid, rating}}(\text{Sailors})\right)\end{cases}&\\\end{flalign*}\end{cases}$​
> >
> > ### $\text{3.1.2. Join Equivalences}$
> >
> > > |           定律            |                             公式                             |               含义                |
> > > | :-----------------------: | :----------------------------------------------------------: | :-------------------------------: |
> > > | $\text{Join Associative}$ | $\text{R}\bowtie(\text{S} \bowtie \text{T})\equiv(\text{R}\bowtie \text{S})\bowtie \text{T} \quad$ | $\text{Join}$顺序不影响结果(三个) |
> > > | $\text{Join Commutative}$ | $(\text{R}\bowtie \text{S})\equiv(\text{S}\bowtie \text{R})\quad$ | $\text{Join}$顺序不影响结果(两个) |
> >
>
> ## $\text{3.2. }$$\text{Query Optimization}$实例
>
> > **1️⃣**$\text{Cross Product}$优化：转化为有条件的$\text{Join}$
> >
> > $\large{}\begin{flalign*}& \sigma_{\text{Sailors.sid=Reserves.sid}}(\text{Sailors} \text{×}\text{Reserves}) &\\& \Updownarrow &\\& \text{Sailors} \bowtie_{\text{Sailors.sid=Reserves.sid}} \text{Reserves} &\\& \Updownarrow &\\& \text{Sailors} \bowtie \text{Reserves }\end{flalign*}$
> >
> > **2️⃣**$\text{Predicate Pushdown: }$先给表格筛选$\to{}$降低数据量/减少计算
> >
> > $\large{}\begin{flalign*}
> > & \sigma_{\text{Sailors.age<18}}(\text{Sailors} \bowtie_{\text{Sailors.sid=Reserves.sid}} \text{Reserves}) &\\
> > & \Bigg\Updownarrow {\small{想办法把\text{Join}左边的\text{Sailors}表格变小}} &\\
> > &(\sigma_{\text{Sailors.age<18}}(\text{Sailors})) \bowtie_{\text{Sailors.sid=Reserves.sid}} \text{Reserves} &
> > \end{flalign*}$
> >
> > **3️⃣**$\text{Projection Pushdown: }$先给表格筛选$\to{}$降低数据量/减少计算
> >
> > $\large{}\begin{flalign*}
> > & \pi_{\text{Sailors.sname}}(\text{Sailors} \bowtie_{\text{Sailors.sid=Reserves.sid}} 
> > \text{Reserves})&\\
> > & \Bigg\Updownarrow {\small{想办法把\text{Join}左右的\text{Sailors/Reserves}表格变小}\to{}\text{把两张表中用得到的Column都Project出来}} &\\
> > &\pi_{\text{Sailors.sname}}(\pi_{\text{sname, sid}}
> > (\text{Sailors}) \bowtie_{\text{Sailors.sid=Reserves.sid}} \pi_{\text{sid}}(\text{Reserves})) &
> > \end{flalign*}$​ 

# $\text{4. Query Cost}$计算题​

> ## $\text{4.1. Of One Table}$
>
> > **1️⃣**原理：考虑各种可能的$\text{Query}$途径($\text{Scan/Index}$)$\to{}$选择开销最小的一个
> >
> > 1. 注意永远别忘了算一下$\text{Heap Scan}$，有时候算来算去反倒$\text{Heap Scan}$​​开销最小
> > 2. 除去$\text{Heap Scan}$其它所有类型的开销，都需要先估计$\text{RF }\downarrow{}$​
> >
> > **2️⃣**$\text{RF}$估算汇总
> >
> > |         条件         |                       $\text{RF}$等于                        |               补充说明               |
> > | :------------------: | :----------------------------------------------------------: | :----------------------------------: |
> > | ${}\text{Col=Value}$ |           $\cfrac{\text{Num}}{\text{NKeys(Col)}}$            |           ==处理离散变量==           |
> > |  $\text{Col>Value}$  | $\cfrac{\text{High(Col)}-\text{Value}}{\text{High(Col)}-\text{Low(Col)}}$ |           ==变量必须连续==           |
> > |  $\text{Col<Value}$  | $\cfrac{\text{Value}-\text{Low(Col)}}{\text{High(Col)}-\text{Low(Col)}}$ |           ==变量必须连续==           |
> > |  $\text{Join}$操作   |    $\cfrac{1}{\text{Max[NKeys(Col\_A), NKeys(Col\_B)]}}$     | 主键所在列$\text{JoinCol}$唯一值更多 |
> > |    无任何已知条件    |                  $\text{RF=}\cfrac{1}{10}$                   |                 默认                 |
> >
> > **3️⃣**基于`WHERE + Condition`的$\text{RF}$​​​选取
> >
> > ```sql
> > WHERE day<8/9/94 AND bid=5 AND sid=3
> > ```
> >
> > |       $\text{Type}$       | $\text{Index}$ | $匹配的\text{Prefix}$ |      是否适用于示例的查询       |       $\text{RF}$        |
> > | :-----------------------: | :------------: | :-------------------: | :-----------------------------: | :----------------------: |
> > | $\text{B}^{+}\text{Tree}$ | `<rname,day>`  |     $\text{N/A}$      | $\text{N}(无匹配\text{Prefix})$ |        $\text{1}$        |
> > | $\text{B}^{+}\text{Tree}$ | `<day,rname>`  |         `day`         |           $\text{Y}$            |     $\text{RF(day)}$     |
> > | $\text{B}^{+}\text{Tree}$ |  `<day,sid>`   |       `day,sid`       |           $\text{Y}$            | $\text{RF(day)*RF(sid)}$ |
> > |       $\text{Hash}$       | `<day,rname>`  |         `day`         |  $\text{N(Hash不能范围搜索)}$   |        $\text{1}$        |
> >
> > 1. 索引匹配的谓词：`WHERE + Condition`==必须要==包含$\text{Composite Search Key}$的$\text{Prefix}$
> > 2. $\text{Hash}$不能作$\text{Range Search}$
> >
> > **4️⃣**基于$\text{RF}$的$\text{Scan Cost Formula}$汇总
> >
> > |  $\text{Structure}$  |      $\text{Index}$实现       | $\text{Index}$存储/角色  |                             开销                             |
> > | :------------------: | :---------------------------: | :----------------------: | :----------------------------------------------------------: |
> > |  $\text{Heap File}$  |         $\text{N/A}$          |       $\text{N/A}$       |                      $\text{NPages(R)}$                      |
> > | $\text{Sorted File}$ |         $\text{N/A}$          |       $\text{N/A}$       |       $\log_{2}\text{[NPages(R)]+RF×}\text{NPages(R)}$       |
> > | $\text{index File}$  |   $\text{B}^{+}\text{Tree}$   |     $\text{Primary}$     |                 $\text{树高Height(Index)+1}$                 |
> > | $\text{index File}$  |         $\text{Hash}$         |     $\text{Primary}$     |     $\text{ProbeCost(Index)+1}\xrightarrow{默认为}1.2+1$     |
> > | $\text{index File}$  |   $\text{B}^{+}\text{Tree}$   | ==$\text{Unclustered}$== | $\text{[NPages(I)+NTuples(R)]×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}$ |
> > | $\text{index File}$  | ==$\text{B}^{+}\text{Tree}$== |  ==$\text{Clustered}$==  | $\text{[NPages(I)+NPages(R)]×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}$ |
> > | $\text{index File}$  |         $\text{Hash}$         | ==$\text{Unclustered}$== | $\text{NTuples(R)×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}\times{}2.2$ |
> > | $\text{index File}$  |         $\text{Hash}$         |  ==$\text{Clustered}$==  | $\text{NPages(R)×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}\times{}2.2$ |
> >
>
> # $\text{4.2. Of Multiple Tables}$
>
> > **1️⃣**需要考虑的问题
> >
> > |            事项             | 注释                                                         |
> > | :-------------------------: | ------------------------------------------------------------ |
> > | $\text{Join}$所有可能的顺序 | 这不会影响$\text{Join}$结果但会影响开销，一般只考虑$\text{Left-Deep Join Tree}$ |
> > | $\text{Join}$所有可能的算法 | 但是排除最蠢的$\text{Cross Product}$                         |
> >
> > **2️⃣**对$\text{Pipeline}$​的处理
> >
> > 1. $\text{Heap Scan}$不算$\text{Cost + }$上层$\text{Join}$也不减其$\text{Pipelining}$​
> > 2. $\text{Heap Scan}$自动忽略所有$\text{Index}$
> >
> > **3️⃣**$\text{Join Cost}$汇总：注意小表为$\text{Outer}$
> >
> > |        $\text{Type}$        | 扫描成本                                                     |
> > | :-------------------------: | :----------------------------------------------------------- |
> > |     $\text{Simple NLJ}$     | $\text{NPages(Outer)+}\text{NTuples(Outer)}\text{×}\text{NPages(Inner)}$ |
> > | $\text{Page-Oriented  NLJ}$ | $\text{NPages(Outer)+}\text{NPagees(Outer)}\text{×}\text{NPages(Inner)}$ |
> > |     $\text{Block  NLJ}$     | $\text{NPages(Outer)+}\text{NPages(Outer)/(Memory-2)}\text{×}\text{NPages(Inner)}$ |
> > |     $\text{Hash Join}$      | $\text{[NPages(Outer)+NPages(Inner)]×3}$                     |
> > |        $\text{SMJ}$         | $\text{[NPages(Outer)+NPages(Inner)]×(2×NumPasses+1)}$       |
> >
> > 1.  $\text{NPages(Outer)/(Memory-2)}$要==向上取整==
> > 2.  最优解：$\begin{cases}\text{RAM大小: }\text{NPages(Outer)+2}\\\\\text{开销: Cost=NPages(Outer)+NPages(Inner)}\end{cases}$​​ 
> > 3.  注意$\text{SMJ}$中可能出现$\text{Outer/Inner}$的$\text{NumPass}$不一样的情况，此时就要分开讨论
